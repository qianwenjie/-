<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>简便录入 - 考试系统</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <!-- KaTeX 公式渲染库 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: { 50: '#E6F9F0', 500: '#00B96B', 600: '#00A35C' },
            success: { 50: '#E8FFEA', 500: '#00B42A' },
            warning: { 50: '#FFF7E8', 500: '#FF7D00' },
            error: { 50: '#FFECE8', 500: '#F53F3F' },
            info: { 50: '#E8F7FF', 500: '#14C9C9' }
          }
        }
      }
    }
  </script>
  <style>
    /* 代码编辑器样式 */
    .code-editor {
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      line-height: 1.8;
      tab-size: 2;
    }

    /* contentEditable placeholder */
    #inputText[contenteditable]:empty:before {
      content: attr(data-placeholder);
      color: #9ca3af;
      pointer-events: none;
      white-space: pre-wrap;
      display: block;
    }

    /* 自定义滚动条 */
    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
      background: #f9fafb;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: #d1d5db;
      border-radius: 3px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: #9ca3af;
    }

    /* 题目卡片样式 */
    .question-card {
      transition: all 0.2s ease;
    }
    .question-card:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }

    /* 错误提示样式 */
    .error-text {
      background-color: #FFF1F0;
      color: #F53F3F;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 13px;
    }

    /* 单选框样式 */
    .radio-option {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .radio-option:hover {
      background-color: #f9fafb;
    }
    .radio-option input[type="radio"] {
      width: 18px;
      height: 18px;
      margin-right: 10px;
      cursor: pointer;
    }

    /* 知识点树样式 */
    .knowledge-node {
      margin-bottom: 2px;
    }
    .knowledge-node .children-container {
      margin-top: 2px;
    }

    /* 拖拽光标指示器 */
    .drop-cursor {
      position: fixed;
      width: 2px;
      height: 1.2em;
      background-color: #00B96B;
      pointer-events: none;
      z-index: 1000;
      animation: blink 1s infinite;
    }
    .drop-cursor::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      width: 8px;
      height: 8px;
      background-color: #00B96B;
      border-radius: 50%;
    }
    .drop-cursor::after {
      content: '';
      position: absolute;
      bottom: -3px;
      left: -3px;
      width: 8px;
      height: 8px;
      background-color: #00B96B;
      border-radius: 50%;
    }
    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0.3; }
    }

    /* 内联公式样式 */
    .inline-formula-editable {
      display: inline-block;
      margin: 0 2px;
      padding: 2px 6px;
      background: #e0f2fe;
      border-radius: 3px;
      vertical-align: middle;
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    .inline-formula-editable:hover {
      background: #bae6fd;
    }

    /* 内联图片样式 */
    .inline-image-editable {
      display: inline-block;
      margin: 0 2px;
      padding: 2px 6px;
      background: #fef3c7;
      border-radius: 3px;
      color: #92400e;
      font-size: 12px;
      vertical-align: middle;
      cursor: pointer;
      user-select: none;
    }
    .inline-image-editable:hover {
      background: #fde68a;
    }
  </style>
</head>
<body class="bg-gray-50">
  <!-- 顶部导航栏 -->
  <header class="h-16 bg-white border-b border-gray-200 fixed top-0 left-0 right-0 z-50">
    <div class="flex items-center justify-between h-full px-6">
      <div class="flex items-center space-x-4">
        <div class="flex items-center space-x-2">
          <div class="w-8 h-8 bg-primary-500 rounded flex items-center justify-center">
            <i class="fas fa-graduation-cap text-white"></i>
          </div>
          <span class="text-xl font-semibold text-gray-900">考试系统</span>
        </div>
        <nav class="hidden md:flex items-center space-x-2 text-sm text-gray-600">
          <a href="../dashboard.html" class="hover:text-primary-500">首页</a>
          <i class="fas fa-chevron-right text-xs text-gray-400"></i>
          <a href="list.html" class="hover:text-primary-500">题库管理</a>
          <i class="fas fa-chevron-right text-xs text-gray-400"></i>
          <span class="text-gray-900 font-medium">简便录入</span>
        </nav>
      </div>
      <div class="flex items-center space-x-4">
        <img src="https://via.placeholder.com/32" alt="用户" class="w-8 h-8 rounded-full">
        <span class="text-sm text-gray-700 font-medium">管理员</span>
      </div>
    </div>
  </header>

  <!-- 主内容区 -->
  <div class="pt-16 h-screen flex flex-col">
    <!-- 顶部说明区 -->
    <div class="bg-blue-50 border-b border-blue-100 px-6 py-4">
      <div class="flex items-start justify-between">
        <div class="flex-1">
          <h3 class="text-sm font-semibold text-gray-900 mb-2">
            <i class="fas fa-info-circle text-blue-500 mr-2"></i>
            试题录入说明：
          </h3>
          <p class="text-sm text-gray-700">
            请手动输入或者粘贴内容到输入区（支持粘贴图片和插入公式），若有疑问可查看录入帮助
            <a href="javascript:showFormatGuide()" class="text-primary-500 hover:text-primary-600 ml-1">
              <i class="fas fa-question-circle"></i> 录入帮助
            </a>
          </p>
        </div>
        <div class="flex items-center space-x-3 ml-6">
          <span id="draftSaveTime" class="text-xs text-gray-500 hidden">
            <i class="fas fa-check-circle text-success-500 mr-1"></i>
            <span id="draftTimeText"></span>
          </span>
          <button onclick="saveDraft()" class="px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 hover:bg-gray-50 transition-colors">
            <i class="fas fa-save mr-2"></i>
            保存草稿
          </button>
          <button onclick="batchImport()" class="bg-primary-500 hover:bg-primary-600 text-white px-6 py-2.5 rounded-lg font-medium text-sm shadow-sm transition-colors">
            <i class="fas fa-check mr-2"></i>
            批量导入
          </button>
          <button id="errorButton" onclick="jumpToFirstError()" class="hidden px-4 py-2 bg-error-500 hover:bg-error-600 text-white rounded-lg text-sm font-medium transition-colors">
            <i class="fas fa-exclamation-triangle mr-2"></i>
            已有错误，请修改
          </button>
        </div>
      </div>
    </div>

    <!-- 左右分栏内容区 -->
    <div class="flex-1 flex overflow-hidden">
      <!-- 左侧：输入区 -->
      <div class="w-1/2 bg-white border-r border-gray-200 flex flex-col">
        <!-- 输入区头部 -->
        <div class="flex items-center justify-between px-6 py-3 border-b border-gray-200 bg-gray-50" style="height: 49px;">
          <div class="flex items-center space-x-4">
            <h3 class="text-sm font-semibold text-gray-900 flex items-center">
              <i class="fas fa-keyboard text-primary-500 mr-2"></i>
              输入区
            </h3>
            <span class="text-xs text-gray-500">关联知识点：</span>
            <button onclick="selectKnowledgePoints()" class="px-3 py-1.5 bg-primary-500 hover:bg-primary-600 text-white rounded text-xs font-medium transition-colors">
              选择知识点
            </button>
          </div>
          <div class="flex items-center space-x-2">
            <button onclick="insertImage()" class="w-8 h-8 flex items-center justify-center text-gray-500 hover:text-primary-500 hover:bg-gray-100 rounded transition-colors" title="粘贴图片">
              <i class="fas fa-image"></i>
            </button>
            <button onclick="insertFormula()" class="w-8 h-8 flex items-center justify-center text-gray-500 hover:text-primary-500 hover:bg-gray-100 rounded transition-colors" title="插入公式">
              <i class="fas fa-square-root-variable"></i>
            </button>
            <button onclick="clearInput()" class="w-8 h-8 flex items-center justify-center text-gray-500 hover:text-error-500 hover:bg-gray-100 rounded transition-colors" title="清空">
              <i class="fas fa-trash-alt"></i>
            </button>
          </div>
        </div>

        <!-- 文本输入框 -->
        <div class="flex-1 overflow-hidden relative">
          <!-- 隐藏的 textarea 用于存储纯文本数据 -->
          <textarea
            id="inputTextData"
            class="hidden"
          ></textarea>
          <!-- 可编辑的可视化区域 -->
          <div
            id="inputText"
            class="code-editor w-full h-full p-6 resize-none focus:outline-none custom-scrollbar text-sm overflow-y-auto"
            contenteditable="true"
            style="white-space: pre-wrap; word-wrap: break-word; font-family: 'Menlo', 'Monaco', 'Courier New', monospace; line-height: 1.5; color: #374151; min-height: 100%;"
            data-placeholder="单选题
4. 李白是哪个朝代的？
A. 唐
B. 宋
C. 元
D. 明
答案：A
答案解析：历史问题
知识点：yunti001

多选题
5. 明清是中国小说史上的繁荣时期。以下作品属于明清时期四大名著的有?
A. 红楼梦
B. 三国演义
C. 窦娥冤
D. 西厢记
答案：AB
知识点：yunti001，yunti002

判断题
3. 扩散现象说明物质的分子在永不停息地做无规则运动
答案：正确

填空题
2. 床前明月光，____。举头望明月，____。
答案：疑是地上霜；低头思故乡

简答题
7. 请论述全球化对国家政治产生了哪些深刻的影响？
答案：全球化对政府的治理提出了更高的要求。

完形填空
6. Most parents, I suppose, have had the experience of reading a bedtime story to their children. And they must have____how difficult it is to write a____children's book. Either the author has aimed too____, so that the children can't follow what is in his story, ____the story seems to be talking to the readers.
1)A. hoped  B. realized  C. told  D. speech
2)A. bad  B. interesting  C.new  D. good
3)A. long  B. short  C. high  D.training
4)A. or  B. but  C. and  D.offered
答案：BDCA

复合题
生活中处处都有科学常识，掌握基础生活知识，有助于提高生活质量和安全意识。
通过以下几道测试题，看看你对生活常识了解多少？
[多选题]
正确洗手可以有效预防疾病，洗手时应重点清洗哪些部位？
A. 手心
B. 手背
C. 手指
D. 指缝
答案：ABCD"
          ></div>
        </div>
      </div>

      <!-- 右侧：检查区 -->
      <div class="w-1/2 bg-gray-50 flex flex-col">
        <!-- 检查区头部 -->
        <div class="flex items-center justify-between px-6 py-3 border-b border-gray-200 bg-white" style="height: 49px;">
          <div class="flex items-center space-x-4">
            <h3 class="text-sm font-semibold text-gray-900 flex items-center">
              <i class="fas fa-clipboard-check text-primary-500 mr-2"></i>
              检查区
            </h3>
            <span class="text-xs">
              <span class="text-success-500 font-medium" id="successCountText">成功识别0题</span>
              <span class="text-gray-400 mx-2">|</span>
              <span class="text-error-500 font-medium" id="errorCountText">识别失败0题</span>
            </span>
            <button id="nextErrorBtn" onclick="jumpToNextError()" class="hidden px-3 py-1.5 bg-error-50 text-error-500 rounded text-xs font-medium hover:bg-error-100 transition-colors">
              下一处错误
            </button>
          </div>
        </div>

        <!-- 检查区内容 -->
        <div id="checkArea" class="flex-1 overflow-y-auto custom-scrollbar p-6">
          <!-- 初始空状态 -->
          <div id="emptyState" class="flex flex-col items-center justify-center h-full text-center">
            <div class="w-20 h-20 bg-gray-100 rounded-full flex items-center justify-center mb-4">
              <i class="fas fa-clipboard-list text-3xl text-gray-300"></i>
            </div>
            <h3 class="text-base font-medium text-gray-900 mb-2">暂无解析结果</h3>
            <p class="text-sm text-gray-500 max-w-md mb-4">
              在左侧输入区按照规范格式输入题目，系统将自动实时解析
            </p>
            <button onclick="showInputExample()" class="text-sm text-primary-500 hover:text-primary-600 font-medium">
              <i class="fas fa-eye mr-1"></i>
              查看输入范例
            </button>
          </div>

          <!-- 解析结果容器 -->
          <div id="parsedQuestions" class="space-y-4" style="display:none;">
            <!-- 动态生成题目卡片 -->
          </div>
        </div>

        <!-- 底部操作栏 -->
        <div id="bottomActions" class="px-6 py-4 border-t border-gray-200 bg-white flex items-center justify-between" style="display:none;">
          <div class="text-sm text-gray-600">
            共 <span id="totalCount" class="font-semibold text-gray-900">0</span> 道题目
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 格式说明弹窗 -->
  <div id="formatGuideModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden">
      <div class="flex items-center justify-between px-6 py-4 border-b border-gray-200">
        <h3 class="text-lg font-semibold text-gray-900">
          <i class="fas fa-book text-primary-500 mr-2"></i>
          简便录入格式说明
        </h3>
        <button onclick="closeFormatGuide()" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="overflow-y-auto custom-scrollbar p-6" style="max-height: calc(90vh - 140px);">
        <div class="prose prose-sm max-w-none">
          <h4 class="text-base font-semibold mb-3">基础规则</h4>
          <ul class="text-sm space-y-2 mb-6">
            <li>题目标号：支持 <code>1.</code> <code>1、</code> <code>1:</code> <code>1。</code> 四种格式</li>
            <li>答案字段：客观题必须含有 <code>答案：</code> 或 <code>答：</code>，主观题可不填</li>
            <li>解析字段：<code>答案解析：</code> 非必需</li>
            <li>知识点字段：必填，格式为 <code>知识点：知识点编号</code></li>
            <li>多知识点：知识点编号之间用 <code>，</code> <code>、</code> <code>；</code> 隔开</li>
          </ul>

          <h4 class="text-base font-semibold mb-3">题型特殊规则</h4>
          <ul class="text-sm space-y-2 mb-6">
            <li><strong>判断题：</strong>选项支持 正确/错误、对/错、是/否、T/F 等</li>
            <li><strong>填空题：</strong>空位用 <code>____</code> 或 <code>（）</code> 标识；多空答案用 <code>；</code> 隔开；同义词用 <code>|||</code> 连接</li>
            <li><strong>完形填空：</strong>子题格式为 <code>1)A. 选项1  B. 选项2  C. 选项3  D. 选项4</code>（序号后不加空格）</li>
            <li><strong>复合题：</strong>子题格式为 <code>1）【题型】题干内容</code></li>
          </ul>

          <h4 class="text-base font-semibold mb-3">完整示例</h4>
          <div class="bg-gray-50 rounded-lg p-4">
            <pre class="code-editor text-xs whitespace-pre-wrap">单选题
4. 李白是哪个朝代的？
A. 唐
B. 宋
C. 元
D. 明
答案：A
答案解析：历史问题
知识点：yunti001

多选题
5. 明清是中国小说史上的繁荣时期。以下作品属于明清时期四大名著的有?
A. 红楼梦
B. 三国演义
C. 窦娥冤
D. 西厢记
答案：AB
知识点：yunti001，yunti002

判断题
3. 扩散现象说明物质的分子在永不停息地做无规则运动
答案：正确

填空题
2. 床前明月光，____。举头望明月，____。
答案：疑是地上霜；低头思故乡

简答题
7. 请论述全球化对国家政治产生了哪些深刻的影响？
答案：全球化对政府的治理提出了更高的要求。

完形填空
6. Most parents, I suppose, have had the experience of reading a bedtime story to their children. And they must have____how difficult it is to write a____children's book. Either the author has aimed too____, so that the children can't follow what is in his story, ____the story seems to be talking to the readers.
1)A. hoped  B. realized  C. told  D. speech
2)A. bad  B. interesting  C.new  D. good
3)A. long  B. short  C. high  D.training
4)A. or  B. but  C. and  D.offered
答案：BDCA

复合题
生活中处处都有科学常识，掌握基础生活知识，有助于提高生活质量和安全意识。
通过以下几道测试题，看看你对生活常识了解多少？
[多选题]
正确洗手可以有效预防疾病，洗手时应重点清洗哪些部位？
A. 手心
B. 手背
C. 手指
D. 指缝
答案：ABCD</pre>
          </div>
        </div>
      </div>
      <div class="px-6 py-4 border-t border-gray-200 bg-gray-50 flex justify-end">
        <button onclick="closeFormatGuide()" class="px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg font-medium text-sm transition-colors">
          知道了
        </button>
      </div>
    </div>
  </div>

  <!-- 输入范例弹窗 -->
  <div id="exampleModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl shadow-2xl max-w-3xl w-full max-h-[90vh] overflow-hidden flex flex-col">
      <div class="flex items-center justify-between px-6 py-4 border-b border-gray-200 flex-shrink-0">
        <h3 class="text-lg font-semibold text-gray-900">
          <i class="fas fa-eye text-primary-500 mr-2"></i>
          输入范例
        </h3>
        <button onclick="closeExample()" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="p-6 overflow-y-auto custom-scrollbar flex-1">
        <div class="bg-gray-50 rounded-lg p-4 mb-4">
          <pre class="code-editor text-sm whitespace-pre-wrap" id="exampleText">单选题
4. 李白是哪个朝代的？
A. 唐
B. 宋
C. 元
D. 明
答案：A
答案解析：历史问题
知识点：yunti001

多选题
5. 明清是中国小说史上的繁荣时期。以下作品属于明清时期四大名著的有?
A. 红楼梦
B. 三国演义
C. 窦娥冤
D. 西厢记
答案：AB
知识点：yunti001，yunti002

判断题
3. 扩散现象说明物质的分子在永不停息地做无规则运动
答案：正确

填空题
2. 床前明月光，____。举头望明月，____。
答案：疑是地上霜；低头思故乡

简答题
7. 请论述全球化对国家政治产生了哪些深刻的影响？
答案：全球化对政府的治理提出了更高的要求。

完形填空
6. Most parents, I suppose, have had the experience of reading a bedtime story to their children. And they must have____how difficult it is to write a____children's book. Either the author has aimed too____, so that the children can't follow what is in his story, ____the story seems to be talking to the readers.
1)A. hoped  B. realized  C. told  D. speech
2)A. bad  B. interesting  C.new  D. good
3)A. long  B. short  C. high  D.training
4)A. or  B. but  C. and  D.offered
答案：BDCA

复合题
生活中处处都有科学常识，掌握基础生活知识，有助于提高生活质量和安全意识。
通过以下几道测试题，看看你对生活常识了解多少？
[多选题]
正确洗手可以有效预防疾病，洗手时应重点清洗哪些部位？
A. 手心
B. 手背
C. 手指
D. 指缝
答案：ABCD</pre>
        </div>
      </div>
      <div class="px-6 py-4 border-t border-gray-200 bg-gray-50 flex justify-end space-x-3 flex-shrink-0">
        <button onclick="closeExample()" class="px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 hover:bg-gray-50 transition-colors">
          取消
        </button>
        <button onclick="useExample()" class="px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg font-medium text-sm transition-colors">
          <i class="fas fa-plus mr-2"></i>
          使用此示例
        </button>
      </div>
    </div>
  </div>

  <!-- 知识点选择弹窗 -->
  <div id="knowledgeModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-hidden flex flex-col">
      <div class="flex items-center justify-between px-6 py-4 border-b border-gray-200 flex-shrink-0">
        <h3 class="text-lg font-semibold text-gray-900">
          <i class="fas fa-sitemap text-primary-500 mr-2"></i>
          选择知识点
        </h3>
        <button onclick="closeKnowledgeModal()" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="p-6 overflow-y-auto custom-scrollbar flex-1">
        <!-- 搜索框 -->
        <div class="mb-4">
          <input
            type="text"
            id="knowledgeSearch"
            placeholder="搜索知识点..."
            oninput="filterKnowledge()"
            class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500"
          >
        </div>
        <!-- 知识点树 -->
        <div id="knowledgeTree" class="space-y-1">
          <!-- 动态生成 -->
        </div>
      </div>
      <div class="px-6 py-4 border-t border-gray-200 bg-gray-50 flex justify-between items-center flex-shrink-0">
        <div class="text-sm text-gray-600">
          已选择：<span id="selectedKnowledgeCount" class="font-medium text-primary-500">0</span> 个知识点
        </div>
        <div class="flex space-x-3">
          <button onclick="closeKnowledgeModal()" class="px-4 py-2 border border-gray-300 hover:bg-gray-50 text-gray-700 rounded-lg font-medium text-sm transition-colors">
            取消
          </button>
          <button onclick="confirmKnowledgeSelection()" class="px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg font-medium text-sm transition-colors">
            <i class="fas fa-check mr-2"></i>
            确定
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- 隐藏的文件输入框 -->
  <input type="file" id="imageFileInput" accept="image/*" style="display:none;" />

  <!-- 公式编辑器弹窗 -->
  <div id="formulaEditorModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl shadow-2xl max-w-5xl w-full max-h-[85vh] flex flex-col">
      <div class="flex items-center justify-between px-6 py-3 border-b border-gray-200 flex-shrink-0">
        <h3 class="text-lg font-semibold text-gray-900">
          <i class="fas fa-square-root-variable text-primary-500 mr-2"></i>
          可视化公式编辑器
        </h3>
        <button onclick="closeFormulaEditor()" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="flex-1 overflow-hidden">
        <div class="h-full grid grid-cols-5 gap-4 p-6">
          <!-- 左侧组件面板 - 可滚动 -->
          <div class="col-span-2 space-y-3 overflow-y-auto pr-2" style="max-height: calc(85vh - 140px);">
            <!-- 基础组件 -->
            <div class="text-sm font-semibold text-gray-700 mb-2">基础组件</div>
            <div class="grid grid-cols-3 gap-2">
              <!-- 分数 -->
              <button onclick="insertFormulaComponent('fraction')" class="p-2 border-2 border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-center">
                <div class="text-lg" style="font-family: serif;">
                  <span style="border-bottom: 1px solid black; padding: 0 6px;">a</span><br>
                  <span style="padding: 0 6px;">b</span>
                </div>
                <div class="text-xs text-gray-600 mt-1">分数</div>
              </button>

              <!-- 上标 -->
              <button onclick="insertFormulaComponent('superscript')" class="p-2 border-2 border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-center">
                <div class="text-lg" style="font-family: serif;">
                  x<sup>n</sup>
                </div>
                <div class="text-xs text-gray-600 mt-1">上标</div>
              </button>

              <!-- 下标 -->
              <button onclick="insertFormulaComponent('subscript')" class="p-2 border-2 border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-center">
                <div class="text-lg" style="font-family: serif;">
                  x<sub>n</sub>
                </div>
                <div class="text-xs text-gray-600 mt-1">下标</div>
              </button>

              <!-- 根号 -->
              <button onclick="insertFormulaComponent('sqrt')" class="p-2 border-2 border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-center">
                <div class="text-lg" style="font-family: serif;">
                  √<span style="text-decoration: overline;">x</span>
                </div>
                <div class="text-xs text-gray-600 mt-1">根号</div>
              </button>

              <!-- 求和 -->
              <button onclick="insertFormulaComponent('sum')" class="p-2 border-2 border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-center">
                <div class="text-xl" style="font-family: serif;">Σ</div>
                <div class="text-xs text-gray-600 mt-1">求和</div>
              </button>

              <!-- 积分 -->
              <button onclick="insertFormulaComponent('integral')" class="p-2 border-2 border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-center">
                <div class="text-xl" style="font-family: serif;">∫</div>
                <div class="text-xs text-gray-600 mt-1">积分</div>
              </button>

              <!-- 极限 -->
              <button onclick="insertFormulaComponent('limit')" class="p-2 border-2 border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-center">
                <div class="text-sm" style="font-family: serif;">lim</div>
                <div class="text-xs text-gray-600 mt-1">极限</div>
              </button>

              <!-- 括号 -->
              <button onclick="insertFormulaComponent('parentheses')" class="p-2 border-2 border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-center">
                <div class="text-lg" style="font-family: serif;">( )</div>
                <div class="text-xs text-gray-600 mt-1">括号</div>
              </button>

              <!-- 矩阵 -->
              <button onclick="insertFormulaComponent('matrix')" class="p-2 border-2 border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-center">
                <div class="text-lg" style="font-family: serif;">[ ]</div>
                <div class="text-xs text-gray-600 mt-1">矩阵</div>
              </button>
            </div>

            <!-- 常用公式模板 -->
            <div class="text-sm font-semibold text-gray-700 mb-2 mt-4">常用公式</div>
            <div class="space-y-2">
              <!-- 勾股定理 -->
              <button onclick="insertFormulaTemplate('pythagorean')" class="w-full p-2 border border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-left">
                <div class="text-sm font-medium text-gray-900">勾股定理</div>
                <div class="text-xs text-gray-600 mt-1">a² + b² = c²</div>
              </button>

              <!-- 二项式定理 -->
              <button onclick="insertFormulaTemplate('binomial')" class="w-full p-2 border border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-left">
                <div class="text-sm font-medium text-gray-900">二项式定理</div>
                <div class="text-xs text-gray-600 mt-1">(a+b)ⁿ = Σ C(n,k)aⁿ⁻ᵏbᵏ</div>
              </button>

              <!-- 一元二次方程 -->
              <button onclick="insertFormulaTemplate('quadratic')" class="w-full p-2 border border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-left">
                <div class="text-sm font-medium text-gray-900">一元二次方程</div>
                <div class="text-xs text-gray-600 mt-1">ax² + bx + c = 0</div>
              </button>

              <!-- 求根公式 -->
              <button onclick="insertFormulaTemplate('quadratic_formula')" class="w-full p-2 border border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-left">
                <div class="text-sm font-medium text-gray-900">求根公式</div>
                <div class="text-xs text-gray-600 mt-1">x = (-b ± √(b²-4ac)) / 2a</div>
              </button>

              <!-- 等差数列 -->
              <button onclick="insertFormulaTemplate('arithmetic')" class="w-full p-2 border border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-left">
                <div class="text-sm font-medium text-gray-900">等差数列</div>
                <div class="text-xs text-gray-600 mt-1">aₙ = a₁ + (n-1)d</div>
              </button>

              <!-- 等比数列 -->
              <button onclick="insertFormulaTemplate('geometric')" class="w-full p-2 border border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-left">
                <div class="text-sm font-medium text-gray-900">等比数列</div>
                <div class="text-xs text-gray-600 mt-1">aₙ = a₁ · qⁿ⁻¹</div>
              </button>

              <!-- 导数定义 -->
              <button onclick="insertFormulaTemplate('derivative')" class="w-full p-2 border border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-left">
                <div class="text-sm font-medium text-gray-900">导数定义</div>
                <div class="text-xs text-gray-600 mt-1">f'(x) = lim(Δx→0) [f(x+Δx)-f(x)]/Δx</div>
              </button>

              <!-- 圆的面积 -->
              <button onclick="insertFormulaTemplate('circle_area')" class="w-full p-2 border border-gray-200 rounded-lg hover:border-primary-500 hover:bg-primary-50 transition-colors text-left">
                <div class="text-sm font-medium text-gray-900">圆的面积</div>
                <div class="text-xs text-gray-600 mt-1">S = πr²</div>
              </button>
            </div>

            <!-- 希腊字母 -->
            <div class="text-sm font-semibold text-gray-700 mb-2 mt-4">希腊字母</div>
            <div class="grid grid-cols-4 gap-2">
              <button onclick="insertGreekLetter('alpha')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="α">α</button>
              <button onclick="insertGreekLetter('beta')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="β">β</button>
              <button onclick="insertGreekLetter('gamma')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="γ">γ</button>
              <button onclick="insertGreekLetter('delta')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="δ">δ</button>
              <button onclick="insertGreekLetter('pi')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="π">π</button>
              <button onclick="insertGreekLetter('theta')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="θ">θ</button>
              <button onclick="insertGreekLetter('lambda')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="λ">λ</button>
              <button onclick="insertGreekLetter('mu')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="μ">μ</button>
            </div>

            <!-- 常用符号 -->
            <div class="text-sm font-semibold text-gray-700 mb-2 mt-4">常用符号</div>
            <div class="grid grid-cols-4 gap-2">
              <button onclick="insertSymbol('infty')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="无穷">∞</button>
              <button onclick="insertSymbol('pm')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="正负">±</button>
              <button onclick="insertSymbol('times')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="乘">×</button>
              <button onclick="insertSymbol('div')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="除">÷</button>
              <button onclick="insertSymbol('leq')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="小于等于">≤</button>
              <button onclick="insertSymbol('geq')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="大于等于">≥</button>
              <button onclick="insertSymbol('neq')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="不等于">≠</button>
              <button onclick="insertSymbol('approx')" class="p-2 border border-gray-200 rounded hover:bg-gray-100 text-center" title="约等于">≈</button>
            </div>
          </div>

          <!-- 右侧编辑和预览区域 - 固定不滚动 -->
          <div class="col-span-3 flex flex-col gap-4">
            <!-- 编辑区 -->
            <div class="flex-1">
              <label class="block text-sm font-medium text-gray-700 mb-2">编辑区域</label>
              <div id="formulaEditor" class="w-full h-[250px] px-4 py-3 border-2 border-gray-300 rounded-lg bg-white focus-within:border-primary-500 transition-colors overflow-hidden">
                <div id="formulaElements" class="flex flex-wrap gap-2 items-center h-full overflow-y-auto"></div>
              </div>
              <div class="mt-2 flex gap-2">
                <button onclick="clearFormulaEditor()" class="px-3 py-1.5 text-xs border border-gray-300 rounded hover:bg-gray-50">
                  <i class="fas fa-eraser mr-1"></i>清空
                </button>
                <button onclick="undoLastElement()" class="px-3 py-1.5 text-xs border border-gray-300 rounded hover:bg-gray-50">
                  <i class="fas fa-undo mr-1"></i>撤销
                </button>
              </div>
            </div>

            <!-- 预览区 -->
            <div class="flex-1">
              <label class="block text-sm font-medium text-gray-700 mb-2">预览</label>
              <div id="formulaPreview" class="w-full h-[180px] px-4 py-3 border border-gray-200 rounded-lg bg-gray-50 flex items-center justify-center text-3xl overflow-y-auto">
                <span class="text-gray-400 text-sm">公式预览将显示在这里</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="px-6 py-3 border-t border-gray-200 bg-gray-50 flex justify-end space-x-3 flex-shrink-0">
        <button onclick="closeFormulaEditor()" class="px-4 py-2 border border-gray-300 hover:bg-gray-50 text-gray-700 rounded-lg font-medium text-sm transition-colors">
          取消
        </button>
        <button onclick="confirmFormulaInsert()" class="px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg font-medium text-sm transition-colors">
          <i class="fas fa-check mr-2"></i>
          插入公式
        </button>
      </div>
    </div>
  </div>

  <!-- 分数设置弹窗 -->
  <div id="scoreSettingModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl shadow-2xl max-w-7xl w-full max-h-[90vh] overflow-hidden flex flex-col">
      <!-- 标题栏 -->
      <div class="flex items-center justify-between px-6 py-4 border-b border-gray-200 flex-shrink-0">
        <h3 class="text-lg font-semibold text-gray-900">
          <i class="fas fa-calculator text-primary-500 mr-2"></i>
          分数设置
        </h3>
        <button onclick="closeScoreModal()" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors">
          <i class="fas fa-times"></i>
        </button>
      </div>

      <!-- 工具栏 -->
      <div class="px-6 py-4 border-b border-gray-200 bg-gray-50 flex-shrink-0">
        <div class="flex items-center justify-between">
          <!-- 左侧：题型筛选 -->
          <div class="flex items-center space-x-4">
            <span class="text-sm text-gray-600">题型筛选：</span>
            <select id="scoreTypeFilter" onchange="filterScoreQuestions()" class="px-3 py-1.5 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500">
              <option value="all">全部题型</option>
              <option value="single">单选题</option>
              <option value="multiple">多选题</option>
              <option value="judge">判断题</option>
              <option value="blank">填空题</option>
              <option value="essay">简答题</option>
              <option value="cloze">完形填空</option>
              <option value="composite">复合题</option>
            </select>
          </div>

          <!-- 右侧：批量设置 -->
          <div class="flex items-center space-x-2">
            <span class="text-sm text-gray-600">批量设置总分：</span>
            <input type="number" id="batchScoreInput" placeholder="输入分数" min="0" step="0.5" class="w-24 px-3 py-1.5 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500">
            <button onclick="batchSetScore()" class="px-4 py-1.5 bg-primary-500 hover:bg-primary-600 text-white rounded-lg text-sm transition-colors">
              <i class="fas fa-magic mr-1"></i>
              应用
            </button>
            <button onclick="batchClearScore()" class="px-4 py-1.5 border border-gray-300 hover:bg-gray-50 text-gray-700 rounded-lg text-sm transition-colors">
              <i class="fas fa-eraser mr-1"></i>
              清除
            </button>
          </div>
        </div>
      </div>

      <!-- 题目列表（表格） -->
      <div class="flex-1 overflow-y-auto custom-scrollbar">
        <table class="w-full">
          <thead class="bg-gray-50 sticky top-0 z-10">
            <tr class="border-b border-gray-200">
              <th class="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider w-16">序号</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider w-32">题型</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">题目</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider w-48">总分</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider w-20">操作</th>
            </tr>
          </thead>
          <tbody id="scoreQuestionTableBody" class="divide-y divide-gray-200">
            <!-- 动态生成 -->
          </tbody>
        </table>
      </div>

      <!-- 底部按钮 -->
      <div class="px-6 py-4 border-t border-gray-200 bg-gray-50 flex justify-between items-center flex-shrink-0">
        <div class="text-sm text-gray-600">
          共 <span id="totalScoreQuestions" class="font-semibold text-gray-900">0</span> 道题目
          <span class="mx-2 text-gray-400">|</span>
          <span class="text-gray-500">如不填写分数直接导入，则题目不带分数</span>
        </div>
        <div class="flex space-x-3">
          <button onclick="confirmScoreAndImport()" class="px-6 py-2.5 bg-primary-500 hover:bg-primary-600 text-white rounded-lg font-medium text-sm transition-colors">
            <i class="fas fa-check mr-2"></i>
            确认导入
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // 全局变量
    let parsedData = [];
    let errorIndexes = [];
    let currentErrorIndex = 0;
    let autoSaveTimer = null;
    let knowledgePointsMap = {}; // id -> name 映射
    let knowledgePointsNameMap = {}; // name -> id 映射
    let knowledgePointsTree = []; // 知识点树结构
    let selectedKnowledgePoints = []; // 当前选中的知识点
    let knowledgeSelectionMode = 'all'; // 'all' 全局添加, 'single' 单个题目
    let currentQuestionIndex = -1; // 当前操作的题目索引
    let imageDataMap = {}; // 图片数据映射：imageId -> {width, height, data}
    let imageIdCounter = 0; // 图片ID计数器
    let formulaDataMap = {}; // 公式数据映射：formulaId -> {latex: '...'}
    let formulaIdCounter = 0; // 公式ID计数器
    let savedRange = null; // 保存的光标位置
    let formulaElements = []; // 可视化公式编辑器的元素数组
    let draggedImageId = null; // 当前拖拽的图片ID
    let draggedSourceField = null; // 拖拽源字段信息 {questionIndex, fieldType, optionIndex}
    let dropCursorElement = null; // 光标指示器元素
    let dropTargetInfo = null; // 拖拽目标信息 {element, textNode, offset}

    // 页面加载完成
    document.addEventListener('DOMContentLoaded', function() {
      // 加载知识点数据
      loadKnowledgePoints();

      // 加载草稿数据
      loadDraft();

      const inputDiv = document.getElementById('inputText');

      // 初始化图片拖拽监听（已废弃，左侧输入框不再支持图片拖拽）
      // initInputDivDragListeners();

      // 创建防抖处理函数
      const debouncedHandleInputChange = debounce(function() {
        console.log('防抖后执行 handleInputChange');
        handleInputChange();
      }, 100);

      // 全局图片粘贴防抖标志（避免重复处理）
      let isProcessingImagePaste = false;
      let pasteEventCounter = 0; // 追踪 paste 事件调用次数
      let lastPasteTime = 0; // 上次粘贴时间戳（防止短时间内重复触发）

      // 监听输入变化，实时解析（100ms 防抖，加快响应速度）
      inputDiv.addEventListener('input', function(e) {
        // 如果正在处理图片粘贴，不触发解析（因为 paste 事件会手动调用）
        if (isProcessingImagePaste) {
          console.log('%c  ⊗ INPUT 事件被阻止（正在处理图片）', 'color: orange;');
          return;
        }
        console.log('%c  ⊙ INPUT 事件触发', 'color: gray;');
        debouncedHandleInputChange();
      });

      // 监听粘贴事件，支持图片粘贴和纯文本粘贴
      inputDiv.addEventListener('paste', function(event) {
        pasteEventCounter++;
        const currentTime = Date.now();

        console.log('%c========== PASTE 事件 #' + pasteEventCounter + ' ==========', 'background: #222; color: #bada55; font-size: 14px; font-weight: bold;');
        console.log('当前时间:', currentTime, '上次粘贴时间:', lastPasteTime, '间隔:', currentTime - lastPasteTime, 'ms');

        // 防止短时间内重复触发（200ms 内的重复 paste 事件直接忽略）
        if (currentTime - lastPasteTime < 200) {
          console.log('%c⊗⊗⊗ 200ms 内重复的 PASTE 事件，直接忽略！ ⊗⊗⊗', 'color: red; font-weight: bold; font-size: 16px; background: yellow;');
          event.preventDefault();
          return;
        }

        lastPasteTime = currentTime;

        const clipboardData = event.clipboardData || window.clipboardData;
        const items = clipboardData.items;

        console.log('剪贴板项目数量:', items ? items.length : 0);
        console.log('当前 isProcessingImagePaste:', isProcessingImagePaste);

        // 首先检查是否有图片
        let hasImage = false;

        // 检查剪贴板中的所有项目类型
        const imageItems = [];
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf('image') !== -1) {
            imageItems.push({ index: i, type: items[i].type, item: items[i] });
            console.log(`  [图片项 ${i}] 类型:`, items[i].type);
          }
        }

        console.log('%c找到 ' + imageItems.length + ' 个图片项', 'color: blue; font-weight: bold;');

        // 如果有图片且当前没有在处理中
        if (imageItems.length > 0 && !isProcessingImagePaste) {
          hasImage = true;
          isProcessingImagePaste = true; // 立即设置为处理中
          event.preventDefault();
          console.log('%c[锁定] isProcessingImagePaste = true', 'color: red; font-weight: bold;');

          // 只处理第一个图片项
          const firstImageItem = imageItems[0];

          const blob = firstImageItem.item.getAsFile();
          if (!blob) {
            console.error('❌ 无法获取图片文件');
            isProcessingImagePaste = false;
            return;
          }

          const reader = new FileReader();

          reader.onload = function(e) {
            try {
              // 生成图片ID
              imageIdCounter++;
              const imageId = `img_${imageIdCounter}`;
              console.log('%c[步骤1] 生成图片ID: ' + imageId, 'color: green; font-weight: bold;');

              // 存储图片数据（默认宽度 200px）
              imageDataMap[imageId] = {
                data: e.target.result,
                width: 200
              };
              console.log('%c[步骤2] 图片数据已保存到 imageDataMap', 'color: green;');

              // 插入图片标记文本
              console.log('%c[步骤3] 调用 insertImageElement...', 'color: orange;');
              insertImageElement(imageId);
              console.log('%c[步骤3完成] insertImageElement 返回', 'color: green;');

              // 触发解析更新
              console.log('%c[步骤4] 调用 handleInputChange...', 'color: orange;');
              handleInputChange();
              console.log('%c[步骤4完成] handleInputChange 返回', 'color: green;');

              console.log('%c========== 图片粘贴完成 ==========', 'background: #222; color: #bada55; font-size: 14px; font-weight: bold;');
            } finally {
              // 500ms 后重置标志，防止短时间内重复粘贴
              setTimeout(() => {
                isProcessingImagePaste = false;
                console.log('%c[解锁] isProcessingImagePaste = false', 'color: green; font-weight: bold;');
              }, 500);
            }
          };

          reader.onerror = function() {
            console.error('❌ 图片读取失败');
            isProcessingImagePaste = false;
          };

          reader.readAsDataURL(blob);
        } else if (imageItems.length > 0 && isProcessingImagePaste) {
          // 如果正在处理图片，阻止事件
          event.preventDefault();
          console.log('%c⚠ 图片正在处理中，忽略此次粘贴事件', 'color: red; font-weight: bold;');
        }

        // 如果没有图片，处理文本粘贴
        if (!hasImage) {
          event.preventDefault();
          console.log('✓ 检测到文本粘贴');

          // 获取纯文本内容
          const text = clipboardData.getData('text/plain');
          console.log('粘贴的纯文本长度:', text ? text.length : 0);

          if (!text) {
            console.log('没有纯文本内容');
            console.log('========== paste 结束（无内容）==========\n');
            return;
          }

          // 获取当前内容
          const currentText = getInputText();

          // 获取光标位置
          const sel = window.getSelection();
          if (sel.rangeCount === 0) {
            console.log('没有光标位置，直接追加到末尾');
            // 如果没有光标，直接追加
            const newText = currentText ? currentText + '\n' + text : text;
            setInputText(newText);
          } else {
            // 有光标位置，在光标位置插入
            const range = sel.getRangeAt(0);

            // 删除选中的内容
            range.deleteContents();

            // 简单方法：直接插入纯文本，让浏览器处理
            // 然后立即重新格式化整个内容
            document.execCommand('insertText', false, text);
          }

          // 触发 input 事件以便重新解析
          setTimeout(() => {
            console.log('粘贴完成，规范化内容');
            // 规范化 DOM 结构：提取文本后重新设置
            const normalizedText = getInputText();

            // 重新设置内容以确保 DOM 结构一致
            setInputText(normalizedText);

            // 触发解析
            handleInputChange();
            console.log('========== 文本粘贴完成 ==========\n');
          }, 100);
        }
      });
    });

    // ==================== ContentEditable 辅助函数 ====================

    // 从 contentEditable 获取纯文本（包含标记）
    let getInputTextCounter = 0; // 追踪调用次数
    function getInputText() {
      getInputTextCounter++;
      const inputDiv = document.getElementById('inputText');
      let text = '';

      // 不输出详细日志，避免刷屏
      // console.log('=== getInputText #' + getInputTextCounter + ' ===');

      // 遍历所有子节点
      function traverseNodes(node, isTopLevel = false, depth = 0) {
        if (node.nodeType === Node.TEXT_NODE) {
          text += node.textContent;
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.classList.contains('inline-formula-editable')) {
            // 公式元素，提取 data-formula-id
            const formulaId = node.getAttribute('data-formula-id');
            text += `[公式:${formulaId}]`;
          } else if (node.tagName === 'BR') {
            text += '\n';
          } else if (node.tagName === 'DIV' && isTopLevel) {
            // 顶层 div 表示新行
            if (text && !text.endsWith('\n')) {
              text += '\n';
            }
            // 递归处理子节点
            for (let child of node.childNodes) {
              traverseNodes(child, false, depth + 1);
            }
          } else {
            // 递归处理子节点
            for (let child of node.childNodes) {
              traverseNodes(child, isTopLevel, depth + 1);
            }
          }
        }
      }

      for (let child of inputDiv.childNodes) {
        traverseNodes(child, true, 0);
      }

      // 清理多余的换行
      text = text.replace(/\n{3,}/g, '\n\n').trim();

      return text;
    }

    // 设置 contentEditable 的内容（渲染公式和图片）
    function setInputText(text) {
      const inputDiv = document.getElementById('inputText');
      inputDiv.innerHTML = '';

      if (!text || text.trim() === '') {
        return;
      }

      // 按行分割
      const lines = text.split('\n');

      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        const lineDiv = document.createElement('div');

        if (line.trim() === '') {
          lineDiv.innerHTML = '<br>';
        } else {
          // 解析行中的公式和图片
          let lastIndex = 0;
          const imageRegex = /\[图片:(img_\d+)\]/g;
          const formulaRegex = /\[公式:(formula_\d+)\]/g;

          // 找到所有匹配项
          const matches = [];
          let match;

          while ((match = imageRegex.exec(line)) !== null) {
            matches.push({ type: 'image', index: match.index, length: match[0].length, id: match[1] });
          }
          while ((match = formulaRegex.exec(line)) !== null) {
            matches.push({ type: 'formula', index: match.index, length: match[0].length, id: match[1] });
          }

          // 按位置排序
          matches.sort((a, b) => a.index - b.index);

          // 构建行内容
          matches.forEach(m => {
            // 添加前面的文本
            if (m.index > lastIndex) {
              const textNode = document.createTextNode(line.substring(lastIndex, m.index));
              lineDiv.appendChild(textNode);
            }

            // 添加公式或图片元素
            if (m.type === 'formula') {
              lineDiv.appendChild(createFormulaElement(m.id));
            } else if (m.type === 'image') {
              lineDiv.appendChild(createImageElement(m.id));
            }

            lastIndex = m.index + m.length;
          });

          // 添加剩余文本
          if (lastIndex < line.length) {
            const textNode = document.createTextNode(line.substring(lastIndex));
            lineDiv.appendChild(textNode);
          }
        }

        inputDiv.appendChild(lineDiv);
      }
    }

    // 创建公式元素
    function createFormulaElement(formulaId) {
      const formulaData = formulaDataMap[formulaId];
      if (!formulaData) {
        return document.createTextNode(`[公式:${formulaId}]`);
      }

      const span = document.createElement('span');
      span.className = 'inline-formula-editable';
      span.setAttribute('contenteditable', 'false');
      span.setAttribute('data-formula-id', formulaId);

      try {
        katex.render(formulaData.latex, span, {
          throwOnError: false,
          displayMode: false,
          errorColor: '#F53F3F'
        });
      } catch (e) {
        span.textContent = '[公式错误]';
        span.style.color = '#ef4444';
      }

      return span;
    }

    // 创建图片元素 - 左侧只显示纯文本标记
    function createImageElement(imageId) {
      // 左侧输入框不创建图片元素，只返回纯文本标记
      // 这样可以避免与contentEditable的复杂交互问题
      return document.createTextNode(`[图片:${imageId}]`);
    }

    // 在光标位置插入公式元素
    function insertFormulaElement(formulaId) {
      const inputDiv = document.getElementById('inputText');

      if (!inputDiv) {
        console.error('找不到 inputText 元素');
        return;
      }

      // 确保输入区域有焦点
      inputDiv.focus();

      const sel = window.getSelection();
      let range;

      // 优先使用保存的光标位置
      if (savedRange) {
        console.log('使用保存的光标位置');
        range = savedRange;
        sel.removeAllRanges();
        sel.addRange(range);
        savedRange = null; // 使用后清空
      } else if (!sel.rangeCount || !inputDiv.contains(sel.anchorNode)) {
        // 如果没有保存的光标且当前没有有效选区，创建新的 range
        console.log('创建新的 range，因为没有有效选区');
        range = document.createRange();

        // 如果 inputDiv 为空，创建一个空的 div
        if (inputDiv.childNodes.length === 0) {
          const div = document.createElement('div');
          div.appendChild(document.createElement('br'));
          inputDiv.appendChild(div);
          console.log('inputDiv 为空，创建了新的 div');
        }

        // 设置 range 到最后一个子节点的末尾
        const lastChild = inputDiv.lastChild;
        if (lastChild.nodeType === Node.TEXT_NODE) {
          range.setStart(lastChild, lastChild.length);
          range.setEnd(lastChild, lastChild.length);
        } else if (lastChild.tagName === 'DIV') {
          // 如果最后一个是 div，在其内部最后位置插入
          if (lastChild.childNodes.length === 0) {
            const br = document.createElement('br');
            lastChild.appendChild(br);
          }
          const lastDivChild = lastChild.lastChild;
          if (lastDivChild.nodeType === Node.TEXT_NODE) {
            range.setStart(lastDivChild, lastDivChild.length);
            range.setEnd(lastDivChild, lastDivChild.length);
          } else if (lastDivChild.tagName === 'BR') {
            range.setStartBefore(lastDivChild);
            range.setEndBefore(lastDivChild);
          } else {
            range.setStartAfter(lastDivChild);
            range.setEndAfter(lastDivChild);
          }
        } else {
          range.setStartAfter(lastChild);
          range.setEndAfter(lastChild);
        }

        sel.removeAllRanges();
        sel.addRange(range);
      } else {
        range = sel.getRangeAt(0);
        console.log('使用现有选区');
      }

      // 删除选中的内容
      range.deleteContents();

      // 创建公式元素
      const formulaElement = createFormulaElement(formulaId);
      console.log('创建公式元素:', formulaElement);

      // 插入公式元素
      range.insertNode(formulaElement);

      // 在公式后添加一个空格，方便继续输入
      const spaceNode = document.createTextNode(' ');
      range.setStartAfter(formulaElement);
      range.insertNode(spaceNode);

      // 移动光标到空格后面
      range.setStartAfter(spaceNode);
      range.setEndAfter(spaceNode);
      sel.removeAllRanges();
      sel.addRange(range);

      console.log('公式插入完成，inputDiv.innerHTML:', inputDiv.innerHTML);
    }

    // 在光标位置插入图片元素
    let insertImageCallCounter = 0; // 追踪调用次数
    function insertImageElement(imageId) {
      insertImageCallCounter++;
      console.log('%c  → insertImageElement #' + insertImageCallCounter + ': ' + imageId, 'color: blue;');

      const inputDiv = document.getElementById('inputText');

      if (!inputDiv) {
        console.error('找不到 inputText 元素');
        return;
      }

      // 确保输入区域有焦点
      inputDiv.focus();

      const sel = window.getSelection();
      let range;

      // 优先使用保存的光标位置
      if (savedRange) {
        console.log('使用保存的光标位置（图片）');
        range = savedRange;
        sel.removeAllRanges();
        sel.addRange(range);
        savedRange = null; // 使用后清空
      } else if (!sel.rangeCount || !inputDiv.contains(sel.anchorNode)) {
        // 如果没有保存的光标且当前没有有效选区，创建新的 range
        console.log('创建新的 range，因为没有有效选区（图片）');
        range = document.createRange();

        // 如果 inputDiv 为空，创建一个空的 div
        if (inputDiv.childNodes.length === 0) {
          const div = document.createElement('div');
          div.appendChild(document.createElement('br'));
          inputDiv.appendChild(div);
          console.log('inputDiv 为空，创建了新的 div');
        }

        // 设置 range 到最后一个子节点的末尾
        const lastChild = inputDiv.lastChild;
        if (lastChild.nodeType === Node.TEXT_NODE) {
          range.setStart(lastChild, lastChild.length);
          range.setEnd(lastChild, lastChild.length);
        } else if (lastChild.tagName === 'DIV') {
          // 如果最后一个是 div，在其内部最后位置插入
          if (lastChild.childNodes.length === 0) {
            const br = document.createElement('br');
            lastChild.appendChild(br);
          }
          const lastDivChild = lastChild.lastChild;
          if (lastDivChild.nodeType === Node.TEXT_NODE) {
            range.setStart(lastDivChild, lastDivChild.length);
            range.setEnd(lastDivChild, lastDivChild.length);
          } else if (lastDivChild.tagName === 'BR') {
            range.setStartBefore(lastDivChild);
            range.setEndBefore(lastDivChild);
          } else {
            range.setStartAfter(lastDivChild);
            range.setEndAfter(lastDivChild);
          }
        } else {
          range.setStartAfter(lastChild);
          range.setEndAfter(lastChild);
        }

        sel.removeAllRanges();
        sel.addRange(range);
      } else {
        range = sel.getRangeAt(0);
        console.log('使用现有选区（图片）');
      }

      // 删除选中的内容
      range.deleteContents();

      // 创建图片元素
      const imageElement = createImageElement(imageId);
      console.log('创建图片元素:', imageElement);

      // 插入图片元素
      range.insertNode(imageElement);

      // 在图片后添加一个空格，方便继续输入
      const spaceNode = document.createTextNode(' ');
      range.setStartAfter(imageElement);
      range.insertNode(spaceNode);

      // 移动光标到空格后面
      range.setStartAfter(spaceNode);
      range.setEndAfter(spaceNode);
      sel.removeAllRanges();
      sel.addRange(range);

      console.log('    ✓ 图片标记已插入到 DOM');
    }

    // 加载知识点数据
    function loadKnowledgePoints() {
      try {
        const knowledgeData = localStorage.getItem('knowledgePoints');
        console.log('加载知识点数据:', knowledgeData);
        if (knowledgeData) {
          knowledgePointsTree = JSON.parse(knowledgeData);
          console.log('解析后的知识点树:', knowledgePointsTree);
          // 递归遍历知识点树，建立映射
          function traverse(nodes) {
            nodes.forEach(node => {
              knowledgePointsMap[node.id] = node.name;
              knowledgePointsNameMap[node.name] = node.id;
              if (node.children && node.children.length > 0) {
                traverse(node.children);
              }
            });
          }
          traverse(knowledgePointsTree);
          console.log('知识点映射表:', knowledgePointsMap);
        } else {
          console.warn('LocalStorage 中没有 knowledgePoints 数据');
        }
      } catch (e) {
        console.error('加载知识点数据失败:', e);
      }
    }

    // 根据知识点ID获取完整路径
    function getKnowledgePathById(targetId) {
      console.log('[知识点路径] 查找ID:', targetId);
      const path = [];

      // 递归查找节点并构建路径
      function findNode(nodes, targetId) {
        for (let node of nodes) {
          if (node.id === targetId) {
            path.unshift(node.name);
            return true;
          }
          if (node.children && node.children.length > 0) {
            if (findNode(node.children, targetId)) {
              path.unshift(node.name);
              return true;
            }
          }
        }
        return false;
      }

      const found = findNode(knowledgePointsTree, targetId);
      const result = path.join(' / ');
      console.log('[知识点路径] 找到:', found, '路径:', result);
      return result;
    }

    // 验证知识点是否存在（支持id或name）
    function validateKnowledgePoints(knowledgePoints) {
      const invalidPoints = knowledgePoints.filter(kp => {
        // 检查是否是有效的id或name
        return !knowledgePointsMap[kp] && !knowledgePointsNameMap[kp];
      });
      if (invalidPoints.length > 0) {
        return `知识点无法识别，"${invalidPoints.join('、')}" 不在知识点目录中`;
      }
      return null;
    }

    // 防抖函数
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // 处理输入变化
    let handleInputChangeCounter = 0; // 追踪调用次数
    function handleInputChange() {
      handleInputChangeCounter++;
      console.log('%c  → handleInputChange #' + handleInputChangeCounter, 'color: purple;');

      const text = getInputText();

      // 简化日志
      console.log('    文本长度:', text.length, '包含图片标记:', text.match(/\[图片:img_\d+\]/g) ? text.match(/\[图片:img_\d+\]/g).length : 0);

      if (!text || text.trim() === '') {
        console.log('文本为空，显示空状态');
        showEmptyState();
        return;
      }

      // 自动解析
      console.log('开始解析文本');
      parseAndDisplay(text);

      // 自动保存
      autoSave();
      console.log('=== handleInputChange 结束 ===');
    }

    // 自动保存
    function autoSave() {
      clearTimeout(autoSaveTimer);
      autoSaveTimer = setTimeout(() => {
        const now = new Date();
        const timeStr = now.toTimeString().split(' ')[0];
        // document.getElementById('saveTime').textContent = timeStr; // 已移除时间显示元素
      }, 1000);
    }

    // 解析并显示
    function parseAndDisplay(text) {
      console.log('=== parseAndDisplay 开始 ===');
      console.log('待解析文本:', text);
      const result = parseQuestions(text);
      parsedData = result.questions;
      errorIndexes = result.errors;

      console.log('解析结果 - 题目数量:', parsedData.length);
      console.log('解析结果 - 错误数量:', errorIndexes.length);
      console.log('解析后的题目数据:', parsedData);

      updateStatistics();
      displayQuestions();
      console.log('=== parseAndDisplay 结束 ===');
    }

    // 将文本中的图片和公式标记转换为HTML
    function convertImagesToHTML(text) {
      if (!text) return '';

      // 1. 先处理图片标记 - 右侧支持拖拽和调整大小
      const imageRegex = /\[图片:(img_\d+)\]/g;
      text = text.replace(imageRegex, function(match, imageId) {
        const imageData = imageDataMap[imageId];
        if (imageData) {
          // 右侧识别框显示图片（支持拖拽移动、调整大小和删除）
          return '<span class="inline-image-wrapper" ' +
                      'style="position: relative; display: inline-block; margin: 0 4px; vertical-align: middle;"' +
                      'onmouseenter="showResizeHandles(this)" ' +
                      'onmouseleave="hideResizeHandles(this)">' +
                    '<img src="' + imageData.data + '"' +
                         ' data-image-id="' + imageId + '"' +
                         ' style="display: block; width: ' + imageData.width + 'px; height: auto; border-radius: 4px; transition: all 0.2s; cursor: move;"' +
                         ' class="inline-image border-2 border-gray-300"' +
                         ' draggable="true"' +
                         ' ondragstart="handleImageDragStart(event, \'' + imageId + '\')"' +
                         ' ondragend="handleImageDragEnd(event)">' +

                    // 四个角的拖拽手柄
                    '<span class="resize-handle" draggable="false" ' +
                         'onmousedown="event.stopPropagation(); window.startInlineImageResize(event, \'' + imageId + '\', \'nw\')" ' +
                         'style="position: absolute; top: -6px; left: -6px; width: 14px; height: 14px; background: white; border: 2px solid #00B96B; border-radius: 50%; cursor: nw-resize; display: none; z-index: 10;"></span>' +

                    '<span class="resize-handle" draggable="false" ' +
                         'onmousedown="event.stopPropagation(); window.startInlineImageResize(event, \'' + imageId + '\', \'ne\')" ' +
                         'style="position: absolute; top: -6px; right: -6px; width: 14px; height: 14px; background: white; border: 2px solid #00B96B; border-radius: 50%; cursor: ne-resize; display: none; z-index: 10;"></span>' +

                    '<span class="resize-handle" draggable="false" ' +
                         'onmousedown="event.stopPropagation(); window.startInlineImageResize(event, \'' + imageId + '\', \'sw\')" ' +
                         'style="position: absolute; bottom: -6px; left: -6px; width: 14px; height: 14px; background: white; border: 2px solid #00B96B; border-radius: 50%; cursor: sw-resize; display: none; z-index: 10;"></span>' +

                    '<span class="resize-handle" draggable="false" ' +
                         'onmousedown="event.stopPropagation(); window.startInlineImageResize(event, \'' + imageId + '\', \'se\')" ' +
                         'style="position: absolute; bottom: -6px; right: -6px; width: 14px; height: 14px; background: white; border: 2px solid #00B96B; border-radius: 50%; cursor: se-resize; display: none; z-index: 10;"></span>' +

                    // 删除按钮
                    '<button class="delete-btn" draggable="false"' +
                            ' onclick="event.stopPropagation(); window.removeImageById(\'' + imageId + '\')"' +
                            ' style="position: absolute; top: -8px; right: -8px; width: 22px; height: 22px; border-radius: 50%; background: #ef4444; color: white; border: 2px solid white; font-size: 12px; cursor: pointer; display: none; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.2); z-index: 11;"' +
                            ' title="删除图片">×</button>' +
                  '</span>';
        }
        return match;
      });

      // 2. 再处理公式标记
      const formulaRegex = /\[公式:(formula_\d+)\]/g;
      text = text.replace(formulaRegex, function(match, formulaId) {
        const formulaData = formulaDataMap[formulaId];
        if (formulaData) {
          // 创建一个临时容器用于 KaTeX 渲染
          const tempDiv = document.createElement('div');
          try {
            katex.render(formulaData.latex, tempDiv, {
              throwOnError: false,
              displayMode: false, // 行内模式
              errorColor: '#F53F3F'
            });
            // 将渲染后的公式包装在一个 span 中，添加删除按钮
            return '<span class="inline-formula-wrapper" ' +
                      'style="position: relative; display: inline-block; margin: 0 4px; vertical-align: middle; padding: 2px 6px; background: #f0f9ff; border-radius: 4px; border: 1px solid #bae6fd;" ' +
                      'onmouseenter="showFormulaDelete(this)" ' +
                      'onmouseleave="hideFormulaDelete(this)">' +
                    '<span class="inline-formula" style="display: inline-block;">' + tempDiv.innerHTML + '</span>' +
                    '<button class="formula-delete-btn"' +
                            ' onclick="event.stopPropagation(); window.removeFormulaById(\'' + formulaId + '\')"' +
                            ' style="position: absolute; top: -8px; right: -8px; width: 20px; height: 20px; border-radius: 50%; background: #ef4444; color: white; border: 2px solid white; font-size: 12px; cursor: pointer; display: none; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.2); z-index: 11;"' +
                            ' title="删除公式">×</button>' +
                  '</span>';
          } catch (e) {
            return '<span class="text-error-500 text-sm">[公式错误]</span>';
          }
        }
        return match;
      });

      return text;
    }

    // 显示公式删除按钮
    window.showFormulaDelete = function(wrapper) {
      const deleteBtn = wrapper.querySelector('.formula-delete-btn');
      if (deleteBtn) {
        deleteBtn.style.display = 'flex';
      }
      wrapper.style.background = '#dbeafe';
      wrapper.style.borderColor = '#60a5fa';
    };

    // 隐藏公式删除按钮
    window.hideFormulaDelete = function(wrapper) {
      const deleteBtn = wrapper.querySelector('.formula-delete-btn');
      if (deleteBtn) {
        deleteBtn.style.display = 'none';
      }
      wrapper.style.background = '#f0f9ff';
      wrapper.style.borderColor = '#bae6fd';
    };

    // 显示拖拽手柄
    window.showResizeHandles = function(wrapper) {
      const handles = wrapper.querySelectorAll('.resize-handle');
      const deleteBtn = wrapper.querySelector('.delete-btn');
      const img = wrapper.querySelector('.inline-image');

      handles.forEach(function(handle) {
        handle.style.display = 'block';
      });

      if (deleteBtn) {
        deleteBtn.style.display = 'flex';
      }

      if (img) {
        img.style.boxShadow = '0 2px 8px rgba(0, 185, 107, 0.3)';
        img.style.borderColor = '#00B96B';
      }
    };

    // 隐藏拖拽手柄
    window.hideResizeHandles = function(wrapper) {
      const handles = wrapper.querySelectorAll('.resize-handle');
      const deleteBtn = wrapper.querySelector('.delete-btn');
      const img = wrapper.querySelector('.inline-image');

      handles.forEach(function(handle) {
        handle.style.display = 'none';
      });

      if (deleteBtn) {
        deleteBtn.style.display = 'none';
      }

      if (img) {
        img.style.boxShadow = '';
        img.style.borderColor = '#d1d5db';
      }
    };

    // 解析题目
    function parseQuestions(text) {
      const questions = [];
      const errors = [];
      const lines = text.split('\n');

      let currentQuestion = null;
      let currentTypeHint = null; // 记录当前题型提示
      let lineNumber = 0;
      let questionCounter = 0; // 题目计数器

      // 题型映射
      const typeMap = {
        '单选题': { type: 'single', typeName: '单选题' },
        '多选题': { type: 'multiple', typeName: '多选题' },
        '判断题': { type: 'judge', typeName: '判断题' },
        '填空题': { type: 'blank', typeName: '填空题' },
        '简答题': { type: 'shortAnswer', typeName: '简答题' },
        '完形填空': { type: 'cloze', typeName: '完形填空' },
        '复合题': { type: 'composite', typeName: '复合题' }
      };

      for (let line of lines) {
        lineNumber++;
        line = line.trim();
        if (!line) continue;

        // 识别题型标识
        if (typeMap[line]) {
          // 保存上一题
          if (currentQuestion) {
            questions.push(currentQuestion);
          }

          currentTypeHint = typeMap[line];
          questionCounter++;

          // 创建一个临时题目对象
          currentQuestion = {
            id: questionCounter.toString(),
            content: '',
            options: [],
            answer: '',
            explanation: '',
            knowledgePoints: [],
            type: currentTypeHint.type,
            typeName: currentTypeHint.typeName,
            typeHint: currentTypeHint,
            hasError: false,
            errorMessages: [],
            isTemporary: true // 标记为临时题目
          };
          continue;
        }

        // 题目标号
        const titleMatch = line.match(/^(\d+)[.、:。]\s*(.*)$/);
        if (titleMatch) {
          if (currentQuestion && !currentQuestion.isTemporary) {
            // 保存非临时的上一题
            questions.push(currentQuestion);
          }

          currentQuestion = {
            id: titleMatch[1],
            content: '',
            options: [],
            answer: '',
            explanation: '',
            knowledgePoints: [],
            type: currentTypeHint ? currentTypeHint.type : 'unknown',
            typeName: currentTypeHint ? currentTypeHint.typeName : '未知',
            typeHint: currentTypeHint, // 保存题型提示
            hasError: false,
            errorMessages: [],
            isTemporary: false
          };

          // 处理题目内容（保留图片标记）
          const contentText = titleMatch[2];
          currentQuestion.content = contentText;
          continue;
        }

        if (!currentQuestion) continue;

        // 如果是临时题目，遇到非题号行时保持临时状态
        if (currentQuestion.isTemporary) {
          // 不处理其他内容，等待题号出现
          continue;
        }

        // 复合题的子题题型标记（格式：[单选题]、[多选题]、【判断题】等）
        const compositeSubTypeMatch = line.match(/^\[(.+?)\](.*)$/) || line.match(/^【(.+?)】(.*)$/);
        if (compositeSubTypeMatch && currentQuestion.type === 'composite') {
          const subTypeName = compositeSubTypeMatch[1].trim();
          const subContent = compositeSubTypeMatch[2].trim();

          // 子题题型映射
          const subTypeMap = {
            '单选题': 'single',
            '多选题': 'multiple',
            '判断题': 'judge',
            '填空题': 'blank',
            '简答题': 'shortAnswer'
          };

          const subType = subTypeMap[subTypeName];
          if (subType) {
            if (!currentQuestion.compositeSubQuestions) {
              currentQuestion.compositeSubQuestions = [];
              currentQuestion.currentSubQuestion = null; // 当前正在处理的子题
            }

            // 创建新的子题
            currentQuestion.currentSubQuestion = {
              type: subType,
              typeName: subTypeName,
              content: subContent,
              options: [],
              answer: '',
              explanation: ''
            };

            currentQuestion.compositeSubQuestions.push(currentQuestion.currentSubQuestion);
            continue;
          }
        }

        // 完形填空的子题选项（格式：1)A. xxx B. xxx C. xxx D. xxx 或 1）A. xxx B. xxx）
        const clozeSubQuestionMatch = line.match(/^(\d+)[)）](.+)$/);
        if (clozeSubQuestionMatch && currentQuestion.type === 'cloze') {
          const subQuestionIndex = clozeSubQuestionMatch[1];
          const optionsText = clozeSubQuestionMatch[2].trim();

          // 解析选项（A. xxx B. xxx C. xxx D. xxx）
          const optionRegex = /([A-E])\.\s*([^\s]+(?:\s+[^\s]+)*?)(?=\s+[A-E]\.|$)/g;
          const subOptions = [];
          let optMatch;

          while ((optMatch = optionRegex.exec(optionsText)) !== null) {
            subOptions.push({
              label: optMatch[1],
              text: optMatch[2].trim()
            });
          }

          if (!currentQuestion.clozeSubQuestions) {
            currentQuestion.clozeSubQuestions = [];
          }

          currentQuestion.clozeSubQuestions.push({
            index: parseInt(subQuestionIndex),
            options: subOptions
          });
          continue;
        }

        // 普通选项（单选题、多选题等）或复合题子题的选项
        const optionMatch = line.match(/^([A-E])[.、:。：]\s*(.+)$/);
        if (optionMatch) {
          // 如果是复合题且当前有子题，将选项添加到子题
          if (currentQuestion.type === 'composite' && currentQuestion.currentSubQuestion) {
            currentQuestion.currentSubQuestion.options.push({
              label: optionMatch[1],
              text: optionMatch[2]
            });
          } else {
            // 否则添加到主题目
            currentQuestion.options.push({
              label: optionMatch[1],
              text: optionMatch[2]
            });
          }
          continue;
        }

        // 答案（支持"答案："、"答："、"正确答案："）
        if (line.startsWith('答案：') || line.startsWith('答：') || line.startsWith('正确答案：')) {
          const answerText = line.replace(/^(正确)?答案?：/, '').trim();

          // 如果是复合题且当前有子题，将答案添加到子题
          if (currentQuestion.type === 'composite' && currentQuestion.currentSubQuestion) {
            currentQuestion.currentSubQuestion.answer = answerText;
          } else {
            // 否则添加到主题目
            currentQuestion.answer = answerText;
          }
          continue;
        }

        // 解析（支持"解析："、"答案解析："、"参考答案："）
        if (line.startsWith('解析：') || line.startsWith('答案解析：') || line.startsWith('参考答案：')) {
          let explanationText = line;
          if (line.startsWith('答案解析：')) {
            explanationText = line.replace('答案解析：', '').trim();
          } else if (line.startsWith('参考答案：')) {
            explanationText = line.replace('参考答案：', '').trim();
          } else if (line.startsWith('解析：')) {
            explanationText = line.replace('解析：', '').trim();
          }

          // 如果是复合题且当前有子题，将解析添加到子题
          if (currentQuestion.type === 'composite' && currentQuestion.currentSubQuestion) {
            currentQuestion.currentSubQuestion.explanation = explanationText;
          } else {
            // 否则添加到主题目
            currentQuestion.explanation = explanationText;
          }
          continue;
        }

        // 知识点
        if (line.startsWith('知识点：')) {
          const kps = line.replace('知识点：', '').trim();
          currentQuestion.knowledgePoints = kps.split(/[，、；]/).map(k => k.trim());
          console.log('[解析] 知识点行:', line);
          console.log('[解析] 提取的知识点:', currentQuestion.knowledgePoints);
          continue;
        }

        // 其他行作为题目内容的一部分（多行题干）
        // 排除已知的关键词开头的行
        const knownPrefixes = ['答案：', '答：', '正确答案：', '解析：', '答案解析：', '参考答案：', '知识点：', 'A.', 'B.', 'C.', 'D.', 'E.', '[', '【'];
        const isKnownLine = knownPrefixes.some(prefix => line.startsWith(prefix));

        if (line && !isKnownLine) {
          // 如果是复合题且当前有子题，将内容追加到子题
          if (currentQuestion.type === 'composite' && currentQuestion.currentSubQuestion) {
            if (currentQuestion.currentSubQuestion.content) {
              currentQuestion.currentSubQuestion.content += ' ' + line;
            } else {
              currentQuestion.currentSubQuestion.content = line;
            }
          } else if (currentQuestion.content) {
            // 否则追加到主题目
            currentQuestion.content += ' ' + line;
          }
        }
      }

      // 最后一题
      if (currentQuestion) {
        questions.push(currentQuestion);
      }

      // 设置题目索引并检查错误
      questions.forEach((q, index) => {
        q.index = index;
        q.contentError = null;    // 题目内容错误
        q.optionsError = null;    // 选项错误
        q.answerError = null;     // 答案错误
        q.knowledgeError = null;  // 知识点错误

        // 检查是否缺少题型标识
        if (!q.typeHint) {
          q.contentError = '缺少题型标识（需在题目前添加：单选题、多选题、判断题等）';
        }

        // 如果是临时题目（只有题型标识，没有题号）
        if (q.isTemporary) {
          q.contentError = '题目内容无法识别，题目标号支持1.、1:、1、和1。四种格式';
          q.optionsError = '选项无法识别，选项格式为"A. 选项内容"';
          q.answerError = '答案无法识别，题目必须包含"答案："字段，且不能为空';
          q.knowledgeError = '知识点无法识别，题目必须有知识点属性。"知识点：知识点编号"';
          q.hasError = true;
          return; // 临时题目不需要继续检查
        }

        // 检查题目内容
        if (!q.content || q.content.trim() === '') {
          q.contentError = '题目内容无法识别，题目标号支持1.、1:、1、和1。四种格式';
        }

        // 对于有选项的题型，检查选项和答案
        if (q.type === 'single' || q.type === 'multiple') {
          if (q.options.length === 0) {
            q.optionsError = '选项无法识别，选项格式为"A. 选项内容"';
          }

          if (!q.answer || q.answer.trim() === '') {
            q.answerError = '答案无法识别，题目必须包含"答案："字段，且不能为空';
          } else {
            // 单选题和多选题的答案不支持插入图片，只能是纯字母
            const imageRegex = /\[图片:(img_\d+)\]/;
            if (imageRegex.test(q.answer)) {
              q.answerError = '答案无法识别，答案只能是选项字母（如A、B、AB等），不支持插入图片';
            } else {
              // 验证答案格式
              const answer = q.answer.trim().toUpperCase();
              const validOptions = q.options.map(opt => opt.label);

              // 检查答案是否只包含字母
              if (!/^[A-E]+$/.test(answer)) {
                q.answerError = '答案格式错误，答案只能包含选项字母（A-E）';
              } else {
                // 单选题：答案必须是单个字母
                if (q.type === 'single') {
                  if (answer.length !== 1) {
                    q.answerError = '单选题答案必须是单个字母（如A、B、C等）';
                  } else if (!validOptions.includes(answer)) {
                    q.answerError = `答案"${answer}"不在可选项范围内（${validOptions.join('、')}）`;
                  }
                }

                // 多选题：答案可以是多个字母，且每个字母必须在选项范围内
                if (q.type === 'multiple') {
                  if (answer.length < 2) {
                    q.answerError = '多选题答案至少需要2个选项（如AB、ABC等）';
                  } else {
                    // 检查每个字母是否在选项范围内
                    const answerLetters = answer.split('');
                    const invalidLetters = answerLetters.filter(letter => !validOptions.includes(letter));

                    if (invalidLetters.length > 0) {
                      q.answerError = `答案中的"${invalidLetters.join('、')}"不在可选项范围内（${validOptions.join('、')}）`;
                    }

                    // 检查是否有重复的字母
                    const uniqueLetters = [...new Set(answerLetters)];
                    if (uniqueLetters.length !== answerLetters.length) {
                      q.answerError = '多选题答案不能包含重复的选项字母';
                    }
                  }
                }
              }
            }
          }
        }

        // 对于判断题，检查答案
        if (q.type === 'judge') {
          if (!q.answer || q.answer.trim() === '') {
            q.answerError = '答案无法识别，判断题答案格式为"答案：正确"或"答案：错误"';
          } else {
            // 判断题答案不支持插入图片
            const imageRegex = /\[图片:(img_\d+)\]/;
            if (imageRegex.test(q.answer)) {
              q.answerError = '判断题答案不支持插入图片，只能是文字（正确/错误、对/错等）';
            } else {
              // 验证判断题答案格式
              const answer = q.answer.trim();

              // 定义有效的答案映射（支持多种表达方式）
              const validAnswersMap = {
                // 正确的表达
                '正确': 'correct',
                '对': 'correct',
                '是': 'correct',
                'T': 'correct',
                't': 'correct',
                'TRUE': 'correct',
                'true': 'correct',
                'True': 'correct',
                '√': 'correct',
                '✓': 'correct',
                '✔': 'correct',
                '对的': 'correct',
                '正确的': 'correct',

                // 错误的表达
                '错误': 'wrong',
                '错': 'wrong',
                '否': 'wrong',
                'F': 'wrong',
                'f': 'wrong',
                'FALSE': 'wrong',
                'false': 'wrong',
                'False': 'wrong',
                '×': 'wrong',
                '✗': 'wrong',
                '✘': 'wrong',
                '错的': 'wrong',
                '错误的': 'wrong'
              };

              // 检查答案是否在有效范围内
              if (!validAnswersMap[answer]) {
                q.answerError = '答案格式错误，判断题答案支持：正确/错误、对/错、是/否、T/F、√/× 等格式';
              } else {
                // 标准化答案（统一转换为"正确"或"错误"，便于后续处理）
                q.normalizedAnswer = validAnswersMap[answer] === 'correct' ? '正确' : '错误';
              }
            }
          }
        }

        // 对于填空题，检查空位和答案
        if (q.type === 'blank') {
          if (!q.answer || q.answer.trim() === '') {
            q.answerError = '答案无法识别，填空题必须包含"答案："字段，且不能为空';
          } else {
            // 检查题干中是否有空位标记
            const blankRegex1 = /_{2,}/g; // 匹配 ____ (两个或多个下划线)
            const blankRegex2 = /[（(][^）)]*[）)]/g; // 匹配 （） 或 ()

            const blanks1 = q.content.match(blankRegex1) || [];
            const blanks2 = q.content.match(blankRegex2) || [];
            const totalBlanks = blanks1.length + blanks2.length;

            if (totalBlanks === 0) {
              q.contentError = '填空题题干中必须包含空位标记（____或（））';
            } else {
              // 解析答案（支持分号、中文分号分隔）
              const answers = q.answer.split(/[;；]/).map(a => a.trim()).filter(a => a);

              // 检查答案数量是否匹配空位数量
              if (answers.length !== totalBlanks) {
                q.answerError = `答案数量（${answers.length}个）与空位数量（${totalBlanks}个）不匹配，多个答案请用"；"分隔`;
              } else {
                // 提取答案详情（同义词用|||分隔）
                q.blankAnswers = answers.map(ans => {
                  const synonyms = ans.split('|||').map(s => s.trim()).filter(s => s);
                  return {
                    text: ans,
                    synonyms: synonyms
                  };
                });
              }
            }
          }
        }

        // 对于简答题，检查答案
        if (q.type === 'shortAnswer') {
          if (!q.answer || q.answer.trim() === '') {
            q.answerError = '答案无法识别，简答题必须包含"答案："字段，且不能为空';
          } else {
            // 简答题答案可以包含图片、多行文本等
            // 只需要确保不为空即可
            const answerWithoutImages = q.answer.replace(/\[图片:img_\d+\]/g, '').trim();
            if (!answerWithoutImages && !q.answer.includes('[图片:')) {
              q.answerError = '答案内容不能为空';
            }
          }
        }

        // 对于完形填空，检查子题和答案
        if (q.type === 'cloze') {
          // 检查是否有子题
          if (!q.clozeSubQuestions || q.clozeSubQuestions.length === 0) {
            q.optionsError = '完形填空必须包含子题，格式为"1)A. 选项1  B. 选项2  C. 选项3  D. 选项4"';
          }

          // 检查答案
          if (!q.answer || q.answer.trim() === '') {
            q.answerError = '答案无法识别，完形填空必须包含"答案："字段，且不能为空';
          } else {
            // 完形填空答案不支持插入图片
            const imageRegex = /\[图片:(img_\d+)\]/;
            if (imageRegex.test(q.answer)) {
              q.answerError = '完形填空答案不支持插入图片，只能是连续的选项字母（如ABCD、BDCA等）';
            } else {
              const answer = q.answer.trim().toUpperCase();
              const subQuestionsCount = q.clozeSubQuestions ? q.clozeSubQuestions.length : 0;

              // 检查答案是否只包含字母
              if (!/^[A-E]+$/.test(answer)) {
                q.answerError = '答案格式错误，完形填空答案只能包含选项字母（A-E）';
              } else if (answer.length !== subQuestionsCount) {
                q.answerError = `答案长度（${answer.length}个字母）与子题数量（${subQuestionsCount}个）不匹配`;
              } else if (subQuestionsCount > 0) {
                // 检查每个答案字母是否在对应子题的选项范围内
                const answerLetters = answer.split('');
                let invalidAnswers = [];

                for (let i = 0; i < answerLetters.length; i++) {
                  const letter = answerLetters[i];
                  const subQuestion = q.clozeSubQuestions[i];
                  if (subQuestion) {
                    const validOptions = subQuestion.options.map(opt => opt.label);
                    if (!validOptions.includes(letter)) {
                      invalidAnswers.push(`第${i + 1}题答案"${letter}"不在选项范围内（${validOptions.join('、')}）`);
                    }
                  }
                }

                if (invalidAnswers.length > 0) {
                  q.answerError = invalidAnswers.join('；');
                }
              }
            }
          }
        }

        // 对于复合题，检查材料和子题
        if (q.type === 'composite') {
          // 检查是否有材料内容
          if (!q.content || q.content.trim() === '') {
            q.contentError = '复合题必须包含材料内容';
          }

          // 检查是否有子题
          if (!q.compositeSubQuestions || q.compositeSubQuestions.length === 0) {
            q.optionsError = '复合题必须包含至少1个子题，格式为"[题型]题干内容"';
          } else {
            // 验证每个子题
            q.compositeSubQuestions.forEach((subQ, subIdx) => {
              // 初始化子题的错误属性
              subQ.contentError = '';
              subQ.optionsError = '';
              subQ.answerError = '';

              // 检查子题内容
              if (!subQ.content || subQ.content.trim() === '') {
                subQ.contentError = '缺少题干内容';
              }

              // 根据子题类型验证
              if (subQ.type === 'single' || subQ.type === 'multiple') {
                // 检查选项
                if (subQ.options.length === 0) {
                  subQ.optionsError = '缺少选项';
                }

                // 检查答案
                if (!subQ.answer || subQ.answer.trim() === '') {
                  subQ.answerError = '缺少答案';
                } else {
                  const answer = subQ.answer.trim().toUpperCase();
                  const validOptions = subQ.options.map(opt => opt.label);

                  // 单选题验证
                  if (subQ.type === 'single') {
                    if (answer.length !== 1) {
                      subQ.answerError = '答案必须是单个字母';
                    } else if (!validOptions.includes(answer)) {
                      subQ.answerError = `答案"${answer}"不在选项范围内`;
                    }
                  }

                  // 多选题验证
                  if (subQ.type === 'multiple') {
                    if (answer.length < 2) {
                      subQ.answerError = '答案至少需要2个字母';
                    } else {
                      const answerLetters = answer.split('');
                      const invalidLetters = answerLetters.filter(letter => !validOptions.includes(letter));
                      if (invalidLetters.length > 0) {
                        subQ.answerError = `答案中的"${invalidLetters.join('、')}"不在选项范围内`;
                      }
                      // 检查是否有重复字母
                      const uniqueLetters = [...new Set(answerLetters)];
                      if (uniqueLetters.length !== answerLetters.length) {
                        subQ.answerError = '答案中不能有重复字母';
                      }
                    }
                  }
                }
              } else if (subQ.type === 'judge') {
                // 判断题验证
                if (!subQ.answer || subQ.answer.trim() === '') {
                  subQ.answerError = '缺少答案';
                }
              } else if (subQ.type === 'blank') {
                // 填空题验证
                if (!subQ.answer || subQ.answer.trim() === '') {
                  subQ.answerError = '缺少答案';
                } else {
                  // 检查题干中是否有空位标记
                  const blankRegex1 = /_{2,}/g; // 匹配 ____ (两个或多个下划线)
                  const blankRegex2 = /[（(][^）)]*[）)]/g; // 匹配 （） 或 ()

                  const blanks1 = subQ.content.match(blankRegex1) || [];
                  const blanks2 = subQ.content.match(blankRegex2) || [];
                  const totalBlanks = blanks1.length + blanks2.length;

                  if (totalBlanks === 0) {
                    subQ.contentError = '题干中必须包含空位标记（____或（））';
                  } else {
                    // 解析答案（支持分号、中文分号分隔）
                    const answers = subQ.answer.split(/[;；]/).map(a => a.trim()).filter(a => a);

                    // 检查答案数量是否匹配空位数量
                    if (answers.length !== totalBlanks) {
                      subQ.answerError = `答案数量（${answers.length}个）与空位数量（${totalBlanks}个）不匹配`;
                    } else {
                      // 提取答案详情（同义词用|||分隔）
                      subQ.blankAnswers = answers.map(ans => {
                        const synonyms = ans.split('|||').map(s => s.trim()).filter(s => s);
                        return {
                          text: ans,
                          synonyms: synonyms
                        };
                      });
                    }
                  }
                }
              } else if (subQ.type === 'shortAnswer') {
                // 简答题验证
                if (!subQ.answer || subQ.answer.trim() === '') {
                  subQ.answerError = '缺少答案';
                }
              }

              // 如果子题有任何错误，标记主题目有错误
              if (subQ.contentError || subQ.optionsError || subQ.answerError) {
                if (!q.answerError) q.answerError = '部分子题存在错误';
              }
            });
          }
        }

        // 检查知识点
        if (q.knowledgePoints.length === 0 || !q.knowledgePoints[0]) {
          q.knowledgeError = '知识点无法识别，题目必须有知识点属性。"知识点：知识点编号"';
        } else {
          // 验证知识点是否存在
          q.knowledgeError = validateKnowledgePoints(q.knowledgePoints);
        }

        // 如果有任何错误，标记为错误题目
        if (q.contentError || q.optionsError || q.answerError || q.knowledgeError) {
          q.hasError = true;
        }
      });

      return { questions, errors };
    }

    // 更新统计
    function updateStatistics() {
      const successCount = parsedData.filter(q => !q.hasError).length;
      const errorCount = parsedData.filter(q => q.hasError).length;

      document.getElementById('successCountText').textContent = `成功识别${successCount}题`;
      document.getElementById('errorCountText').textContent = `识别失败${errorCount}题`;
      document.getElementById('totalCount').textContent = parsedData.length;

      if (errorCount > 0) {
        document.getElementById('errorButton').classList.remove('hidden');
        document.getElementById('nextErrorBtn').classList.remove('hidden');
      } else {
        document.getElementById('errorButton').classList.add('hidden');
        document.getElementById('nextErrorBtn').classList.add('hidden');
      }

      if (parsedData.length > 0) {
        document.getElementById('bottomActions').style.display = 'flex';
      } else {
        document.getElementById('bottomActions').style.display = 'none';
      }
    }

    // 显示题目
    function displayQuestions() {
      const container = document.getElementById('parsedQuestions');

      if (parsedData.length === 0) {
        showEmptyState();
        return;
      }

      document.getElementById('emptyState').style.display = 'none';
      container.style.display = 'block';
      container.innerHTML = '';

      parsedData.forEach((q, index) => {
        const card = createQuestionCard(q, index);
        container.appendChild(card);
      });
    }

    // 创建题目卡片
    function createQuestionCard(q, index) {
      const div = document.createElement('div');
      div.className = 'question-card bg-white rounded-lg border-2 p-5 ' + (q.hasError ? 'border-error-200' : 'border-gray-200');
      div.id = 'question-' + index;

      let optionsHtml = '';
      if (q.type === 'judge') {
        // 使用标准化后的答案（如果有的话），否则使用原始答案
        const displayAnswer = q.normalizedAnswer || q.answer;
        const isCorrect = displayAnswer === '正确' || displayAnswer === '对' || displayAnswer === 'T' || displayAnswer === '是' || displayAnswer === '√' || displayAnswer === '✓';
        const isWrong = displayAnswer === '错误' || displayAnswer === '错' || displayAnswer === 'F' || displayAnswer === '否' || displayAnswer === '×' || displayAnswer === '✗';

        optionsHtml = `
          <div class="space-y-2 mb-4">
            <div class="radio-option ${isCorrect ? 'bg-primary-50' : ''}">
              <input type="radio" name="judge-${index}" ${isCorrect ? 'checked' : ''}>
              <span class="text-sm text-gray-700">正确</span>
            </div>
            <div class="radio-option ${isWrong ? 'bg-primary-50' : ''}">
              <input type="radio" name="judge-${index}" ${isWrong ? 'checked' : ''}>
              <span class="text-sm text-gray-700">错误</span>
            </div>
          </div>
        `;
      } else if (q.type === 'cloze' && q.clozeSubQuestions && q.clozeSubQuestions.length > 0) {
        // 完形填空：显示子题列表
        const answerLetters = q.answer ? q.answer.trim().toUpperCase().split('') : [];
        optionsHtml = '<div class="space-y-2 mb-4">';
        q.clozeSubQuestions.forEach((subQ, subIdx) => {
          const correctAnswer = answerLetters[subIdx];
          optionsHtml += `
            <div class="flex items-start py-1">
              <span class="text-xs font-medium text-gray-600 mr-3 flex-shrink-0 mt-0.5">${subQ.index}）</span>
              <div class="flex flex-wrap gap-2 flex-1">
                ${subQ.options.map(opt => {
                  const isCorrect = opt.label === correctAnswer;
                  return `
                    <span class="inline-flex items-center px-2.5 py-1 rounded text-xs ${isCorrect ? 'bg-success-500 text-white font-medium' : 'bg-gray-100 text-gray-700'}">
                      ${opt.label}. ${opt.text}
                    </span>
                  `;
                }).join('')}
              </div>
            </div>
          `;
        });
        optionsHtml += '</div>';
      } else if (q.options.length > 0) {
        optionsHtml = '<div class="space-y-2 mb-4">';
        q.options.forEach((opt, optIndex) => {
          const isCorrect = q.answer && q.answer.includes(opt.label);
          // 使用convertImagesToHTML将选项中的图片标记转换为内联图片
          const optionTextWithImages = convertImagesToHTML(opt.text);
          optionsHtml += `
            <div class="flex items-start py-1"
                 data-drop-target="option"
                 data-question-index="${index}"
                 data-option-index="${optIndex}"
                 ondragover="handleDragOver(event)"
                 ondragleave="handleDragLeave(event)"
                 ondrop="handleImageDrop(event, ${index}, 'option', ${optIndex})">
              <span class="inline-flex items-center justify-center w-6 h-6 rounded-full text-xs font-medium mr-2 flex-shrink-0 ${isCorrect ? 'bg-success-500 text-white' : 'bg-gray-100 text-gray-600'}">${opt.label}</span>
              <span class="text-sm text-gray-700">${optionTextWithImages}</span>
            </div>
          `;
        });
        optionsHtml += '</div>';
      } else if (q.type === 'composite' && q.compositeSubQuestions && q.compositeSubQuestions.length > 0) {
        // 复合题：显示子题列表
        optionsHtml = '<div class="space-y-4 mb-4 border-t border-gray-200 pt-4">';
        q.compositeSubQuestions.forEach((subQ, subIdx) => {
          let subOptionsHtml = '';

          // 根据子题类型显示选项
          if (subQ.type === 'single' || subQ.type === 'multiple') {
            subOptionsHtml = '<div class="space-y-1.5 mt-2">';
            subQ.options.forEach((opt) => {
              const isCorrect = subQ.answer && subQ.answer.toUpperCase().includes(opt.label);
              subOptionsHtml += `
                <div class="flex items-start py-0.5">
                  <span class="inline-flex items-center justify-center w-5 h-5 rounded-full text-xs font-medium mr-2 flex-shrink-0 ${isCorrect ? 'bg-success-500 text-white' : 'bg-gray-100 text-gray-600'}">${opt.label}</span>
                  <span class="text-xs text-gray-700">${convertImagesToHTML(opt.text)}</span>
                </div>
              `;
            });
            subOptionsHtml += '</div>';
          } else if (subQ.type === 'judge') {
            const isCorrect = subQ.answer === '正确' || subQ.answer === '对' || subQ.answer === 'T';
            const isWrong = subQ.answer === '错误' || subQ.answer === '错' || subQ.answer === 'F';
            subOptionsHtml = `
              <div class="flex gap-3 mt-2">
                <span class="inline-flex items-center px-3 py-1 rounded text-xs ${isCorrect ? 'bg-success-500 text-white font-medium' : 'bg-gray-100 text-gray-700'}">正确</span>
                <span class="inline-flex items-center px-3 py-1 rounded text-xs ${isWrong ? 'bg-success-500 text-white font-medium' : 'bg-gray-100 text-gray-700'}">错误</span>
              </div>
            `;
          }

          optionsHtml += `
            <div class="bg-gray-50 rounded-lg p-4 border ${subQ.contentError || subQ.optionsError || subQ.answerError ? 'border-error-300' : 'border-gray-200'}">
              <div class="flex items-start mb-2">
                <span class="inline-flex items-center justify-center w-6 h-6 rounded-full bg-primary-500 text-white text-xs font-medium mr-2 flex-shrink-0">${subIdx + 1}</span>
                <div class="flex-1">
                  <span class="inline-block px-2 py-0.5 bg-info-100 text-info-700 text-xs font-medium rounded mr-2">【${subQ.typeName}】</span>
                  <span class="text-sm text-gray-900">${convertImagesToHTML(subQ.content || '')}</span>
                  ${subQ.contentError ? `<div class="mt-1"><span class="text-xs text-error-600"><i class="fas fa-exclamation-circle mr-1"></i>${subQ.contentError}</span></div>` : ''}
                </div>
              </div>
              ${subOptionsHtml}
              ${subQ.optionsError ? `<div class="mt-2"><span class="text-xs text-error-600"><i class="fas fa-exclamation-circle mr-1"></i>${subQ.optionsError}</span></div>` : ''}
              <div class="mt-2 text-xs">
                <span class="text-gray-500">答案：</span>
                ${subQ.type === 'blank' && subQ.blankAnswers && subQ.blankAnswers.length > 0 ?
                  `<div class="block mt-1">
                    ${subQ.blankAnswers.map((ans, idx) => `
                      <div class="text-gray-900 ${idx > 0 ? 'mt-1' : ''}">
                        <span class="inline-block w-4 text-gray-500">${idx + 1}.</span>
                        <span class="font-medium">${convertImagesToHTML(ans.text)}</span>
                        ${ans.synonyms.length > 1 ?
                          `<span class="text-xs text-gray-500 ml-1">(同义词: ${ans.synonyms.join(' / ')})</span>` :
                          ''}
                      </div>
                    `).join('')}
                  </div>` :
                  `<span class="text-gray-900 font-medium">${subQ.answer || ''}</span>`
                }
                ${subQ.answerError ? `<div class="mt-1"><span class="text-error-600"><i class="fas fa-exclamation-circle mr-1"></i>${subQ.answerError}</span></div>` : ''}
              </div>
              ${subQ.explanation ? `
              <div class="mt-2 text-xs">
                <span class="text-gray-500">解析：</span>
                <span class="text-gray-700">${convertImagesToHTML(subQ.explanation)}</span>
              </div>
              ` : ''}
            </div>
          `;
        });
        optionsHtml += '</div>';
      }

      // 生成知识点标签 HTML
      let knowledgeTagsHtml = '';
      if (q.knowledgePoints.length > 0 && q.knowledgePoints[0]) {
        knowledgeTagsHtml = '<div class="flex flex-wrap gap-2 mb-2">';
        q.knowledgePoints.forEach((kp, kpIndex) => {
          const kpName = knowledgePointsMap[kp] || kp;
          knowledgeTagsHtml += `
            <span class="inline-flex items-center px-2 py-1 rounded-md text-xs bg-primary-50 text-primary-700 border border-primary-200">
              ${kpName}
              <button onclick="removeKnowledgePoint(${index}, ${kpIndex})" class="ml-1.5 text-primary-500 hover:text-primary-700">
                <i class="fas fa-times text-xs"></i>
              </button>
            </span>
          `;
        });
        knowledgeTagsHtml += '</div>';
      }

      div.innerHTML = `
        <div class="flex items-start mb-3">
          <h4 class="text-sm font-semibold text-gray-900">【${q.typeName}】</h4>
        </div>

        <div class="mb-4"
             data-drop-target="content"
             data-question-index="${index}"
             ondragover="handleDragOver(event)"
             ondragleave="handleDragLeave(event)"
             ondrop="handleImageDrop(event, ${index}, 'content')">
          <p class="text-sm text-gray-900 leading-relaxed">${q.id}、${convertImagesToHTML(q.content || '')}</p>
          ${q.contentError ? `<div class="error-text text-xs mt-2">${q.contentError}</div>` : ''}
        </div>

        ${optionsHtml}
        ${q.optionsError ? `<div class="error-text text-xs mb-4">${q.optionsError}</div>` : ''}

        ${q.type !== 'composite' ? `
        <div class="mb-4">
          <div class="flex items-start text-sm">
            <span class="text-gray-500 mr-2 flex-shrink-0">答案：</span>
            <div class="flex-1">
              ${q.type === 'judge' && q.normalizedAnswer ?
                `<span class="text-gray-900 font-medium">${q.normalizedAnswer}</span>` :
                q.type === 'blank' && q.blankAnswers && q.blankAnswers.length > 0 ?
                  `<div class="space-y-1">
                    ${q.blankAnswers.map((ans, idx) => `
                      <div class="text-gray-900">
                        <span class="inline-block w-5 text-gray-500">${idx + 1}.</span>
                        <span class="font-medium">${convertImagesToHTML(ans.text)}</span>
                        ${ans.synonyms.length > 1 ?
                          `<span class="text-xs text-gray-500 ml-2">(同义词: ${ans.synonyms.join(' / ')})</span>` :
                          ''}
                      </div>
                    `).join('')}
                  </div>` :
                  `<span class="text-gray-900 font-medium">${convertImagesToHTML(q.answer || '')}</span>`
              }
            </div>
          </div>
          ${q.answerError ? `<div class="error-text text-xs mt-2">${q.answerError}</div>` : ''}
        </div>
        ` : q.answerError ? `<div class="error-text text-xs mb-4">${q.answerError}</div>` : ''}

        ${q.explanation && q.type !== 'composite' ? `
        <div class="mb-4"
             data-drop-target="explanation"
             data-question-index="${index}"
             ondragover="handleDragOver(event)"
             ondragleave="handleDragLeave(event)"
             ondrop="handleImageDrop(event, ${index}, 'explanation')">
          <div class="flex items-start text-sm">
            <span class="text-gray-500 mr-2 flex-shrink-0">解析：</span>
            <span class="text-gray-700">${convertImagesToHTML(q.explanation)}</span>
          </div>
        </div>
        ` : ''}

        <div class="flex items-start text-sm">
          <span class="text-gray-500 mr-2 flex-shrink-0">知识点：</span>
          <div class="flex-1">
            ${knowledgeTagsHtml}
            <button onclick="addKnowledgePoint(${index})" class="text-xs text-primary-500 hover:text-primary-600 border border-gray-300 rounded px-2 py-0.5">
              <i class="fas fa-plus mr-1"></i>
              添加知识点
            </button>
            ${q.knowledgeError ? `<div class="error-text text-xs mt-2">${q.knowledgeError}</div>` : ''}
          </div>
        </div>
      `;

      return div;
    }

    // 显示空状态
    function showEmptyState() {
      document.getElementById('emptyState').style.display = 'flex';
      document.getElementById('parsedQuestions').style.display = 'none';
      document.getElementById('bottomActions').style.display = 'none';
      document.getElementById('successCountText').textContent = '成功识别0题';
      document.getElementById('errorCountText').textContent = '识别失败0题';
      document.getElementById('errorButton').classList.add('hidden');
      document.getElementById('nextErrorBtn').classList.add('hidden');
    }

    // 删除题目
    function deleteQuestion(index) {
      parsedData.splice(index, 1);
      updateStatistics();
      displayQuestions();
    }

    // 跳转到第一个错误
    function jumpToFirstError() {
      const firstError = parsedData.findIndex(q => q.hasError);
      if (firstError !== -1) {
        const element = document.getElementById('question-' + firstError);
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    // 跳转到下一个错误
    function jumpToNextError() {
      const errors = parsedData.map((q, i) => q.hasError ? i : -1).filter(i => i !== -1);
      if (errors.length === 0) return;

      currentErrorIndex = (currentErrorIndex + 1) % errors.length;
      const element = document.getElementById('question-' + errors[currentErrorIndex]);
      element.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // 选择知识点（全局）
    function selectKnowledgePoints() {
      knowledgeSelectionMode = 'all';
      currentQuestionIndex = -1;
      selectedKnowledgePoints = [];
      openKnowledgeModal();
    }

    // 添加知识点（单个题目）
    function addKnowledgePoint(index) {
      knowledgeSelectionMode = 'single';
      currentQuestionIndex = index;
      // 预选当前题目已有的知识点
      if (parsedData[index] && parsedData[index].knowledgePoints) {
        selectedKnowledgePoints = [...parsedData[index].knowledgePoints];
      } else {
        selectedKnowledgePoints = [];
      }
      openKnowledgeModal();
    }

    // 删除知识点
    function removeKnowledgePoint(questionIndex, knowledgeIndex) {
      if (!parsedData[questionIndex]) return;

      const question = parsedData[questionIndex];
      const removedKnowledge = question.knowledgePoints[knowledgeIndex];
      const removedKnowledgeName = knowledgePointsMap[removedKnowledge] || removedKnowledge;

      // 从数组中删除该知识点
      question.knowledgePoints.splice(knowledgeIndex, 1);

      // 更新 textarea 中的知识点
      removeKnowledgePointFromTextarea(questionIndex, removedKnowledgeName);
    }

    // 从 textarea 中删除知识点
    function removeKnowledgePointFromTextarea(questionIndex, knowledgeName) {
      console.log('=== 删除知识点开始 ===');
      console.log('题目索引:', questionIndex);
      console.log('知识点名称:', knowledgeName);

      const inputDiv = document.getElementById('inputText');
      let text = getInputText(); // 使用 getInputText 获取文本
      console.log('当前文本:', text);

      const lines = text.split('\n');
      let newLines = [];
      let questionIdx = -1;
      let inQuestion = false;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // 检测题型标识
        const typeMap = {
          '单选题': { type: 'single', typeName: '单选题' },
          '多选题': { type: 'multiple', typeName: '多选题' },
          '判断题': { type: 'judge', typeName: '判断题' },
          '填空题': { type: 'blank', typeName: '填空题' },
          '简答题': { type: 'essay', typeName: '简答题' },
          '完形填空': { type: 'cloze', typeName: '完形填空' },
          '复合题': { type: 'composite', typeName: '复合题' }
        };

        if (typeMap[line]) {
          inQuestion = true;
          newLines.push(lines[i]);
          continue;
        }

        // 检测题号
        if (/^\d+[.、:。]\s*/.test(line) && inQuestion) {
          questionIdx++;
        }

        // 检测知识点行
        if (line.startsWith('知识点：') && inQuestion && questionIdx === questionIndex) {
          // 这是要修改的题目的知识点行
          const knowledgeText = line.replace(/^知识点：/, '');
          const knowledges = knowledgeText.split(/[、,，]/).map(k => k.trim()).filter(k => k);

          console.log('原知识点:', knowledges);

          // 删除指定的知识点
          const updatedKnowledges = knowledges.filter(k => k !== knowledgeName);

          console.log('删除后知识点:', updatedKnowledges);

          // 如果还有剩余知识点，更新该行；否则跳过该行
          if (updatedKnowledges.length > 0) {
            newLines.push('知识点：' + updatedKnowledges.join('、'));
          }
          // 如果没有剩余知识点，不添加这一行（相当于删除整行）
          continue;
        }

        // 其他行直接添加
        newLines.push(lines[i]);
      }

      // 更新内容，使用 setInputText
      const newText = newLines.join('\n');
      console.log('新文本:', newText);
      setInputText(newText);

      // 重新解析
      handleInputChange();
      console.log('=== 删除知识点完成 ===');
    }

    // 打开知识点选择弹窗
    function openKnowledgeModal() {
      console.log('打开知识点选择弹窗');
      console.log('知识点树数据:', knowledgePointsTree);
      document.getElementById('knowledgeModal').classList.remove('hidden');
      renderKnowledgeTree();
      updateSelectedCount();
    }

    // 关闭知识点选择弹窗
    function closeKnowledgeModal() {
      document.getElementById('knowledgeModal').classList.add('hidden');
      document.getElementById('knowledgeSearch').value = '';
      selectedKnowledgePoints = [];
    }

    // 渲染知识点树
    function renderKnowledgeTree() {
      console.log('开始渲染知识点树');
      const container = document.getElementById('knowledgeTree');
      container.innerHTML = '';

      if (!knowledgePointsTree || knowledgePointsTree.length === 0) {
        console.warn('知识点树为空');
        container.innerHTML = '<div class="text-center text-gray-500 py-8">暂无知识点数据<br><small class="text-xs">请先在题库管理页面添加知识点</small></div>';
        return;
      }

      console.log('知识点树节点数量:', knowledgePointsTree.length);

      function renderNode(node, level = 0) {
        const div = document.createElement('div');
        div.className = 'knowledge-node';

        const nodeContent = document.createElement('div');
        nodeContent.style.paddingLeft = (level * 20) + 'px';
        nodeContent.className = 'py-2 px-3 hover:bg-gray-50 rounded cursor-pointer flex items-center space-x-2';

        // 如果有子节点，添加展开/折叠图标
        if (node.children && node.children.length > 0) {
          const toggleIcon = document.createElement('i');
          toggleIcon.className = 'fas fa-chevron-down text-xs text-gray-400 transition-transform';
          toggleIcon.style.width = '12px';
          toggleIcon.onclick = (e) => {
            e.stopPropagation();
            const childrenContainer = div.querySelector('.children-container');
            if (childrenContainer) {
              const isHidden = childrenContainer.style.display === 'none';
              childrenContainer.style.display = isHidden ? 'block' : 'none';
              toggleIcon.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(-90deg)';
            }
          };
          nodeContent.appendChild(toggleIcon);
        } else {
          // 占位，保持对齐
          const spacer = document.createElement('span');
          spacer.style.width = '12px';
          spacer.style.display = 'inline-block';
          nodeContent.appendChild(spacer);
        }

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'rounded border-gray-300 text-primary-500 focus:ring-primary-500';
        checkbox.checked = selectedKnowledgePoints.includes(node.id);
        checkbox.onclick = (e) => {
          e.stopPropagation();
        };
        checkbox.onchange = (e) => {
          if (e.target.checked) {
            if (!selectedKnowledgePoints.includes(node.id)) {
              selectedKnowledgePoints.push(node.id);
              console.log('选中知识点:', node.name, node.id);
            }
          } else {
            selectedKnowledgePoints = selectedKnowledgePoints.filter(id => id !== node.id);
            console.log('取消选中知识点:', node.name, node.id);
          }
          updateSelectedCount();
        };

        const icon = document.createElement('i');
        if (node.children && node.children.length > 0) {
          icon.className = 'fas fa-folder text-warning-500 text-sm';
        } else {
          icon.className = 'fas fa-file-alt text-info-500 text-sm';
        }

        const label = document.createElement('span');
        label.className = 'text-sm text-gray-700 flex-1';
        label.textContent = node.name;

        const count = document.createElement('span');
        count.className = 'text-xs text-gray-400';
        if (node.questionCount !== undefined && node.questionCount > 0) {
          count.textContent = node.questionCount;
        }

        nodeContent.appendChild(checkbox);
        nodeContent.appendChild(icon);
        nodeContent.appendChild(label);
        nodeContent.appendChild(count);

        div.appendChild(nodeContent);

        // 添加子节点容器
        if (node.children && node.children.length > 0) {
          const childrenContainer = document.createElement('div');
          childrenContainer.className = 'children-container';
          node.children.forEach(child => {
            const childNode = renderNode(child, level + 1);
            childrenContainer.appendChild(childNode);
          });
          div.appendChild(childrenContainer);
        }

        return div;
      }

      knowledgePointsTree.forEach(node => {
        console.log('渲染节点:', node.name);
        const nodeElement = renderNode(node);
        container.appendChild(nodeElement);
      });

      console.log('知识点树渲染完成');
    }

    // 更新已选择数量
    function updateSelectedCount() {
      document.getElementById('selectedKnowledgeCount').textContent = selectedKnowledgePoints.length;
    }

    // 搜索过滤知识点
    function filterKnowledge() {
      const searchTerm = document.getElementById('knowledgeSearch').value.toLowerCase();
      const allNodes = document.querySelectorAll('.knowledge-node');

      allNodes.forEach(node => {
        const label = node.querySelector('span.text-gray-700');
        if (label) {
          const text = label.textContent.toLowerCase();
          if (text.includes(searchTerm) || searchTerm === '') {
            node.style.display = 'block';
          } else {
            node.style.display = 'none';
          }
        }
      });
    }

    // 确认知识点选择
    function confirmKnowledgeSelection() {
      if (selectedKnowledgePoints.length === 0) {
        alert('请至少选择一个知识点');
        return;
      }

      // 获取选择的知识点名称
      const selectedNames = selectedKnowledgePoints.map(id => knowledgePointsMap[id] || id);

      // 将选择的知识点插入到输入框中
      insertKnowledgePointsToTextarea(selectedNames);

      // 关闭弹窗
      closeKnowledgeModal();
    }

    // 将知识点插入到输入框
    function insertKnowledgePointsToTextarea(knowledgeNames) {
      console.log('=== 插入知识点开始 ===');
      console.log('知识点名称:', knowledgeNames);
      console.log('知识点选择模式:', knowledgeSelectionMode);
      console.log('当前题目索引:', currentQuestionIndex);

      const inputDiv = document.getElementById('inputText');
      let text = getInputText(); // 使用 getInputText 获取文本
      console.log('获取到的文本:', text);

      const lines = text.split('\n');
      let newLines = [];
      let questionIdx = -1;
      let inQuestion = false;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // 检测题型标识
        const typeMap = {
          '单选题': { type: 'single', typeName: '单选题' },
          '多选题': { type: 'multiple', typeName: '多选题' },
          '判断题': { type: 'judge', typeName: '判断题' },
          '填空题': { type: 'blank', typeName: '填空题' },
          '简答题': { type: 'essay', typeName: '简答题' },
          '完形填空': { type: 'cloze', typeName: '完形填空' },
          '复合题': { type: 'composite', typeName: '复合题' }
        };

        if (typeMap[line]) {
          inQuestion = true;
          newLines.push(lines[i]);
          continue;
        }

        // 检测题号
        if (/^\d+[.、:。]\s*/.test(line) && inQuestion) {
          questionIdx++;
        }

        // 检测答案行
        if ((line.startsWith('答案：') || line.startsWith('答：') || line.startsWith('正确答案：')) && inQuestion) {
          newLines.push(lines[i]);

          // 检查下一行是否是答案解析
          const nextLine = i + 1 < lines.length ? lines[i + 1].trim() : '';
          const isExplanation = nextLine.startsWith('答案解析：') || nextLine.startsWith('解析：');

          if (isExplanation) {
            // 如果下一行是答案解析，先添加答案解析行
            i++; // 移动到答案解析行
            newLines.push(lines[i]);

            // 然后在答案解析后插入知识点
            const nextNextLine = i + 1 < lines.length ? lines[i + 1].trim() : '';
            const hasKnowledgeLine = nextNextLine.startsWith('知识点：');

            // 判断是否需要为当前题目添加知识点
            const shouldAddKnowledge =
              (knowledgeSelectionMode === 'all') ||
              (knowledgeSelectionMode === 'single' && questionIdx === currentQuestionIndex);

            if (shouldAddKnowledge) {
              if (hasKnowledgeLine) {
                // 如果已有知识点行，读取已有的知识点
                i++; // 跳过原有的知识点行
                const existingKnowledgeText = lines[i].trim().replace(/^知识点：/, '');
                const existingKnowledges = existingKnowledgeText.split(/[、,，]/).map(k => k.trim()).filter(k => k);

                // 全局模式：合并知识点（去重）
                // 单个模式：替换知识点
                let finalKnowledges;
                if (knowledgeSelectionMode === 'all') {
                  // 合并并去重
                  finalKnowledges = [...new Set([...existingKnowledges, ...knowledgeNames])];
                } else {
                  // 替换
                  finalKnowledges = knowledgeNames;
                }

                newLines.push('知识点：' + finalKnowledges.join('、'));
              } else {
                // 如果没有知识点行，直接添加
                newLines.push('知识点：' + knowledgeNames.join('、'));
              }
            } else if (hasKnowledgeLine) {
              // 不需要添加知识点，但已有知识点行，保留原有的
              i++;
              newLines.push(lines[i]);
            }
          } else {
            // 如果下一行不是答案解析，在答案后直接插入知识点
            const hasKnowledgeLine = nextLine.startsWith('知识点：');

            // 判断是否需要为当前题目添加知识点
            const shouldAddKnowledge =
              (knowledgeSelectionMode === 'all') ||
              (knowledgeSelectionMode === 'single' && questionIdx === currentQuestionIndex);

            if (shouldAddKnowledge) {
              if (hasKnowledgeLine) {
                // 如果已有知识点行，读取已有的知识点
                i++; // 跳过原有的知识点行
                const existingKnowledgeText = lines[i].trim().replace(/^知识点：/, '');
                const existingKnowledges = existingKnowledgeText.split(/[、,，]/).map(k => k.trim()).filter(k => k);

                // 全局模式：合并知识点（去重）
                // 单个模式：替换知识点
                let finalKnowledges;
                if (knowledgeSelectionMode === 'all') {
                  // 合并并去重
                  finalKnowledges = [...new Set([...existingKnowledges, ...knowledgeNames])];
                } else {
                  // 替换
                  finalKnowledges = knowledgeNames;
                }

                newLines.push('知识点：' + finalKnowledges.join('、'));
              } else {
                // 如果没有知识点行，直接添加
                newLines.push('知识点：' + knowledgeNames.join('、'));
              }
            } else if (hasKnowledgeLine) {
              // 不需要添加知识点，但已有知识点行，保留原有的
              i++;
              newLines.push(lines[i]);
            }
          }
          continue;
        }

        // 其他行直接添加
        newLines.push(lines[i]);
      }

      // 更新内容，使用 setInputText
      const newText = newLines.join('\n');
      console.log('新文本:', newText);
      setInputText(newText);

      // 重新解析
      handleInputChange();
      console.log('=== 插入知识点完成 ===');
    }

    // 插入图片
    function insertImage() {
      const inputDiv = document.getElementById('inputText');

      // 保存当前光标位置
      const sel = window.getSelection();
      if (sel.rangeCount > 0 && inputDiv.contains(sel.anchorNode)) {
        savedRange = sel.getRangeAt(0).cloneRange();
        console.log('保存了光标位置（图片）');
      } else {
        savedRange = null;
        console.log('没有有效光标（图片），将使用默认位置');
      }

      const fileInput = document.getElementById('imageFileInput');
      fileInput.onchange = handleImageSelect;
      fileInput.click();
    }

    // 处理图片选择
    function handleImageSelect(event) {
      const file = event.target.files[0];
      if (!file) return;

      // 检查文件类型
      if (!file.type.startsWith('image/')) {
        alert('请选择图片文件');
        return;
      }

      // 检查文件大小（限制 5MB）
      if (file.size > 5 * 1024 * 1024) {
        alert('图片大小不能超过 5MB');
        return;
      }

      // 读取图片
      const reader = new FileReader();
      reader.onload = function(e) {
        const base64Data = e.target.result;

        // 获取图片尺寸
        const img = new Image();
        img.onload = function() {
          // 自动调整尺寸（最大宽度 400px）
          let width = img.width;
          let height = img.height;
          const maxWidth = 400;

          if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
          }

          // 插入图片标记到光标位置
          insertImageMarkdown(base64Data, width, height);
        };
        img.src = base64Data;
      };
      reader.readAsDataURL(file);

      // 清空 input 以便可以重复选择同一文件
      event.target.value = '';
    }

    // 插入图片标记
    function insertImageMarkdown(base64Data, width, height) {
      // 生成唯一的图片ID
      const imageId = 'img_' + (++imageIdCounter);

      // 存储图片数据到映射中
      imageDataMap[imageId] = {
        width: Math.round(width),
        height: Math.round(height),
        data: base64Data
      };

      // 使用 insertImageElement 插入图片元素
      insertImageElement(imageId);

      // 重新解析
      handleInputChange();
    }

    // 编辑内联图片大小（保留备用，确保全局可访问）
    window.editInlineImage = function(imageId) {
      const imageData = imageDataMap[imageId];
      if (!imageData) return;

      const currentWidth = imageData.width;
      const newWidth = prompt(`调整图片宽度（当前：${currentWidth}px，范围：50-800px）：`, currentWidth);

      if (newWidth === null) return; // 用户取消

      const width = parseInt(newWidth);
      if (isNaN(width) || width < 50 || width > 800) {
        alert('请输入有效的宽度（50-800px）');
        return;
      }

      // 保持宽高比
      const aspectRatio = imageData.height / imageData.width;
      const height = Math.round(width * aspectRatio);

      // 更新映射数据
      imageDataMap[imageId].width = width;
      imageDataMap[imageId].height = height;

      // 重新解析以更新显示
      handleInputChange();
    };

    // 内联图片拖拽调整大小相关变量
    let resizingInlineImage = null;
    let inlineResizeStartX = 0;
    let inlineResizeStartY = 0;
    let inlineResizeStartWidth = 0;
    let inlineResizeStartHeight = 0;
    let inlineResizeDirection = '';
    let inlineResizeImageId = '';

    // 开始拖拽调整内联图片大小（确保全局可访问）
    window.startInlineImageResize = function(event, imageId, direction) {
      event.preventDefault();
      event.stopPropagation();

      const imageData = imageDataMap[imageId];
      if (!imageData) {
        console.error('Image data not found for:', imageId);
        return;
      }

      console.log('开始调整图片大小:', imageId, direction);

      // 记录初始状态
      inlineResizeImageId = imageId;
      inlineResizeStartX = event.clientX;
      inlineResizeStartY = event.clientY;
      inlineResizeStartWidth = imageData.width;
      inlineResizeStartHeight = imageData.height;
      inlineResizeDirection = direction;

      // 找到图片容器 - 兼容两种类名
      const container = event.target.closest('.inline-image-wrapper') || event.target.closest('.inline-image-editable');
      if (container) {
        const img = container.querySelector('.inline-image');
        if (img) {
          img.style.boxShadow = '0 4px 12px rgba(0, 185, 107, 0.5)';
          img.style.borderColor = '#00B96B';
        }
        resizingInlineImage = container;
      }

      // 添加全局事件监听
      document.addEventListener('mousemove', handleInlineImageResize);
      document.addEventListener('mouseup', stopInlineImageResize);

      // 防止文本选择
      document.body.style.userSelect = 'none';
      document.body.style.cursor = event.target.style.cursor;
    };

    // 处理拖拽调整内联图片大小
    function handleInlineImageResize(event) {
      if (!inlineResizeImageId || !imageDataMap[inlineResizeImageId]) return;

      const deltaX = event.clientX - inlineResizeStartX;

      let newWidth = inlineResizeStartWidth;

      // 根据拖拽方向计算新尺寸
      switch (inlineResizeDirection) {
        case 'se': // 右下角
          newWidth = inlineResizeStartWidth + deltaX;
          break;
        case 'sw': // 左下角
          newWidth = inlineResizeStartWidth - deltaX;
          break;
        case 'ne': // 右上角
          newWidth = inlineResizeStartWidth + deltaX;
          break;
        case 'nw': // 左上角
          newWidth = inlineResizeStartWidth - deltaX;
          break;
      }

      // 限制最小和最大尺寸
      newWidth = Math.max(50, Math.min(800, newWidth));

      // 保持宽高比
      const aspectRatio = inlineResizeStartHeight / inlineResizeStartWidth;
      const newHeight = Math.round(newWidth * aspectRatio);

      // 更新映射中的数据
      imageDataMap[inlineResizeImageId].width = Math.round(newWidth);
      imageDataMap[inlineResizeImageId].height = newHeight;

      // 实时更新显示
      if (resizingInlineImage) {
        const img = resizingInlineImage.querySelector('.inline-image');
        if (img) {
          img.style.width = Math.round(newWidth) + 'px';
        }
      }
    }

    // 停止拖拽调整内联图片大小
    function stopInlineImageResize() {
      if (resizingInlineImage) {
        // 恢复图片样式
        const img = resizingInlineImage.querySelector('.inline-image');
        if (img) {
          img.style.boxShadow = '';
          img.style.borderColor = '#d1d5db';
        }
        resizingInlineImage = null;
      }

      // 移除全局事件监听
      document.removeEventListener('mousemove', handleInlineImageResize);
      document.removeEventListener('mouseup', stopInlineImageResize);

      // 恢复样式
      document.body.style.userSelect = '';
      document.body.style.cursor = '';

      // 清空状态
      const wasResizing = !!inlineResizeImageId;
      inlineResizeImageId = '';
      inlineResizeStartX = 0;
      inlineResizeStartY = 0;
      inlineResizeStartWidth = 0;
      inlineResizeStartHeight = 0;
      inlineResizeDirection = '';

      // 如果进行了调整，触发一次轻量级的重新渲染
      // 这样可以确保数据和显示保持同步
      if (wasResizing) {
        // 不完全重新解析，只更新显示
        displayQuestions();
      }
    }

    // 图片拖拽调整大小相关变量（保留用于未来扩展）
    let resizingImage = null;
    let resizeStartX = 0;
    let resizeStartY = 0;
    let resizeStartWidth = 0;
    let resizeStartHeight = 0;
    let resizeDirection = '';

    // 开始调整图片大小（暂时废弃，使用editInlineImage代替）
    function startResize(event, questionIndex, imageIndex, direction, initialWidth, initialHeight, imageId) {
      event.preventDefault();
      event.stopPropagation();

      // 记录初始状态
      resizingImage = { questionIndex, imageIndex, imageId };
      resizeStartX = event.clientX;
      resizeStartY = event.clientY;
      resizeStartWidth = initialWidth;
      resizeStartHeight = initialHeight;
      resizeDirection = direction;

      // 添加全局事件监听
      document.addEventListener('mousemove', handleResize);
      document.addEventListener('mouseup', stopResize);

      // 添加全局样式，防止文本选择
      document.body.style.userSelect = 'none';
      document.body.style.cursor = event.target.style.cursor;
    }

    // 处理拖拽调整大小
    function handleResize(event) {
      if (!resizingImage) return;

      const { questionIndex, imageIndex, imageId } = resizingImage;
      const deltaX = event.clientX - resizeStartX;

      let newWidth = resizeStartWidth;

      // 根据拖拽方向计算新尺寸
      switch (resizeDirection) {
        case 'se': // 右下角
          newWidth = resizeStartWidth + deltaX;
          break;
        case 'sw': // 左下角
          newWidth = resizeStartWidth - deltaX;
          break;
        case 'ne': // 右上角
          newWidth = resizeStartWidth + deltaX;
          break;
        case 'nw': // 左上角
          newWidth = resizeStartWidth - deltaX;
          break;
      }

      // 限制最小和最大尺寸
      newWidth = Math.max(100, Math.min(800, newWidth));

      // 保持宽高比
      const aspectRatio = resizeStartHeight / resizeStartWidth;
      const newHeight = newWidth * aspectRatio;

      // 更新映射中的数据
      if (imageDataMap[imageId]) {
        imageDataMap[imageId].width = Math.round(newWidth);
        imageDataMap[imageId].height = Math.round(newHeight);
      }

      // 实时更新显示
      const imgContainer = document.querySelector(`[data-question-index="${questionIndex}"][data-image-index="${imageIndex}"]`);
      if (imgContainer) {
        imgContainer.style.width = Math.round(newWidth) + 'px';
        const sizeLabel = imgContainer.querySelector('.px-2.py-1');
        if (sizeLabel) {
          sizeLabel.textContent = Math.round(newWidth) + 'px';
        }
      }

      // 重新解析以更新数据结构
      handleInputChange();
    }

    // 停止调整大小
    function stopResize() {
      if (resizingImage) {
        // 移除全局事件监听
        document.removeEventListener('mousemove', handleResize);
        document.removeEventListener('mouseup', stopResize);

        // 恢复样式
        document.body.style.userSelect = '';
        document.body.style.cursor = '';

        resizingImage = null;
      }
    }

    // 删除图片（通过ID，确保全局可访问）
    window.removeImageById = function(imageId) {
      if (!confirm('确定要删除这张图片吗？')) return;

      console.log('========== 删除图片 ==========');
      console.log('删除图片ID:', imageId);

      // 1. 从图片数据映射中删除
      if (imageDataMap[imageId]) {
        delete imageDataMap[imageId];
        console.log('✓ 已从 imageDataMap 删除');
      }

      // 2. 从左侧输入框文本中删除图片标记 [图片:img_x]
      const imageMarker = `[图片:${imageId}]`;
      let text = getInputText();
      console.log('删除前文本长度:', text.length);

      if (text.includes(imageMarker)) {
        text = text.replace(new RegExp(`\\[图片:${imageId}\\]`, 'g'), '');
        console.log('✓ 已从文本中删除图片标记');
        console.log('删除后文本长度:', text.length);

        // 更新左侧输入框
        setInputText(text);
        console.log('✓ 已更新左侧输入框');
      } else {
        console.log('警告：文本中未找到图片标记');
      }

      // 3. 重新解析并更新显示
      handleInputChange();
      console.log('✓ 已重新解析');
      console.log('========== 删除完成 ==========\n');
    };

    // 删除图片（旧版本，保留兼容）
    function removeImage(questionIndex, imageIndex, imageId) {
      removeImageById(imageId);
    }

    // 插入公式 - 打开可视化编辑器
    function insertFormula() {
      const inputDiv = document.getElementById('inputText');
      const modal = document.getElementById('formulaEditorModal');
      const elementsContainer = document.getElementById('formulaElements');
      const preview = document.getElementById('formulaPreview');

      // 保存当前光标位置
      const sel = window.getSelection();
      if (sel.rangeCount > 0 && inputDiv.contains(sel.anchorNode)) {
        savedRange = sel.getRangeAt(0).cloneRange();
        console.log('保存了光标位置');
      } else {
        // 如果没有有效光标，设置一个默认位置
        savedRange = null;
        console.log('没有有效光标，将使用默认位置');
      }

      // 清空编辑器状态
      formulaElements = [];
      elementsContainer.innerHTML = '';
      preview.innerHTML = '<span class="text-gray-400 text-sm">公式预览将显示在这里</span>';

      // 显示弹窗
      modal.classList.remove('hidden');
    }

    // 插入公式组件
    function insertFormulaComponent(type) {
      const elementsContainer = document.getElementById('formulaElements');

      switch(type) {
        case 'fraction':
          // 分数：创建两个输入框
          const fractionEl = document.createElement('div');
          fractionEl.className = 'inline-flex flex-col items-center border border-primary-300 rounded px-2 py-1 bg-primary-50';
          fractionEl.innerHTML = `
            <input type="text" placeholder="分子" class="w-16 px-1 py-0.5 text-center border-b border-gray-300 text-sm focus:outline-none focus:border-primary-500" />
            <div class="w-full h-px bg-gray-400 my-0.5"></div>
            <input type="text" placeholder="分母" class="w-16 px-1 py-0.5 text-center text-sm focus:outline-none focus:border-primary-500" />
          `;
          elementsContainer.appendChild(fractionEl);
          formulaElements.push({type: 'fraction', element: fractionEl});
          // 自动聚焦到第一个输入框
          fractionEl.querySelector('input').focus();
          break;

        case 'superscript':
          // 上标
          const superEl = document.createElement('div');
          superEl.className = 'inline-flex items-start border border-primary-300 rounded px-2 py-1 bg-primary-50';
          superEl.innerHTML = `
            <input type="text" placeholder="底数" class="w-12 px-1 py-0.5 text-center text-sm focus:outline-none focus:border-primary-500" />
            <input type="text" placeholder="指数" class="w-8 px-1 text-center text-xs focus:outline-none focus:border-primary-500" style="vertical-align: super; font-size: 0.7em;" />
          `;
          elementsContainer.appendChild(superEl);
          formulaElements.push({type: 'superscript', element: superEl});
          superEl.querySelector('input').focus();
          break;

        case 'subscript':
          // 下标
          const subEl = document.createElement('div');
          subEl.className = 'inline-flex items-end border border-primary-300 rounded px-2 py-1 bg-primary-50';
          subEl.innerHTML = `
            <input type="text" placeholder="主体" class="w-12 px-1 py-0.5 text-center text-sm focus:outline-none focus:border-primary-500" />
            <input type="text" placeholder="下标" class="w-8 px-1 text-center text-xs focus:outline-none focus:border-primary-500" style="vertical-align: sub; font-size: 0.7em;" />
          `;
          elementsContainer.appendChild(subEl);
          formulaElements.push({type: 'subscript', element: subEl});
          subEl.querySelector('input').focus();
          break;

        case 'sqrt':
          // 根号
          const sqrtEl = document.createElement('div');
          sqrtEl.className = 'inline-flex items-center border border-primary-300 rounded px-2 py-1 bg-primary-50';
          sqrtEl.innerHTML = `
            <span class="text-lg mr-1">√</span>
            <input type="text" placeholder="内容" class="w-16 px-1 py-0.5 text-center text-sm focus:outline-none focus:border-primary-500" style="border-top: 1px solid #666;" />
          `;
          elementsContainer.appendChild(sqrtEl);
          formulaElements.push({type: 'sqrt', element: sqrtEl});
          sqrtEl.querySelector('input').focus();
          break;

        case 'sum':
          // 求和
          const sumEl = document.createElement('div');
          sumEl.className = 'inline-flex flex-col items-center border border-primary-300 rounded px-2 py-1 bg-primary-50';
          sumEl.innerHTML = `
            <input type="text" placeholder="上限" class="w-12 px-1 text-center text-xs mb-0.5 focus:outline-none focus:border-primary-500" />
            <span class="text-2xl">Σ</span>
            <input type="text" placeholder="下限" class="w-12 px-1 text-center text-xs mt-0.5 focus:outline-none focus:border-primary-500" />
          `;
          elementsContainer.appendChild(sumEl);
          formulaElements.push({type: 'sum', element: sumEl});
          sumEl.querySelector('input').focus();
          break;

        case 'integral':
          // 积分
          const integralEl = document.createElement('div');
          integralEl.className = 'inline-flex flex-col items-center border border-primary-300 rounded px-2 py-1 bg-primary-50';
          integralEl.innerHTML = `
            <input type="text" placeholder="上限" class="w-12 px-1 text-center text-xs mb-0.5 focus:outline-none focus:border-primary-500" />
            <span class="text-2xl">∫</span>
            <input type="text" placeholder="下限" class="w-12 px-1 text-center text-xs mt-0.5 focus:outline-none focus:border-primary-500" />
          `;
          elementsContainer.appendChild(integralEl);
          formulaElements.push({type: 'integral', element: integralEl});
          integralEl.querySelector('input').focus();
          break;

        case 'parentheses':
          // 括号
          const parenEl = document.createElement('div');
          parenEl.className = 'inline-flex items-center border border-primary-300 rounded px-1 py-1 bg-primary-50';
          parenEl.innerHTML = `
            <span class="text-lg">(</span>
            <input type="text" placeholder="内容" class="w-20 px-1 py-0.5 text-center text-sm focus:outline-none focus:border-primary-500" />
            <span class="text-lg">)</span>
          `;
          elementsContainer.appendChild(parenEl);
          formulaElements.push({type: 'parentheses', element: parenEl});
          parenEl.querySelector('input').focus();
          break;

        case 'limit':
          // 极限
          const limitEl = document.createElement('div');
          limitEl.className = 'inline-flex items-center gap-1 border border-primary-300 rounded px-2 py-1 bg-primary-50';
          limitEl.innerHTML = `
            <span class="text-sm">lim</span>
            <div class="flex flex-col text-xs">
              <input type="text" placeholder="x→" class="w-16 px-1 text-center focus:outline-none focus:border-primary-500" />
            </div>
          `;
          elementsContainer.appendChild(limitEl);
          formulaElements.push({type: 'limit', element: limitEl});
          limitEl.querySelector('input').focus();
          break;

        case 'matrix':
          // 矩阵
          const matrixEl = document.createElement('div');
          matrixEl.className = 'inline-flex items-center border border-primary-300 rounded px-1 py-1 bg-primary-50';
          matrixEl.innerHTML = `
            <span class="text-lg">[</span>
            <input type="text" placeholder="内容" class="w-20 px-1 py-0.5 text-center text-sm focus:outline-none focus:border-primary-500" />
            <span class="text-lg">]</span>
          `;
          elementsContainer.appendChild(matrixEl);
          formulaElements.push({type: 'matrix', element: matrixEl});
          matrixEl.querySelector('input').focus();
          break;
      }

      // 添加监听器以更新预览
      elementsContainer.querySelectorAll('input').forEach(input => {
        input.addEventListener('input', updateVisualFormulaPreview);
      });

      // 更新预览
      updateVisualFormulaPreview();
    }

    // 插入希腊字母
    function insertGreekLetter(letter) {
      const elementsContainer = document.getElementById('formulaElements');
      const letterMap = {
        'alpha': 'α', 'beta': 'β', 'gamma': 'γ',
        'delta': 'δ', 'pi': 'π', 'theta': 'θ',
        'lambda': 'λ', 'mu': 'μ'
      };

      const span = document.createElement('span');
      span.className = 'inline-block px-2 py-1 border border-gray-300 rounded bg-gray-50 text-lg';
      span.textContent = letterMap[letter] || letter;
      elementsContainer.appendChild(span);

      formulaElements.push({type: 'letter', element: span, value: letter});
      updateVisualFormulaPreview();
    }

    // 插入常用符号
    function insertSymbol(symbol) {
      const elementsContainer = document.getElementById('formulaElements');
      const symbolMap = {
        'infty': '∞',
        'pm': '±',
        'times': '×',
        'div': '÷',
        'leq': '≤',
        'geq': '≥',
        'neq': '≠',
        'approx': '≈'
      };

      const span = document.createElement('span');
      span.className = 'inline-block px-2 py-1 border border-gray-300 rounded bg-gray-50 text-lg';
      span.textContent = symbolMap[symbol] || symbol;
      elementsContainer.appendChild(span);

      formulaElements.push({type: 'symbol', element: span, value: symbol});
      updateVisualFormulaPreview();
    }

    // 辅助函数：插入纯文本
    function insertText(text) {
      const elementsContainer = document.getElementById('formulaElements');
      const span = document.createElement('span');
      span.className = 'inline-block px-1 py-1 text-lg';
      span.textContent = text;
      elementsContainer.appendChild(span);
      formulaElements.push({type: 'text', element: span, text: text});
    }

    // 插入公式模板
    function insertFormulaTemplate(template) {
      const elementsContainer = document.getElementById('formulaElements');

      // 先清空编辑器
      clearFormulaEditor();

      switch(template) {
        case 'pythagorean':
          // 勾股定理: a² + b² = c²
          insertText('a');
          insertFormulaComponent('superscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 2) {
              inputs[inputs.length - 1].value = '2';
            }
          }, 10);
          insertText(' + b');
          insertFormulaComponent('superscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 4) {
              inputs[inputs.length - 1].value = '2';
            }
          }, 20);
          insertText(' = c');
          insertFormulaComponent('superscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 6) {
              inputs[inputs.length - 1].value = '2';
            }
          }, 30);
          break;

        case 'binomial':
          // 二项式定理: (a+b)ⁿ
          insertText('(a+b)');
          insertFormulaComponent('superscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 2) {
              inputs[inputs.length - 1].value = 'n';
            }
          }, 10);
          break;

        case 'quadratic':
          // 一元二次方程: ax² + bx + c = 0
          insertText('ax');
          insertFormulaComponent('superscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 2) {
              inputs[inputs.length - 1].value = '2';
            }
          }, 10);
          insertText(' + bx + c = 0');
          break;

        case 'quadratic_formula':
          // 求根公式: x = (-b ± √(b²-4ac)) / 2a
          insertText('x = ');
          insertFormulaComponent('fraction');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 2) {
              inputs[inputs.length - 2].value = '-b ± √(b²-4ac)';
              inputs[inputs.length - 1].value = '2a';
            }
          }, 10);
          break;

        case 'arithmetic':
          // 等差数列: aₙ = a₁ + (n-1)d
          insertText('a');
          insertFormulaComponent('subscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 2) {
              inputs[inputs.length - 1].value = 'n';
            }
          }, 10);
          insertText(' = a');
          insertFormulaComponent('subscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 4) {
              inputs[inputs.length - 1].value = '1';
            }
          }, 20);
          insertText(' + (n-1)d');
          break;

        case 'geometric':
          // 等比数列: aₙ = a₁ · qⁿ⁻¹
          insertText('a');
          insertFormulaComponent('subscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 2) {
              inputs[inputs.length - 1].value = 'n';
            }
          }, 10);
          insertText(' = a');
          insertFormulaComponent('subscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 4) {
              inputs[inputs.length - 1].value = '1';
            }
          }, 20);
          insertText(' · q');
          insertFormulaComponent('superscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 6) {
              inputs[inputs.length - 1].value = 'n-1';
            }
          }, 30);
          break;

        case 'derivative':
          // 导数定义: f'(x) = lim(Δx→0) [f(x+Δx)-f(x)]/Δx
          insertText("f'(x) = ");
          insertFormulaComponent('limit');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 1) {
              inputs[inputs.length - 1].value = 'Δx→0';
            }
          }, 10);
          insertFormulaComponent('fraction');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 3) {
              inputs[inputs.length - 2].value = 'f(x+Δx)-f(x)';
              inputs[inputs.length - 1].value = 'Δx';
            }
          }, 20);
          break;

        case 'circle_area':
          // 圆的面积: S = πr²
          insertText('S = πr');
          insertFormulaComponent('superscript');
          setTimeout(() => {
            const inputs = elementsContainer.querySelectorAll('input');
            if (inputs.length >= 2) {
              inputs[inputs.length - 1].value = '2';
            }
          }, 10);
          break;
      }

      // 延迟更新预览
      setTimeout(() => {
        updateVisualFormulaPreview();
      }, 50);
    }

    // 更新可视化公式预览
    function updateVisualFormulaPreview() {
      const preview = document.getElementById('formulaPreview');
      const latex = generateLatexFromElements();

      if (!latex || latex.trim() === '') {
        preview.innerHTML = '<span class="text-gray-400 text-sm">公式预览将显示在这里</span>';
        return;
      }

      try {
        preview.innerHTML = '';
        katex.render(latex, preview, {
          throwOnError: false,
          displayMode: true,
          errorColor: '#F53F3F'
        });
      } catch (e) {
        preview.innerHTML = '<span class="text-error-500 text-sm">公式格式错误</span>';
      }
    }

    // 从可视化元素生成LaTeX
    function generateLatexFromElements() {
      let latex = '';

      formulaElements.forEach(el => {
        const inputs = el.element.querySelectorAll('input');

        switch(el.type) {
          case 'fraction':
            const numerator = inputs[0]?.value || 'a';
            const denominator = inputs[1]?.value || 'b';
            latex += `\\frac{${numerator}}{${denominator}}`;
            break;

          case 'superscript':
            const base = inputs[0]?.value || 'x';
            const exp = inputs[1]?.value || 'n';
            latex += `${base}^{${exp}}`;
            break;

          case 'subscript':
            const main = inputs[0]?.value || 'x';
            const sub = inputs[1]?.value || 'n';
            latex += `${main}_{${sub}}`;
            break;

          case 'sqrt':
            const content = inputs[0]?.value || 'x';
            latex += `\\sqrt{${content}}`;
            break;

          case 'sum':
            const sumUpper = inputs[0]?.value || 'n';
            const sumLower = inputs[1]?.value || 'i=1';
            latex += `\\sum_{${sumLower}}^{${sumUpper}}`;
            break;

          case 'integral':
            const intUpper = inputs[0]?.value || 'b';
            const intLower = inputs[1]?.value || 'a';
            latex += `\\int_{${intLower}}^{${intUpper}}`;
            break;

          case 'parentheses':
            const parenContent = inputs[0]?.value || '';
            latex += `(${parenContent})`;
            break;

          case 'letter':
            const letterMap = {
              'alpha': '\\alpha', 'beta': '\\beta', 'gamma': '\\gamma',
              'delta': '\\delta', 'pi': '\\pi', 'theta': '\\theta'
            };
            latex += letterMap[el.value] || el.value;
            break;
        }
      });

      return latex;
    }

    // 清空公式编辑器
    function clearFormulaEditor() {
      formulaElements = [];
      document.getElementById('formulaElements').innerHTML = '';
      document.getElementById('formulaPreview').innerHTML = '<span class="text-gray-400 text-sm">公式预览将显示在这里</span>';
    }

    // 撤销最后一个元素
    function undoLastElement() {
      if (formulaElements.length > 0) {
        formulaElements.pop();
        const container = document.getElementById('formulaElements');
        if (container.lastChild) {
          container.removeChild(container.lastChild);
        }
        updateVisualFormulaPreview();
      }
    }

    // 更新公式预览（保留旧函数兼容）
    function updateFormulaPreview() {
      updateVisualFormulaPreview();
    }

    // 关闭公式编辑器
    function closeFormulaEditor() {
      const modal = document.getElementById('formulaEditorModal');
      modal.classList.add('hidden');
    }

    // 确认插入公式
    function confirmFormulaInsert() {
      // 从可视化编辑器生成 LaTeX
      const latex = generateLatexFromElements();

      if (!latex || latex.trim() === '') {
        alert('请先添加公式元素');
        return;
      }

      // 生成公式ID
      formulaIdCounter++;
      const formulaId = `formula_${formulaIdCounter}`;

      // 存储公式数据
      formulaDataMap[formulaId] = { latex: latex };

      // 清空可视化编辑器
      clearFormulaEditor();

      // 关闭弹窗
      closeFormulaEditor();

      // 插入公式元素（该函数内部会处理焦点）
      insertFormulaElement(formulaId);

      // 触发解析更新
      handleInputChange();
    }

    // 删除公式（从文本中删除标记并清理数据）
    window.removeFormulaById = function(formulaId) {
      // 从映射中删除数据
      delete formulaDataMap[formulaId];

      // 从 contentEditable 删除公式元素
      const inputDiv = document.getElementById('inputText');
      const formulaElements = inputDiv.querySelectorAll(`[data-formula-id="${formulaId}"]`);
      formulaElements.forEach(el => el.remove());

      // 触发重新解析
      handleInputChange();
    };

    // ==================== 内联图片拖拽移动相关函数 ====================

    let draggedInlineImageElement = null;
    let draggedInlineImageId = null;

    // 内联图片拖拽开始
    // ==================== 左侧输入框图片拖拽功能已废弃 ====================
    // 左侧输入框现在只显示图片占位符，不再支持拖拽功能
    // 所有图片的拖拽和调整大小功能都在右侧识别框中进行

    // function handleInlineImageDragStart(event, imageId) {
    //   console.log('开始拖拽图片:', imageId);
    //   draggedInlineImageElement = event.target;
    //   draggedInlineImageId = imageId;
    //   event.dataTransfer.effectAllowed = 'move';
    //   event.dataTransfer.setData('text/html', event.target.outerHTML);
    //   setTimeout(() => {
    //     if (draggedInlineImageElement) {
    //       draggedInlineImageElement.style.opacity = '0.5';
    //     }
    //   }, 0);
    // }

    // function handleInlineImageDragEnd(event) {
    //   console.log('拖拽结束');
    //   if (event.target) {
    //     event.target.style.opacity = '1';
    //   }
    //   draggedInlineImageElement = null;
    //   draggedInlineImageId = null;
    // }

    // function handleInputDivDragOver(event) {
    //   if (!draggedInlineImageId) return;
    //   event.preventDefault();
    //   event.dataTransfer.dropEffect = 'move';
    // }

    // function handleInputDivDrop(event) {
    //   if (!draggedInlineImageId || !draggedInlineImageElement) {
    //     return;
    //   }
    //   event.preventDefault();
    //   event.stopPropagation();
    //   // ... 省略具体实现
    // }

    // function initInputDivDragListeners() {
    //   const inputDiv = document.getElementById('inputText');
    //   if (inputDiv) {
    //     inputDiv.addEventListener('dragover', handleInputDivDragOver);
    //     inputDiv.addEventListener('drop', handleInputDivDrop);
    //     console.log('inputDiv 拖拽监听已初始化');
    //   }
    // }

    // ==================== 图片拖拽相关函数（旧系统，已废弃）====================

    // 图片拖拽开始
    function handleImageDragStart(event, imageId) {
      draggedImageId = imageId;
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setData('text/html', event.target.outerHTML);

      // 添加拖拽时的视觉反馈
      event.target.style.opacity = '0.5';

      // 查找图片在哪个字段中
      const dropTargets = document.querySelectorAll('[data-drop-target]');
      dropTargets.forEach(target => {
        const targetElement = target.querySelector(`[data-image-id="${imageId}"]`);
        if (targetElement) {
          draggedSourceField = {
            questionIndex: parseInt(target.getAttribute('data-question-index')),
            fieldType: target.getAttribute('data-drop-target'),
            optionIndex: target.getAttribute('data-option-index') ? parseInt(target.getAttribute('data-option-index')) : null
          };
        }
      });
    }

    // 图片拖拽结束
    function handleImageDragEnd(event) {
      event.target.style.opacity = '1';

      // 隐藏光标指示器
      if (dropCursorElement) {
        dropCursorElement.style.display = 'none';
      }

      // 清除所有拖拽状态
      draggedImageId = null;
      draggedSourceField = null;
      dropTargetInfo = null;
    }

    // 拖拽经过目标区域 - 显示精确光标位置
    function handleDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'move';

      if (!draggedImageId) return;

      const target = event.currentTarget;

      // 创建或获取光标指示器
      if (!dropCursorElement) {
        dropCursorElement = document.createElement('div');
        dropCursorElement.className = 'drop-cursor';
        document.body.appendChild(dropCursorElement);
      }

      // 获取鼠标位置对应的文本位置
      const range = getCaretRangeFromPoint(event.clientX, event.clientY);

      if (range) {
        const rect = range.getBoundingClientRect();

        // 显示光标指示器 (使用 fixed 定位，不需要 scrollY)
        dropCursorElement.style.display = 'block';
        dropCursorElement.style.left = rect.left + 'px';
        dropCursorElement.style.top = rect.top + 'px';

        // 保存目标信息
        dropTargetInfo = {
          element: target,
          range: range,
          questionIndex: parseInt(target.getAttribute('data-question-index')),
          fieldType: target.getAttribute('data-drop-target'),
          optionIndex: target.getAttribute('data-option-index') ? parseInt(target.getAttribute('data-option-index')) : null
        };
      }

      // 添加视觉反馈
      if (target.hasAttribute('data-drop-target')) {
        target.style.background = '#f0f9ff';
      }
    }

    // 获取鼠标位置对应的文本Range
    function getCaretRangeFromPoint(x, y) {
      if (document.caretRangeFromPoint) {
        return document.caretRangeFromPoint(x, y);
      } else if (document.caretPositionFromPoint) {
        const position = document.caretPositionFromPoint(x, y);
        if (position) {
          const range = document.createRange();
          range.setStart(position.offsetNode, position.offset);
          range.setEnd(position.offsetNode, position.offset);
          return range;
        }
      }
      return null;
    }

    // 拖拽离开目标区域
    function handleDragLeave(event) {
      const target = event.currentTarget;
      if (target.hasAttribute('data-drop-target')) {
        target.style.background = '';
      }

      // 隐藏光标指示器
      if (dropCursorElement) {
        dropCursorElement.style.display = 'none';
      }
    }

    // 辅助函数：计算光标在整个 contentEditable 元素中的绝对位置
    // 这个函数需要处理右侧显示区域（包含 img 元素）和左侧输入区域（包含公式元素）
    function getAbsoluteCaretOffset(range, containerElement) {
      if (!range || !containerElement) return -1;

      const startContainer = range.startContainer;
      const startOffset = range.startOffset;

      // 如果光标不在容器内，返回-1
      if (!containerElement.contains(startContainer)) {
        console.log('光标不在容器内');
        return -1;
      }

      // 遍历容器的所有节点，计算绝对偏移量
      let absoluteOffset = 0;
      let found = false;

      function traverseNodes(node) {
        if (found) return;

        if (node.nodeType === Node.TEXT_NODE) {
          // 如果是目标节点，加上偏移量后结束
          if (node === startContainer) {
            absoluteOffset += startOffset;
            found = true;
            console.log('找到目标文本节点，当前累计偏移量:', absoluteOffset);
            return;
          }
          // 否则，累加整个文本节点的长度
          const textLength = node.textContent.length;
          absoluteOffset += textLength;
          console.log(`文本节点: "${node.textContent.substring(0, 20)}...", 长度: ${textLength}, 累计: ${absoluteOffset}`);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          // 处理图片元素（右侧显示区域）
          if (node.tagName === 'IMG' && node.hasAttribute('data-image-id')) {
            const imageId = node.getAttribute('data-image-id');
            const markerLength = `[图片:${imageId}]`.length;
            absoluteOffset += markerLength;
            console.log(`图片元素: ${imageId}, 标记长度: ${markerLength}, 累计: ${absoluteOffset}`);

            // 如果光标在图片元素之后（startContainer 是父节点，startOffset 指向图片后的位置）
            if (startContainer === node.parentNode) {
              let imageIndex = Array.from(node.parentNode.childNodes).indexOf(node);
              if (startOffset === imageIndex + 1) {
                found = true;
                console.log('找到光标位置（图片之后），累计偏移量:', absoluteOffset);
                return;
              }
            }
            return; // 不递归进入 img 元素
          }

          // 处理公式元素（左侧输入区域）
          if (node.classList && node.classList.contains('inline-formula-editable')) {
            const formulaId = node.getAttribute('data-formula-id');
            const markerLength = `[公式:${formulaId}]`.length;
            absoluteOffset += markerLength;
            console.log(`公式元素: ${formulaId}, 标记长度: ${markerLength}, 累计: ${absoluteOffset}`);
            return; // 不递归进入公式元素
          }

          // 处理换行
          if (node.tagName === 'BR') {
            absoluteOffset += 1; // 换行符
            console.log('换行符, 累计:', absoluteOffset);
            return;
          }

          // 检查光标是否在当前元素的子节点之间
          if (startContainer === node && node.childNodes.length > 0) {
            // 遍历到 startOffset 位置的子节点
            for (let i = 0; i < Math.min(startOffset, node.childNodes.length); i++) {
              traverseNodes(node.childNodes[i]);
              if (found) return;
            }
            // 如果遍历完了还没找到，说明光标就在 startOffset 位置
            if (!found && startOffset <= node.childNodes.length) {
              found = true;
              console.log('找到光标位置（元素子节点之间），累计偏移量:', absoluteOffset);
              return;
            }
          } else {
            // 递归处理子节点
            for (let i = 0; i < node.childNodes.length; i++) {
              traverseNodes(node.childNodes[i]);
              if (found) return;
            }
          }
        }
      }

      console.log('开始遍历节点，容器:', containerElement.tagName, containerElement.className);
      traverseNodes(containerElement);

      console.log(`遍历完成，found: ${found}, absoluteOffset: ${absoluteOffset}`);
      return found ? absoluteOffset : -1;
    }

    // 图片放置到目标区域 - 改进方案：直接修改 parsedData，避免重新解析
    function handleImageDrop(event, questionIndex, fieldType, optionIndex) {
      event.preventDefault();
      event.stopPropagation();

      // 清除视觉反馈
      const target = event.currentTarget;
      if (target) {
        target.style.background = '';
      }

      // 隐藏光标指示器
      if (dropCursorElement) {
        dropCursorElement.style.display = 'none';
      }

      if (!draggedImageId || !draggedSourceField) {
        console.log('拖拽取消：没有有效的拖拽源');
        draggedImageId = null;
        draggedSourceField = null;
        dropTargetInfo = null;
        return;
      }

      console.log('========== 图片拖拽开始 ==========');
      console.log('拖拽的图片ID:', draggedImageId);
      console.log('源位置:', draggedSourceField);
      console.log('目标位置:', { questionIndex, fieldType, optionIndex });
      console.log('当前 parsedData 长度:', parsedData ? parsedData.length : 'undefined');

      // 如果拖到同一个位置，不处理
      if (draggedSourceField.questionIndex === questionIndex &&
          draggedSourceField.fieldType === fieldType &&
          draggedSourceField.optionIndex === optionIndex) {
        console.log('拖拽取消：拖到同一位置');
        draggedImageId = null;
        draggedSourceField = null;
        dropTargetInfo = null;
        return;
      }

      const imageMarker = `[图片:${draggedImageId}]`;

      try {
        // 验证 parsedData
        if (!parsedData || !Array.isArray(parsedData) || parsedData.length === 0) {
          throw new Error('parsedData 为空或无效');
        }

        console.log('开始修改 parsedData...');

        // 1. 从源位置删除图片标记
        const sourceQuestion = parsedData[draggedSourceField.questionIndex];
        if (!sourceQuestion) {
          throw new Error(`源题目不存在 (索引: ${draggedSourceField.questionIndex})`);
        }

        console.log('源题目:', sourceQuestion);

        let removed = false;
        if (draggedSourceField.fieldType === 'content') {
          if (sourceQuestion.content && sourceQuestion.content.includes(imageMarker)) {
            sourceQuestion.content = sourceQuestion.content.replace(imageMarker, '');
            removed = true;
            console.log('✓ 从题干删除图片');
          }
        } else if (draggedSourceField.fieldType === 'option' && draggedSourceField.optionIndex !== null) {
          const opt = sourceQuestion.options ? sourceQuestion.options[draggedSourceField.optionIndex] : null;
          if (opt && opt.text && opt.text.includes(imageMarker)) {
            opt.text = opt.text.replace(imageMarker, '');
            removed = true;
            console.log('✓ 从选项删除图片');
          }
        } else if (draggedSourceField.fieldType === 'explanation') {
          if (sourceQuestion.explanation && sourceQuestion.explanation.includes(imageMarker)) {
            sourceQuestion.explanation = sourceQuestion.explanation.replace(imageMarker, '');
            removed = true;
            console.log('✓ 从解析删除图片');
          }
        }

        if (!removed) {
          throw new Error('未找到源图片标记');
        }

        // 2. 在目标位置添加图片标记（支持精确位置插入）
        const targetQuestion = parsedData[questionIndex];
        if (!targetQuestion) {
          throw new Error(`目标题目不存在 (索引: ${questionIndex})`);
        }

        console.log('目标题目:', targetQuestion);

        // 尝试获取精确插入位置（使用绝对偏移量计算）
        let insertOffset = -1; // -1 表示插入到末尾
        if (dropTargetInfo && dropTargetInfo.range && target) {
          try {
            const range = dropTargetInfo.range;

            // 找到实际包含内容的元素
            // target 是 data-drop-target 的容器，需要找到里面的 <p> 或其他内容元素
            let containerElement = null;

            // 首先，尝试从 range 的 startContainer 向上查找，直到找到 target 的直接子元素
            let rangeContainer = range.startContainer;
            if (rangeContainer.nodeType === Node.TEXT_NODE) {
              rangeContainer = rangeContainer.parentNode;
            }

            // 向上遍历，找到 target 的子元素
            while (rangeContainer && rangeContainer !== target && rangeContainer.parentNode) {
              if (rangeContainer.parentNode === target) {
                containerElement = rangeContainer;
                break;
              }
              rangeContainer = rangeContainer.parentNode;
            }

            // 如果没找到，尝试直接查找 target 的第一个 <p> 或 contentEditable 元素
            if (!containerElement) {
              containerElement = target.querySelector('p') || target.querySelector('[contenteditable="true"]') || target;
            }

            if (containerElement) {
              console.log('找到内容容器元素:', containerElement.tagName, containerElement.className);

              // 使用新的辅助函数计算绝对偏移量
              insertOffset = getAbsoluteCaretOffset(range, containerElement);
              console.log('检测到精确插入位置，绝对偏移量:', insertOffset);

              // 调试：获取目标字段的当前内容
              let currentContent = '';
              if (fieldType === 'content') {
                currentContent = targetQuestion.content || '';
              } else if (fieldType === 'option' && optionIndex !== null) {
                const opt = targetQuestion.options ? targetQuestion.options[optionIndex] : null;
                currentContent = opt ? (opt.text || '') : '';
              } else if (fieldType === 'explanation') {
                currentContent = targetQuestion.explanation || '';
              }
              console.log('当前字段内容:', currentContent);
              console.log('当前字段内容长度:', currentContent.length);
            } else {
              console.log('未找到内容容器元素');
            }
          } catch (e) {
            console.log('无法获取精确位置，将插入到末尾:', e.message);
            console.error(e);
          }
        }

        // 根据字段类型插入图片标记
        if (fieldType === 'content') {
          if (insertOffset >= 0) {
            // 精确位置插入
            const content = targetQuestion.content || '';
            targetQuestion.content = content.substring(0, insertOffset) + imageMarker + content.substring(insertOffset);
            console.log('✓ 精确位置插入到题干');
          } else {
            // 末尾插入
            targetQuestion.content = (targetQuestion.content || '') + imageMarker;
            console.log('✓ 末尾插入到题干');
          }
        } else if (fieldType === 'option' && optionIndex !== null) {
          if (!targetQuestion.options || !Array.isArray(targetQuestion.options)) {
            throw new Error('目标题目没有选项');
          }
          const opt = targetQuestion.options[optionIndex];
          if (opt) {
            if (insertOffset >= 0) {
              // 精确位置插入
              const text = opt.text || '';
              opt.text = text.substring(0, insertOffset) + imageMarker + text.substring(insertOffset);
              console.log('✓ 精确位置插入到选项');
            } else {
              // 末尾插入
              opt.text = (opt.text || '') + imageMarker;
              console.log('✓ 末尾插入到选项');
            }
          } else {
            throw new Error(`目标选项不存在 (索引: ${optionIndex})`);
          }
        } else if (fieldType === 'explanation') {
          if (insertOffset >= 0) {
            // 精确位置插入
            const explanation = targetQuestion.explanation || '';
            targetQuestion.explanation = explanation.substring(0, insertOffset) + imageMarker + explanation.substring(insertOffset);
            console.log('✓ 精确位置插入到解析');
          } else {
            // 末尾插入
            targetQuestion.explanation = (targetQuestion.explanation || '') + imageMarker;
            console.log('✓ 末尾插入到解析');
          }
        }

        console.log('✓ parsedData 修改完成');

        // 3. 同步更新左侧文本（从 parsedData 重建文本）
        console.log('开始同步左侧文本...');
        const newText = rebuildTextFromParsedData();
        console.log('重建的文本长度:', newText.length);

        if (!newText || newText.length === 0) {
          throw new Error('重建的文本为空');
        }

        setInputText(newText);
        console.log('✓ 左侧文本已同步');

        // 4. 刷新右侧显示（传递文本参数）
        parseAndDisplay(newText);
        console.log('✓ 右侧显示已刷新');
        console.log('✓✓✓ 图片移动成功！');

      } catch (error) {
        console.error('✗✗✗ 拖拽失败:', error.message);
        console.error('错误堆栈:', error.stack);
        alert('图片移动失败：' + error.message);
      }

      // 清空拖拽状态
      draggedImageId = null;
      draggedSourceField = null;
      dropTargetInfo = null;
      console.log('========== 图片拖拽结束 ==========\n');
    }

    // 从 parsedData 重建文本（用于图片拖拽后同步）
    function rebuildTextFromParsedData() {
      const lines = [];

      parsedData.forEach((q, index) => {
        // 题型标识（如果有）
        if (index === 0 || parsedData[index - 1].type !== q.type) {
          lines.push(q.typeName || '');
        }

        // 题干
        lines.push(`${q.id || ''}. ${q.content || ''}`);

        // 选项
        if (q.options && Array.isArray(q.options) && q.options.length > 0) {
          q.options.forEach(opt => {
            if (opt && opt.label && opt.text !== undefined) {
              lines.push(`${opt.label}. ${opt.text}`);
            }
          });
        }

        // 答案
        if (q.answer) {
          lines.push(`答案：${q.answer}`);
        }

        // 解析
        if (q.explanation) {
          lines.push(`答案解析：${q.explanation}`);
        }

        // 知识点
        if (q.knowledgePoints && Array.isArray(q.knowledgePoints) && q.knowledgePoints.length > 0) {
          const kpNames = q.knowledgePoints
            .filter(id => id) // 过滤空值
            .map(id => knowledgePointsMap[id] || id);
          if (kpNames.length > 0) {
            lines.push(`知识点：${kpNames.join('、')}`);
          }
        }

        // 空行分隔
        lines.push('');
      });

      const result = lines.join('\n').trim();
      console.log('重建文本完成，长度:', result.length);
      console.log('重建文本内容:', result);
      return result;
    }

    // 在精确位置插入图片标记
    function insertImageAtPreciseLocation(lines, targetInfo, imageMarker) {
      if (!targetInfo || !targetInfo.range) return;

      const questionIndex = targetInfo.questionIndex;
      const fieldType = targetInfo.fieldType;
      const optionIndex = targetInfo.optionIndex;

      // 获取目标文本内容
      const range = targetInfo.range;
      let targetTextNode = range.startContainer;

      // 如果是元素节点，获取其文本内容
      if (targetTextNode.nodeType === Node.ELEMENT_NODE) {
        targetTextNode = targetTextNode.childNodes[0] || targetTextNode;
      }

      // 获取完整的文本内容
      let fullText = '';
      let currentNode = targetTextNode;

      // 向上找到包含完整文本的节点
      while (currentNode && currentNode.nodeType === Node.TEXT_NODE) {
        fullText = currentNode.textContent;
        if (currentNode.parentNode && currentNode.parentNode.tagName === 'P') {
          // 获取整个段落的文本
          fullText = currentNode.parentNode.textContent;
          break;
        }
        currentNode = currentNode.parentNode;
      }

      // 如果没有找到文本，使用默认插入方式
      if (!fullText) {
        addImageMarkerToField(lines, {
          questionIndex: questionIndex,
          fieldType: fieldType,
          optionIndex: optionIndex
        }, imageMarker);
        return;
      }

      // 计算插入位置（相对于完整文本的偏移）
      let insertOffset = range.startOffset;

      // 获取光标前后的文本
      const textBefore = fullText.substring(0, insertOffset);
      const textAfter = fullText.substring(insertOffset);

      // 在文本行中找到对应的行并插入
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // 根据字段类型查找对应行
        let found = false;
        if (fieldType === 'content') {
          const questionMatch = line.match(/^(\d+)[.、:。：]\s*/);
          if (questionMatch) {
            // 提取题号后的内容
            const prefix = questionMatch[0];
            const content = lines[i].substring(lines[i].indexOf(prefix) + prefix.length);

            // 检查是否匹配
            if (content.includes(textBefore.trim()) || fullText.includes(content.trim())) {
              // 找到位置并插入
              const beforeMatch = lines[i].indexOf(textBefore.trim());
              if (beforeMatch !== -1) {
                const insertPos = beforeMatch + textBefore.trim().length;
                lines[i] = lines[i].substring(0, insertPos) + imageMarker + lines[i].substring(insertPos);
                return;
              } else {
                // 默认插入到行尾
                lines[i] = lines[i] + imageMarker;
                return;
              }
            }
          }
        } else if (fieldType === 'option' && optionIndex !== null) {
          const optionLabel = String.fromCharCode(65 + optionIndex);
          const optionMatch = line.match(new RegExp(`^${optionLabel}[.、:。：]\\s*`));
          if (optionMatch) {
            const prefix = optionMatch[0];
            const content = lines[i].substring(lines[i].indexOf(prefix) + prefix.length);

            if (content.includes(textBefore.trim()) || fullText.includes(content.trim())) {
              const beforeMatch = lines[i].indexOf(textBefore.trim());
              if (beforeMatch !== -1) {
                const insertPos = beforeMatch + textBefore.trim().length;
                lines[i] = lines[i].substring(0, insertPos) + imageMarker + lines[i].substring(insertPos);
                return;
              } else {
                lines[i] = lines[i] + imageMarker;
                return;
              }
            }
          }
        } else if (fieldType === 'explanation') {
          if (line.startsWith('解析：') || line.startsWith('答案解析：') || line.startsWith('参考答案：')) {
            const prefix = line.match(/^(解析：|答案解析：|参考答案：)/)[0];
            const content = lines[i].substring(lines[i].indexOf(prefix) + prefix.length);

            if (content.includes(textBefore.trim()) || fullText.includes(content.trim())) {
              const beforeMatch = lines[i].indexOf(textBefore.trim());
              if (beforeMatch !== -1) {
                const insertPos = beforeMatch + textBefore.trim().length;
                lines[i] = lines[i].substring(0, insertPos) + imageMarker + lines[i].substring(insertPos);
                return;
              } else {
                lines[i] = lines[i] + imageMarker;
                return;
              }
            }
          }
        }
      }

      // 如果没有找到精确位置，使用默认插入方式
      addImageMarkerToField(lines, {
        questionIndex: questionIndex,
        fieldType: fieldType,
        optionIndex: optionIndex
      }, imageMarker);
    }

    // 从指定字段删除图片标记
    function removeImageMarkerFromField(lines, fieldInfo, imageMarker) {
      const question = parsedData[fieldInfo.questionIndex];
      if (!question) return;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // 根据字段类型查找对应行
        if (fieldInfo.fieldType === 'content') {
          // 题目内容（题号那一行）
          const questionMatch = line.match(/^(\d+)[.、:。：]\s*/);
          if (questionMatch && lines[i].includes(imageMarker)) {
            lines[i] = lines[i].replace(imageMarker, '');
            return;
          }
        } else if (fieldInfo.fieldType === 'option' && fieldInfo.optionIndex !== null) {
          // 选项
          const optionLabel = String.fromCharCode(65 + fieldInfo.optionIndex); // A, B, C...
          const optionMatch = line.match(new RegExp(`^${optionLabel}[.、:。：]\\s*`));
          if (optionMatch && lines[i].includes(imageMarker)) {
            lines[i] = lines[i].replace(imageMarker, '');
            return;
          }
        } else if (fieldInfo.fieldType === 'explanation') {
          // 解析
          if ((line.startsWith('解析：') || line.startsWith('答案解析：') || line.startsWith('参考答案：')) &&
              lines[i].includes(imageMarker)) {
            lines[i] = lines[i].replace(imageMarker, '');
            return;
          }
        }
      }
    }

    // 向指定字段添加图片标记
    function addImageMarkerToField(lines, fieldInfo, imageMarker) {
      const question = parsedData[fieldInfo.questionIndex];
      if (!question) return;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (fieldInfo.fieldType === 'content') {
          // 题目内容（题号那一行）
          const questionMatch = line.match(/^(\d+)[.、:。：]\s*/);
          if (questionMatch) {
            lines[i] = lines[i] + imageMarker;
            return;
          }
        } else if (fieldInfo.fieldType === 'option' && fieldInfo.optionIndex !== null) {
          // 选项
          const optionLabel = String.fromCharCode(65 + fieldInfo.optionIndex); // A, B, C...
          const optionMatch = line.match(new RegExp(`^${optionLabel}[.、:。：]\\s*`));
          if (optionMatch) {
            lines[i] = lines[i] + imageMarker;
            return;
          }
        } else if (fieldInfo.fieldType === 'explanation') {
          // 解析 - 查找解析行或创建解析行
          let explanationLineIndex = -1;
          for (let j = 0; j < lines.length; j++) {
            const l = lines[j].trim();
            if (l.startsWith('解析：') || l.startsWith('答案解析：') || l.startsWith('参考答案：')) {
              explanationLineIndex = j;
              break;
            }
          }

          if (explanationLineIndex !== -1) {
            // 已有解析行
            lines[explanationLineIndex] = lines[explanationLineIndex] + imageMarker;
          } else {
            // 没有解析行，需要创建
            // 找到答案行后面插入
            for (let j = 0; j < lines.length; j++) {
              const l = lines[j].trim();
              if (l.startsWith('答案：') || l.startsWith('答：') || l.startsWith('正确答案：')) {
                lines.splice(j + 1, 0, `解析：${imageMarker}`);
                return;
              }
            }
          }
          return;
        }
      }
    }

    // 清空输入
    function clearInput() {
      if (confirm('确定要清空所有内容吗？这将同时清除已保存的草稿。')) {
        document.getElementById('inputText').innerHTML = '';
        parsedData = [];
        imageDataMap = {};
        formulaDataMap = {};

        // 清除草稿
        localStorage.removeItem('questionDraft');

        // 隐藏保存时间提示
        const timeContainer = document.getElementById('draftSaveTime');
        if (timeContainer) {
          timeContainer.classList.add('hidden');
        }

        showEmptyState();
      }
    }

    // 刷新预览
    function refreshPreview() {
      const text = getInputText();
      if (text) {
        parseAndDisplay(text);
      }
    }

    // 保存草稿
    function saveDraft() {
      if (parsedData.length === 0) {
        alert('当前没有可保存的题目');
        return;
      }

      try {
        // 获取当前输入区的 HTML 内容
        const inputDiv = document.getElementById('inputText');
        const inputHtml = inputDiv ? inputDiv.innerHTML : '';

        // 准备保存的数据
        const draftData = {
          questions: parsedData,
          errorIndexes: errorIndexes,
          inputHtml: inputHtml,
          imageDataMap: imageDataMap,
          formulaDataMap: formulaDataMap,
          saveTime: new Date().toISOString()
        };

        // 保存到 localStorage
        localStorage.setItem('questionDraft', JSON.stringify(draftData));

        // 更新保存时间显示
        updateDraftSaveTime();

        // 提示用户
        alert(`草稿已保存！共 ${parsedData.length} 道题目`);
      } catch (error) {
        console.error('保存草稿失败:', error);
        alert('保存草稿失败，请重试');
      }
    }

    // 加载草稿
    function loadDraft() {
      try {
        const draftJson = localStorage.getItem('questionDraft');
        if (!draftJson) {
          return false;
        }

        const draftData = JSON.parse(draftJson);

        // 恢复数据
        parsedData = draftData.questions || [];
        errorIndexes = draftData.errorIndexes || [];
        imageDataMap = draftData.imageDataMap || {};
        formulaDataMap = draftData.formulaDataMap || {};

        // 恢复输入区内容
        if (draftData.inputHtml) {
          const inputDiv = document.getElementById('inputText');
          if (inputDiv) {
            inputDiv.innerHTML = draftData.inputHtml;
          }
        }

        // 更新显示
        if (parsedData.length > 0) {
          updateStatistics();
          displayQuestions();
          updateDraftSaveTime();

          console.log('草稿加载成功，共', parsedData.length, '道题目');
        }

        return true;
      } catch (error) {
        console.error('加载草稿失败:', error);
        return false;
      }
    }

    // 更新草稿保存时间显示
    function updateDraftSaveTime() {
      try {
        const draftJson = localStorage.getItem('questionDraft');
        if (!draftJson) {
          return;
        }

        const draftData = JSON.parse(draftJson);
        if (!draftData.saveTime) {
          return;
        }

        const saveTime = new Date(draftData.saveTime);
        const now = new Date();
        const diff = Math.floor((now - saveTime) / 1000); // 秒

        let timeText = '';
        if (diff < 60) {
          timeText = '刚刚已保存';
        } else if (diff < 3600) {
          const minutes = Math.floor(diff / 60);
          timeText = `${minutes}分钟前已保存`;
        } else if (diff < 86400) {
          const hours = Math.floor(diff / 3600);
          timeText = `${hours}小时前已保存`;
        } else {
          const days = Math.floor(diff / 86400);
          timeText = `${days}天前已保存`;
        }

        const timeElement = document.getElementById('draftTimeText');
        const containerElement = document.getElementById('draftSaveTime');

        if (timeElement && containerElement) {
          timeElement.textContent = timeText;
          containerElement.classList.remove('hidden');
        }
      } catch (error) {
        console.error('更新保存时间显示失败:', error);
      }
    }

    // 清除草稿
    function clearDraft() {
      if (confirm('确定要清除所有草稿吗？')) {
        localStorage.removeItem('questionDraft');
        location.reload();
      }
    }

    // 批量导入
    function batchImport() {
      if (parsedData.length === 0) {
        alert('没有可导入的题目');
        return;
      }

      // 检查是否有错误
      const errorCount = parsedData.filter(q => q.hasError).length;
      if (errorCount > 0) {
        alert(`还有 ${errorCount} 道题目存在错误，请修改后再导入`);
        return;
      }

      // 显示分数设置弹窗
      showScoreSettingModal();
    }

    // 显示分数设置弹窗
    function showScoreSettingModal() {
      // 更新题目数量
      document.getElementById('totalScoreQuestions').textContent = parsedData.length;

      // 渲染题目列表（表格）
      renderScoreQuestionTable();

      // 显示弹窗
      document.getElementById('scoreSettingModal').classList.remove('hidden');
    }

    // 关闭分数设置弹窗
    function closeScoreModal() {
      document.getElementById('scoreSettingModal').classList.add('hidden');
    }

    // 记录展开/收起状态
    const expandedStates = {};

    // 渲染分数设置题目表格
    function renderScoreQuestionTable() {
      const tbody = document.getElementById('scoreQuestionTableBody');
      const filterType = document.getElementById('scoreTypeFilter').value;

      let html = '';
      let visibleIndex = 0;

      parsedData.forEach((q, index) => {
        // 题型筛选
        if (filterType !== 'all' && q.type !== filterType) {
          return;
        }

        visibleIndex++;

        // 初始化展开状态（默认展开）
        if (expandedStates[index] === undefined) {
          expandedStates[index] = true;
        }

        const isExpanded = expandedStates[index];

        // 计算rowspan：收起时为1，展开时为1+子行数
        let rowspanCount = 1;
        if (isExpanded && (q.type === 'blank' || q.type === 'composite')) {
          if (q.type === 'blank') {
            rowspanCount += q.blankAnswers ? q.blankAnswers.length : 1;
          } else if (q.type === 'composite') {
            rowspanCount += q.compositeSubQuestions ? q.compositeSubQuestions.length : 0;
          }
        }

        // 主行
        html += `
          <tr class="hover:bg-gray-50 transition-colors" data-index="${index}" data-type="${q.type}">
            <td class="px-4 py-3 text-sm text-gray-900 font-medium" rowspan="${rowspanCount}">${visibleIndex}</td>
            <td class="px-4 py-3" rowspan="${rowspanCount}">
              <span class="${getTypeTagClass(q.type)}">${q.typeName}</span>
            </td>
            <td class="px-4 py-3 text-sm text-gray-700" rowspan="${rowspanCount}">
              ${convertImagesToHTML(q.content).substring(0, 80)}${q.content.length > 80 ? '...' : ''}
            </td>
            <td class="px-4 py-3">`;

        if (q.type === 'blank' || q.type === 'composite') {
          // 填空题和复合题：显示总分（自动计算），需要和子行对齐
          html += `
              <div class="flex items-center">
                <span class="text-xs text-gray-600 inline-block w-32 text-right mr-2">总分：</span>
                <input type="number" id="totalScore_${index}" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary-500 bg-gray-50" min="0" step="0.5" placeholder="总分" readonly>
                <span class="text-xs text-gray-500 ml-2">分</span>
              </div>`;
        } else {
          // 其他题型：直接输入总分，添加标签占位保持对齐
          html += `
              <div class="flex items-center">
                <span class="text-xs text-gray-600 inline-block w-32 text-right mr-2">总分：</span>
                <input type="number" id="score_${index}" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary-500" min="0" step="0.5" placeholder="总分">
                <span class="text-xs text-gray-500 ml-2">分</span>
              </div>`;
        }

        html += `
            </td>
            <td class="px-4 py-3" rowspan="${rowspanCount}">`;

        if (q.type === 'blank' || q.type === 'composite') {
          html += `
              <button onclick="toggleSubScores(${index})" class="text-primary-600 hover:text-primary-700 text-sm">
                <i class="fas fa-angle-${isExpanded ? 'up' : 'down'}" id="toggleIcon_${index}"></i>
                <span id="toggleText_${index}">${isExpanded ? '收起' : '展开'}</span>
              </button>`;
        }

        html += `
            </td>
          </tr>`;

        // 子分数行（填空题/复合题） - 根据展开状态渲染
        if (isExpanded) {
          if (q.type === 'blank') {
            const blankCount = q.blankAnswers ? q.blankAnswers.length : 1;
            for (let i = 0; i < blankCount; i++) {
              html += `
          <tr class="bg-gray-50 border-t border-gray-100" data-parent="${index}">
            <td class="px-4 py-2">
              <div class="flex items-center">
                <span class="text-xs text-gray-600 inline-block w-32 text-right mr-2">第${i + 1}空：</span>
                <input type="number" id="score_${index}_blank_${i}" onchange="calculateTotalScore(${index}, 'blank')" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary-500" min="0" step="0.5" placeholder="分数">
                <span class="text-xs text-gray-500 ml-2">分</span>
              </div>
            </td>
          </tr>`;
            }
          } else if (q.type === 'composite') {
            q.compositeSubQuestions.forEach((subQ, subIdx) => {
              html += `
          <tr class="bg-gray-50 border-t border-gray-100" data-parent="${index}">
            <td class="px-4 py-2">
              <div class="flex items-center">
                <span class="text-xs text-gray-600 inline-block w-32 text-right mr-2">第${subIdx + 1}题（${subQ.typeName}）：</span>
                <input type="number" id="score_${index}_sub_${subIdx}" onchange="calculateTotalScore(${index}, 'composite')" class="w-20 px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary-500" min="0" step="0.5" placeholder="分数">
                <span class="text-xs text-gray-500 ml-2">分</span>
              </div>
            </td>
          </tr>`;
            });
          }
        }
      });

      tbody.innerHTML = html;
    }

    // 展开/折叠子分数
    function toggleSubScores(index) {
      // 保存当前所有分数
      const scores = {};
      parsedData.forEach((q, idx) => {
        if (q.type === 'single' || q.type === 'multiple' || q.type === 'judge' || q.type === 'shortAnswer' || q.type === 'cloze') {
          const scoreInput = document.getElementById(`score_${idx}`);
          if (scoreInput) {
            scores[`score_${idx}`] = scoreInput.value;
          }
        } else if (q.type === 'blank') {
          const blankCount = q.blankAnswers ? q.blankAnswers.length : 1;
          for (let i = 0; i < blankCount; i++) {
            const scoreInput = document.getElementById(`score_${idx}_blank_${i}`);
            if (scoreInput) {
              scores[`score_${idx}_blank_${i}`] = scoreInput.value;
            }
          }
          const totalInput = document.getElementById(`totalScore_${idx}`);
          if (totalInput) {
            scores[`totalScore_${idx}`] = totalInput.value;
          }
        } else if (q.type === 'composite') {
          const subCount = q.compositeSubQuestions ? q.compositeSubQuestions.length : 0;
          for (let i = 0; i < subCount; i++) {
            const scoreInput = document.getElementById(`score_${idx}_sub_${i}`);
            if (scoreInput) {
              scores[`score_${idx}_sub_${i}`] = scoreInput.value;
            }
          }
          const totalInput = document.getElementById(`totalScore_${idx}`);
          if (totalInput) {
            scores[`totalScore_${idx}`] = totalInput.value;
          }
        }
      });

      // 切换状态
      expandedStates[index] = !expandedStates[index];

      // 重新渲染表格
      renderScoreQuestionTable();

      // 恢复分数
      Object.keys(scores).forEach(key => {
        const input = document.getElementById(key);
        if (input) {
          input.value = scores[key];
        }
      });
    }

    // 计算总分（填空题和复合题）
    function calculateTotalScore(index, type) {
      let total = 0;

      if (type === 'blank') {
        const q = parsedData[index];
        const blankCount = q.blankAnswers ? q.blankAnswers.length : 1;
        for (let i = 0; i < blankCount; i++) {
          const scoreInput = document.getElementById(`score_${index}_blank_${i}`);
          const score = scoreInput ? parseFloat(scoreInput.value) : 0;
          if (score > 0) {
            total += score;
          }
        }
      } else if (type === 'composite') {
        const q = parsedData[index];
        const subCount = q.compositeSubQuestions ? q.compositeSubQuestions.length : 0;
        for (let i = 0; i < subCount; i++) {
          const scoreInput = document.getElementById(`score_${index}_sub_${i}`);
          const score = scoreInput ? parseFloat(scoreInput.value) : 0;
          if (score > 0) {
            total += score;
          }
        }
      }

      // 更新总分显示
      const totalInput = document.getElementById(`totalScore_${index}`);
      if (totalInput) {
        totalInput.value = total > 0 ? total : '';
      }
    }

    // 题型筛选
    function filterScoreQuestions() {
      renderScoreQuestionTable();
    }

    // 批量设置总分
    function batchSetScore() {
      const batchScore = parseFloat(document.getElementById('batchScoreInput').value);

      if (!batchScore || batchScore <= 0) {
        alert('请输入有效的分数');
        return;
      }

      const filterType = document.getElementById('scoreTypeFilter').value;

      parsedData.forEach((q, index) => {
        // 题型筛选
        if (filterType !== 'all' && q.type !== filterType) {
          return;
        }

        // 为当前筛选的题型设置分数
        if (q.type === 'single' || q.type === 'multiple' || q.type === 'judge' || q.type === 'shortAnswer' || q.type === 'cloze') {
          const scoreInput = document.getElementById(`score_${index}`);
          if (scoreInput) {
            scoreInput.value = batchScore;
          }
        } else if (q.type === 'blank') {
          // 填空题：平均分配到每个空
          const blankCount = q.blankAnswers ? q.blankAnswers.length : 1;
          const perBlankScore = (batchScore / blankCount).toFixed(1);
          for (let i = 0; i < blankCount; i++) {
            const scoreInput = document.getElementById(`score_${index}_blank_${i}`);
            if (scoreInput) {
              scoreInput.value = perBlankScore;
            }
          }
          calculateTotalScore(index, 'blank');
        } else if (q.type === 'composite') {
          // 复合题：平均分配到每个小题
          const subCount = q.compositeSubQuestions ? q.compositeSubQuestions.length : 0;
          const perSubScore = (batchScore / subCount).toFixed(1);
          for (let i = 0; i < subCount; i++) {
            const scoreInput = document.getElementById(`score_${index}_sub_${i}`);
            if (scoreInput) {
              scoreInput.value = perSubScore;
            }
          }
          calculateTotalScore(index, 'composite');
        }
      });

      // 清空批量输入框
      document.getElementById('batchScoreInput').value = '';
    }

    // 批量清除分数
    function batchClearScore() {
      if (!confirm('确定清除当前筛选题型的所有分数吗？')) {
        return;
      }

      const filterType = document.getElementById('scoreTypeFilter').value;

      parsedData.forEach((q, index) => {
        // 题型筛选
        if (filterType !== 'all' && q.type !== filterType) {
          return;
        }

        // 清除分数
        if (q.type === 'single' || q.type === 'multiple' || q.type === 'judge' || q.type === 'shortAnswer' || q.type === 'cloze') {
          const scoreInput = document.getElementById(`score_${index}`);
          if (scoreInput) {
            scoreInput.value = '';
          }
        } else if (q.type === 'blank') {
          // 填空题：清除每个空的分数
          const blankCount = q.blankAnswers ? q.blankAnswers.length : 1;
          for (let i = 0; i < blankCount; i++) {
            const scoreInput = document.getElementById(`score_${index}_blank_${i}`);
            if (scoreInput) {
              scoreInput.value = '';
            }
          }
          calculateTotalScore(index, 'blank');
        } else if (q.type === 'composite') {
          // 复合题：清除每个小题的分数
          const subCount = q.compositeSubQuestions ? q.compositeSubQuestions.length : 0;
          for (let i = 0; i < subCount; i++) {
            const scoreInput = document.getElementById(`score_${index}_sub_${i}`);
            if (scoreInput) {
              scoreInput.value = '';
            }
          }
          calculateTotalScore(index, 'composite');
        }
      });
    }

    // 确认分数并导入
    function confirmScoreAndImport() {
      // 收集所有分数
      const scores = {};

      parsedData.forEach((q, index) => {
        if (q.type === 'single' || q.type === 'multiple' || q.type === 'judge' || q.type === 'shortAnswer' || q.type === 'cloze') {
          // 单题分数
          const scoreInput = document.getElementById(`score_${index}`);
          const score = scoreInput ? parseFloat(scoreInput.value) : null;
          // 允许分数为空或0，不做验证
          scores[index] = score && score > 0 ? score : null;
        } else if (q.type === 'blank') {
          // 填空题每空分数
          const blankCount = q.blankAnswers ? q.blankAnswers.length : 1;
          scores[index] = [];
          for (let i = 0; i < blankCount; i++) {
            const scoreInput = document.getElementById(`score_${index}_blank_${i}`);
            const score = scoreInput ? parseFloat(scoreInput.value) : null;
            scores[index].push(score && score > 0 ? score : null);
          }
        } else if (q.type === 'composite') {
          // 复合题每小题分数
          const subCount = q.compositeSubQuestions ? q.compositeSubQuestions.length : 0;
          scores[index] = [];
          for (let i = 0; i < subCount; i++) {
            const scoreInput = document.getElementById(`score_${index}_sub_${i}`);
            const score = scoreInput ? parseFloat(scoreInput.value) : null;
            scores[index].push(score && score > 0 ? score : null);
          }
        }
      });

      // 关闭弹窗
      closeScoreModal();

      // 执行导入（带分数，分数可以为null）
      performImport(true, scores);
    }

    // 执行导入
    function performImport(withScore, scores = {}) {
      try {
        // 从 localStorage 读取现有题目
        const existingQuestionsJson = localStorage.getItem('allQuestions');
        let existingQuestions = existingQuestionsJson ? JSON.parse(existingQuestionsJson) : [];

        // 获取当前最大 ID 号
        let maxId = 0;
        existingQuestions.forEach(q => {
          const idNum = parseInt(q.id.replace('Q', ''));
          if (!isNaN(idNum) && idNum > maxId) {
            maxId = idNum;
          }
        });

        // 转换题目格式并添加到题库
        const newQuestions = parsedData.map((q, index) => {
          const newId = `Q${String(maxId + index + 1).padStart(3, '0')}`;
          const now = new Date();
          const timeStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

          console.log('===== 转换题目 =====');
          console.log('题目ID:', q.id);
          console.log('题目类型:', q.type, q.typeName);
          console.log('原始知识点:', q.knowledgePoints);

          // 转换知识点：名称 -> ID 和路径
          const knowledgeIds = [];
          const knowledgePaths = [];
          if (q.knowledgePoints && q.knowledgePoints.length > 0) {
            console.log('[知识点转换] 开始转换', q.knowledgePoints.length, '个知识点');
            console.log('[知识点转换] 知识点名称映射表:', knowledgePointsNameMap);

            q.knowledgePoints.forEach((name, idx) => {
              console.log(`[知识点转换] 第${idx + 1}个: 名称="${name}"`);
              const id = knowledgePointsNameMap[name];
              console.log(`[知识点转换] 映射到ID: "${id}"`);

              if (id) {
                knowledgeIds.push(id);
                // 获取知识点的完整路径
                const path = getKnowledgePathById(id);
                if (path) {
                  knowledgePaths.push(path);
                  console.log(`[知识点转换] 路径: "${path}"`);
                } else {
                  console.warn(`[知识点转换] 未找到路径`);
                }
              } else {
                console.warn(`[知识点转换] 未找到ID映射，知识点名称="${name}"可能不存在`);
              }
            });
          }

          console.log('[知识点转换] 最终结果:');
          console.log('  - knowledgeIds:', knowledgeIds);
          console.log('  - knowledgePaths:', knowledgePaths);
          console.log('  - knowledgePath:', knowledgePaths.join(' / '));

          // 基础题目对象
          const newQuestion = {
            id: newId,
            type: q.type,
            typeName: q.typeName,
            typeIcon: getTypeIcon(q.type),
            typeColor: getTypeColor(q.type),
            difficulty: q.difficulty || 2,
            difficultyName: getDifficultyName(q.difficulty || 2),
            knowledgeIds: knowledgeIds,  // ID数组
            knowledgePath: knowledgePaths.join(' / '),  // 路径字符串
            content: q.content,
            tags: q.tags || [],
            createTime: timeStr,
            author: '简便录入',
            useCount: 0,
            explanation: q.explanation || ''
          };

          console.log('新题目对象:', newQuestion);
          console.log('===================');

          // 根据题型添加特定字段
          if (q.type === 'single' || q.type === 'multiple') {
            newQuestion.options = q.options;
            // 单选题答案是单个字母，多选题答案是多个字母
            if (q.type === 'single') {
              newQuestion.correctAnswers = [q.answer];
            } else {
              // 多选题：将 'ABD' 拆分为 ['A', 'B', 'D']
              newQuestion.correctAnswers = q.answer.split('').filter(c => c.trim());
            }

            // 添加分数（如果有）
            if (withScore && scores[index] !== null && scores[index] !== undefined) {
              newQuestion.score = String(scores[index]);
            }
          } else if (q.type === 'judge') {
            newQuestion.correctAnswer = q.answer === '正确' ? 'true' : 'false';

            // 添加分数（如果有）
            if (withScore && scores[index] !== null && scores[index] !== undefined) {
              newQuestion.score = String(scores[index]);
            }
          } else if (q.type === 'blank') {
            // 填空题
            if (q.blankAnswers && q.blankAnswers.length > 0) {
              newQuestion.blanks = q.blankAnswers.map((ans, idx) => {
                const blankObj = {
                  index: idx + 1,
                  answer: ans.synonyms ? ans.synonyms.join('|||') : ans.text
                };

                // 添加分数（如果有）
                if (withScore && scores[index] && scores[index][idx] !== null && scores[index][idx] !== undefined) {
                  blankObj.score = scores[index][idx];
                }

                return blankObj;
              });
            } else {
              const blankObj = {
                index: 1,
                answer: q.answer
              };

              // 添加分数（如果有）
              if (withScore && scores[index] && scores[index][0] !== null && scores[index][0] !== undefined) {
                blankObj.score = scores[index][0];
              }

              newQuestion.blanks = [blankObj];
            }
          } else if (q.type === 'shortAnswer') {
            // 简答题
            newQuestion.referenceAnswer = q.answer;

            // 添加分数（如果有）
            if (withScore && scores[index] !== null && scores[index] !== undefined) {
              newQuestion.score = String(scores[index]);
            }
          } else if (q.type === 'cloze') {
            // 完形填空
            newQuestion.isComposite = true;
            newQuestion.subCount = q.clozeSubQuestions ? q.clozeSubQuestions.length : 0;

            // 保存完形填空的子题（包含选项）
            if (q.clozeSubQuestions && q.clozeSubQuestions.length > 0) {
              const answers = q.answer ? q.answer.split('').map(letter => letter.trim()).filter(l => l) : [];
              newQuestion.clozeSubQuestions = q.clozeSubQuestions.map((subQ, idx) => ({
                index: subQ.index,
                options: subQ.options,
                correctAnswer: answers[idx] || ''
              }));
            }

            // 构建填空答案数组（兼容旧格式）
            if (q.answer) {
              const answers = q.answer.split('').map(letter => letter.trim()).filter(l => l);
              newQuestion.blanks = answers.map((ans, idx) => ({
                index: idx + 1,
                answer: ans,
                score: 0 // 完形填空的小分暂不支持单独设置
              }));
            }

            // 添加总分（如果有）
            if (withScore && scores[index] !== null && scores[index] !== undefined) {
              newQuestion.score = String(scores[index]);
            }
          } else if (q.type === 'composite') {
            // 复合题（材料分析题）
            newQuestion.type = 'materialAnalysis';
            newQuestion.typeName = '材料分析';
            newQuestion.typeIcon = 'fa-layer-group';
            newQuestion.typeColor = 'purple';
            newQuestion.isComposite = true;
            newQuestion.subCount = q.compositeSubQuestions ? q.compositeSubQuestions.length : 0;

            // 转换子题
            if (q.compositeSubQuestions) {
              newQuestion.subQuestions = q.compositeSubQuestions.map((subQ, subIdx) => {
                const subQuestion = {
                  id: subIdx + 1,
                  type: subQ.type,
                  content: subQ.content,
                  explanation: subQ.explanation || ''
                };

                // 添加子题分数（如果有）
                if (withScore && scores[index] && scores[index][subIdx] !== null && scores[index][subIdx] !== undefined) {
                  subQuestion.score = scores[index][subIdx];
                }

                if (subQ.type === 'single' || subQ.type === 'multiple') {
                  subQuestion.options = subQ.options;
                  // 单选题答案是单个字母，多选题答案是多个字母
                  if (subQ.type === 'single') {
                    subQuestion.correctAnswers = [subQ.answer];
                  } else {
                    // 多选题：将 'ABD' 拆分为 ['A', 'B', 'D']
                    subQuestion.correctAnswers = subQ.answer.split('').filter(c => c.trim());
                  }
                } else if (subQ.type === 'judge') {
                  subQuestion.correctAnswer = subQ.answer === '正确' ? 'true' : 'false';
                } else if (subQ.type === 'blank') {
                  if (subQ.blankAnswers && subQ.blankAnswers.length > 0) {
                    subQuestion.blanks = subQ.blankAnswers.map((ans, idx) => ({
                      index: idx + 1,
                      answer: ans.synonyms ? ans.synonyms.join('|||') : ans.text
                    }));
                  } else {
                    subQuestion.answer = subQ.answer;
                  }
                } else if (subQ.type === 'shortAnswer') {
                  subQuestion.referenceAnswer = subQ.answer;
                }

                return subQuestion;
              });

              // 计算总分（如果有设置分数）
              if (withScore && scores[index]) {
                // 过滤掉 null 值，只计算有效分数
                const validScores = scores[index].filter(s => s !== null && s !== undefined);
                if (validScores.length > 0) {
                  const totalScore = validScores.reduce((sum, s) => sum + s, 0);
                  newQuestion.score = String(totalScore);
                }
              }
            }
          }

          return newQuestion;
        });

        // 合并到现有题目列表
        const allQuestions = [...existingQuestions, ...newQuestions];

        console.log('===== 准备保存到localStorage =====');
        console.log('新题目数量:', newQuestions.length);
        console.log('现有题目数量:', existingQuestions.length);
        console.log('合并后总数:', allQuestions.length);
        console.log('第一个新题目:', newQuestions[0]);
        console.log('  - knowledgeIds:', newQuestions[0].knowledgeIds);
        console.log('  - knowledgePath:', newQuestions[0].knowledgePath);

        // 保存到 localStorage
        localStorage.setItem('allQuestions', JSON.stringify(allQuestions));

        console.log('✅ 已保存到localStorage');
        console.log('验证读取:', JSON.parse(localStorage.getItem('allQuestions')).length, '道题目');
        console.log('==================================');

        // 清除草稿
        localStorage.removeItem('questionDraft');

        alert(`成功导入 ${parsedData.length} 道题目！`);

        // 跳转到题目列表页
        window.location.href = 'list.html';
      } catch (error) {
        console.error('批量导入失败:', error);
        alert('导入失败，请重试');
      }
    }

    // 获取题型图标
    function getTypeIcon(type) {
      const iconMap = {
        'single': 'fa-dot-circle',
        'multiple': 'fa-check-double',
        'judge': 'fa-check',
        'blank': 'fa-pen',
        'shortAnswer': 'fa-align-left',
        'cloze': 'fa-layer-group',
        'composite': 'fa-layer-group',
        'materialAnalysis': 'fa-layer-group'
      };
      return iconMap[type] || 'fa-question-circle';
    }

    // 获取题型颜色
    function getTypeColor(type) {
      const colorMap = {
        'single': 'info',
        'multiple': 'success',
        'judge': 'warning',
        'blank': 'primary',
        'shortAnswer': 'purple',
        'cloze': 'indigo',
        'composite': 'purple',
        'materialAnalysis': 'purple'
      };
      return colorMap[type] || 'gray';
    }

    // 获取题型标签完整类名（Tailwind 不支持动态类名）
    function getTypeTagClass(type) {
      const classMap = {
        'single': 'inline-block px-2 py-1 bg-cyan-100 text-cyan-700 text-xs font-medium rounded',
        'multiple': 'inline-block px-2 py-1 bg-green-100 text-green-700 text-xs font-medium rounded',
        'judge': 'inline-block px-2 py-1 bg-amber-100 text-amber-700 text-xs font-medium rounded',
        'blank': 'inline-block px-2 py-1 bg-primary-100 text-primary-700 text-xs font-medium rounded',
        'shortAnswer': 'inline-block px-2 py-1 bg-purple-100 text-purple-700 text-xs font-medium rounded',
        'cloze': 'inline-block px-2 py-1 bg-indigo-100 text-indigo-700 text-xs font-medium rounded',
        'composite': 'inline-block px-2 py-1 bg-purple-100 text-purple-700 text-xs font-medium rounded',
        'materialAnalysis': 'inline-block px-2 py-1 bg-purple-100 text-purple-700 text-xs font-medium rounded'
      };
      return classMap[type] || 'inline-block px-2 py-1 bg-gray-100 text-gray-700 text-xs font-medium rounded';
    }

    // 获取难度名称
    function getDifficultyName(level) {
      const names = ['', '一级', '二级', '三级', '四级', '五级'];
      return names[level] || '二级';
    }

    // 显示格式说明
    function showFormatGuide() {
      document.getElementById('formatGuideModal').classList.remove('hidden');
    }

    // 关闭格式说明
    function closeFormatGuide() {
      document.getElementById('formatGuideModal').classList.add('hidden');
    }

    // 显示输入范例
    function showInputExample() {
      document.getElementById('exampleModal').classList.remove('hidden');
    }

    // 关闭范例
    function closeExample() {
      document.getElementById('exampleModal').classList.add('hidden');
    }

    // 使用示例
    function useExample() {
      const exampleText = document.getElementById('exampleText').textContent;
      document.getElementById('inputText').value = exampleText;
      closeExample();
      handleInputChange();
    }

    // 点击弹窗外部关闭
    document.getElementById('formatGuideModal').addEventListener('click', function(e) {
      if (e.target === this) closeFormatGuide();
    });
    document.getElementById('exampleModal').addEventListener('click', function(e) {
      if (e.target === this) closeExample();
    });

    // 粘贴图片支持 - 已废弃，改用 DOMContentLoaded 中的统一处理
    // 保留注释以便追踪历史代码
    /*
    document.getElementById('inputText').addEventListener('paste', function(e) {
      const items = e.clipboardData.items;

      for (let i = 0; i < items.length; i++) {
        const item = items[i];

        // 检查是否为图片类型
        if (item.type.indexOf('image') !== -1) {
          e.preventDefault(); // 阻止默认粘贴行为

          const file = item.getAsFile();
          if (!file) continue;

          // 检查文件大小（最大 5MB）
          if (file.size > 5 * 1024 * 1024) {
            alert('图片大小不能超过 5MB');
            continue;
          }

          // 读取图片
          const reader = new FileReader();
          reader.onload = function(e) {
            const base64Data = e.target.result;

            // 获取图片尺寸
            const img = new Image();
            img.onload = function() {
              // 自动调整尺寸（最大宽度 400px）
              let width = img.width;
              let height = img.height;
              const maxWidth = 400;

              if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
              }

              // 插入图片标记到光标位置
              insertImageMarkdown(base64Data, width, height);
            };
            img.src = base64Data;
          };
          reader.readAsDataURL(file);

          break; // 只处理第一张图片
        }
      }
    });
    */
  </script>
</body>
</html>
