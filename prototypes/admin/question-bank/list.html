<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>题目列表 - 考试系统</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: { 50: '#E6F9F0', 500: '#00B96B', 600: '#00A35C' },
            success: { 50: '#E8FFEA', 500: '#00B42A' },
            warning: { 50: '#FFF7E8', 500: '#FF7D00' },
            error: { 50: '#FFECE8', 500: '#F53F3F' },
            info: { 50: '#E8F7FF', 500: '#14C9C9' },
            indigo: { 50: '#E8E7FF', 500: '#6366F1' },
            purple: { 50: '#FAF5FF', 500: '#A855F7' }
          }
        }
      }
    }
  </script>
  <style>
    /* 苹果风格卡片 */
    .apple-card {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .apple-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }

    /* 知识点树样式 */
    .tree-item {
      transition: all 0.2s;
    }
    .tree-item:hover {
      background-color: #F9FAFB;
    }
    .tree-item.active {
      background-color: #E6F9F0;
      color: #00B96B;
      font-weight: 500;
    }

    /* 滚动条样式 */
    .custom-scrollbar::-webkit-scrollbar {
      width: 6px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
      background: #f1f1f1;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: #a1a1a1;
    }

    /* 题目内容样式 */
    .question-content {
      line-height: 1.75;
    }
    .question-content img {
      max-width: 100%;
      height: auto;
      margin: 12px 0;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
      display: block;
    }
    .question-content br {
      display: block;
      margin: 4px 0;
      content: "";
    }

    /* 侧滑面板样式 */
    .preview-drawer {
      position: fixed;
      top: 0;
      right: -600px;
      width: 600px;
      height: 100vh;
      background: white;
      box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
      transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 100;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .preview-drawer.active {
      right: 0;
    }
    .preview-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
      z-index: 99;
    }
    .preview-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    .option-label {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #f3f4f6;
      color: #6b7280;
      font-size: 14px;
      font-weight: 500;
      margin-right: 8px;
      flex-shrink: 0;
    }
    .option-label.correct {
      background: #d1fae5;
      color: #065f46;
    }
    .preview-drawer::-webkit-scrollbar {
      width: 6px;
    }
    .preview-drawer::-webkit-scrollbar-track {
      background: #f1f1f1;
    }
    .preview-drawer::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
    }
  </style>
  <!-- iframe嵌入检测脚本 -->
  <script>
  (function() {
    function isInIframe() {
      try { return window.self !== window.top; } catch (e) { return true; }
    }
    if (isInIframe() || window.location.search.includes("embedded=true")) {
      document.write('<style>header{display:none!important}aside{display:none!important}.pt-16{padding-top:0!important}.ml-64{margin-left:0!important}button[onclick*="history.back"]{display:none!important}</style>');
    }
  })();
  </script>
</head>
<body class="bg-gray-50">
  <!-- 顶部导航栏 -->
  <header class="h-16 bg-white border-b border-gray-200 fixed top-0 left-0 right-0 z-50">
    <div class="flex items-center justify-between h-full px-6">
      <div class="flex items-center space-x-4">
        <div class="flex items-center space-x-2">
          <div class="w-8 h-8 bg-primary-500 rounded flex items-center justify-center">
            <i class="fas fa-graduation-cap text-white"></i>
          </div>
          <span class="text-xl font-semibold text-gray-900">考试系统</span>
        </div>
        <nav class="hidden md:flex items-center space-x-2 text-sm text-gray-600">
          <a href="../dashboard.html" class="hover:text-primary-500">首页</a>
          <i class="fas fa-chevron-right text-xs text-gray-400"></i>
          <span class="text-gray-900 font-medium">题库管理</span>
        </nav>
      </div>
      <div class="flex items-center space-x-4">
        <img src="https://via.placeholder.com/32" alt="用户" class="w-8 h-8 rounded-full">
        <span class="text-sm text-gray-700 font-medium">管理员</span>
      </div>
    </div>
  </header>

  <div class="pt-16 flex h-screen">
    <!-- 左侧知识点树 -->
    <aside class="w-80 bg-white border-r border-gray-200 flex flex-col">
      <!-- 搜索栏 -->
      <div class="p-4 border-b border-gray-200">
        <div class="relative mb-3">
          <input type="text" id="searchInput" placeholder="搜索知识点..." oninput="searchKnowledge(this.value)"
                 class="w-full pl-10 pr-10 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent">
          <i class="fas fa-search absolute left-3 top-2.5 text-gray-400"></i>
          <button id="clearSearchBtn" onclick="clearSearch()" class="hidden absolute right-3 top-2 w-6 h-6 flex items-center justify-center text-gray-400 hover:text-gray-600 rounded-full hover:bg-gray-100 transition-colors">
            <i class="fas fa-times text-xs"></i>
          </button>
        </div>
        <div class="flex items-center gap-2">
          <button onclick="addRootDirectory()" class="flex-1 bg-primary-500 hover:bg-primary-600 text-white px-3 py-2 rounded-lg text-sm font-medium transition-colors">
            <i class="fas fa-folder-plus mr-1.5"></i>添加目录
          </button>
          <button onclick="addRootKnowledgePoint()" class="flex-1 bg-success-500 hover:bg-success-600 text-white px-3 py-2 rounded-lg text-sm font-medium transition-colors">
            <i class="fas fa-book mr-1.5"></i>添加知识点
          </button>
        </div>
      </div>

      <!-- 知识点树 -->
      <div id="knowledgeTree" class="flex-1 overflow-y-auto custom-scrollbar p-4">
        <div class="space-y-1">
          <!-- 全部题目 -->
          <div class="tree-item active px-3 py-2 rounded-lg cursor-pointer flex items-center justify-between" onclick="selectAllQuestions(this)">
            <div class="flex items-center space-x-2">
              <i class="fas fa-folder text-primary-500"></i>
              <span class="text-sm">全部题目</span>
            </div>
            <span class="text-xs text-gray-500" id="totalQuestionsInTree">128</span>
          </div>

          <!-- 动态渲染的知识点树 -->
          <div id="knowledgeTreeContainer" class="mt-4 space-y-1">
            <!-- 将通过JavaScript动态渲染 -->
          </div>
        </div>
      </div>
    </aside>

    <!-- 右侧主内容区 -->
    <main class="flex-1 flex flex-col bg-gray-50">
      <!-- 工具栏 -->
      <div class="bg-white border-b border-gray-200 px-6 py-4">
        <!-- 第一行：标题和操作 -->
        <div class="flex items-center justify-between mb-4">
          <div>
            <h1 class="text-xl font-semibold text-gray-900" id="pageTitle">全部题目</h1>
            <p class="mt-1 text-sm text-gray-500">共 <span id="totalQuestions">128</span> 道题目</p>
          </div>
          <div class="flex items-center space-x-3">
            <button onclick="openQuestionTypeSettings()" class="px-4 py-2.5 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 hover:bg-gray-50 transition-colors">
              <i class="fas fa-cog mr-2"></i>
              题型设置
            </button>
            <button onclick="window.location.href='add-simple.html'" class="px-4 py-2.5 border border-primary-500 text-primary-500 rounded-lg font-medium text-sm flex items-center space-x-2 hover:bg-primary-50 transition-colors">
              <i class="fas fa-keyboard"></i>
              <span>简便录入</span>
            </button>
            <button onclick="addNewQuestion()" class="bg-primary-500 hover:bg-primary-600 text-white px-4 py-2.5 rounded-lg font-medium text-sm flex items-center space-x-2 shadow-sm">
              <i class="fas fa-plus"></i>
              <span>新增题目</span>
            </button>
          </div>
        </div>

        <!-- 筛选栏（一行） -->
        <div class="flex items-center gap-3 flex-wrap">
          <!-- 全局搜索 -->
          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-600 whitespace-nowrap font-medium">搜索:</label>
            <div class="relative">
              <input type="text" id="globalSearchInput" placeholder="搜索题目内容..."
                     oninput="debouncedSearch()" onkeypress="handleEnterKey(event)"
                     class="w-64 pl-10 pr-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent">
              <i class="fas fa-search absolute left-3 top-2.5 text-gray-400"></i>
            </div>
          </div>

          <!-- 题型筛选（多选下拉） -->
          <div class="flex items-center gap-2 relative">
            <label class="text-sm text-gray-600 whitespace-nowrap font-medium">题型:</label>
            <div class="relative">
              <button type="button" id="questionTypeDropdownBtn" onclick="toggleQuestionTypeDropdown()"
                      class="px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500 bg-white min-w-[140px] flex items-center justify-between hover:bg-gray-50 transition-colors">
                <span id="questionTypeLabel" class="text-gray-700">全部题型</span>
                <i class="fas fa-chevron-down text-gray-400 ml-2 text-xs"></i>
              </button>
              <div id="questionTypeDropdown" class="hidden absolute z-20 mt-1 w-56 bg-white border border-gray-200 rounded-lg shadow-lg">
                <div class="p-2 max-h-64 overflow-y-auto custom-scrollbar">
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="single" class="question-type-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateQuestionTypeSelection()">
                    <span class="ml-2 text-sm text-gray-700">单选题</span>
                  </label>
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="multiple" class="question-type-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateQuestionTypeSelection()">
                    <span class="ml-2 text-sm text-gray-700">多选题</span>
                  </label>
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="judge" class="question-type-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateQuestionTypeSelection()">
                    <span class="ml-2 text-sm text-gray-700">判断题</span>
                  </label>
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="blank" class="question-type-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateQuestionTypeSelection()">
                    <span class="ml-2 text-sm text-gray-700">填空题</span>
                  </label>
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="shortAnswer" class="question-type-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateQuestionTypeSelection()">
                    <span class="ml-2 text-sm text-gray-700">简答题</span>
                  </label>
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="cloze" class="question-type-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateQuestionTypeSelection()">
                    <span class="ml-2 text-sm text-gray-700">完形填空</span>
                  </label>
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="materialAnalysis" class="question-type-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateQuestionTypeSelection()">
                    <span class="ml-2 text-sm text-gray-700">材料分析</span>
                  </label>
                </div>
              </div>
            </div>
          </div>

          <!-- 难度筛选（多选下拉） -->
          <div class="flex items-center gap-2 relative">
            <label class="text-sm text-gray-600 whitespace-nowrap font-medium">难度:</label>
            <div class="relative">
              <button type="button" id="difficultyDropdownBtn" onclick="toggleDifficultyDropdown()"
                      class="px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500 bg-white min-w-[120px] flex items-center justify-between hover:bg-gray-50 transition-colors">
                <span id="difficultyLabel" class="text-gray-700">全部难度</span>
                <i class="fas fa-chevron-down text-gray-400 ml-2 text-xs"></i>
              </button>
              <div id="difficultyDropdown" class="hidden absolute z-20 mt-1 w-40 bg-white border border-gray-200 rounded-lg shadow-lg">
                <div class="p-2">
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="1" class="difficulty-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateDifficultySelection()">
                    <span class="ml-2 text-sm text-gray-700">一级</span>
                  </label>
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="2" class="difficulty-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateDifficultySelection()">
                    <span class="ml-2 text-sm text-gray-700">二级</span>
                  </label>
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="3" class="difficulty-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateDifficultySelection()">
                    <span class="ml-2 text-sm text-gray-700">三级</span>
                  </label>
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="4" class="difficulty-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateDifficultySelection()">
                    <span class="ml-2 text-sm text-gray-700">四级</span>
                  </label>
                  <label class="flex items-center px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer transition-colors">
                    <input type="checkbox" value="5" class="difficulty-checkbox rounded border-gray-300 text-primary-500 focus:ring-primary-500" onchange="updateDifficultySelection()">
                    <span class="ml-2 text-sm text-gray-700">五级</span>
                  </label>
                </div>
              </div>
            </div>
          </div>

          <!-- 标签搜索 -->
          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-600 whitespace-nowrap font-medium">标签:</label>
            <input type="text" id="filterTag" placeholder="输入标签..."
                   oninput="debouncedSearch()" onkeypress="handleEnterKey(event)"
                   class="px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500 bg-white min-w-[120px]">
          </div>

          <!-- 筛选和重置按钮 -->
          <button onclick="applyFilters()" class="px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg text-sm font-medium transition-colors whitespace-nowrap">
            筛选
          </button>
          <button onclick="clearAllFilters()" class="px-4 py-2 border border-gray-300 hover:bg-gray-50 text-gray-700 rounded-lg text-sm font-medium transition-colors whitespace-nowrap">
            重置
          </button>
        </div>
      </div>

      <!-- 题目列表 -->
      <div id="questionListContainer" class="flex-1 overflow-y-auto custom-scrollbar p-6 pb-24">
        <div id="questionList" class="max-w-6xl mx-auto space-y-4">
          <!-- 题目将通过JavaScript动态渲染 -->
        </div>

        <!-- 空状态提示 -->
        <div id="emptyState" class="hidden max-w-6xl mx-auto text-center py-20">
          <i class="fas fa-inbox text-6xl text-gray-300 mb-4"></i>
          <p class="text-gray-500 text-lg">暂无题目</p>
          <p class="text-gray-400 text-sm mt-2">请调整筛选条件或新增题目</p>
        </div>

        <!-- 分页控件 -->
        <div id="paginationContainer" class="hidden fixed bottom-0 left-80 right-0 bg-white border-t border-gray-200 px-6 py-4 z-40">
          <div class="max-w-6xl mx-auto flex items-center justify-between">
            <div class="text-sm text-gray-600">
              显示 <span id="pageStart">1</span>-<span id="pageEnd">20</span> 条，共 <span id="pageTotal">0</span> 条
            </div>
            <div class="flex items-center space-x-2">
              <button onclick="goToFirstPage()" id="firstPageBtn" class="px-3 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-600 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors" disabled>
                <i class="fas fa-angle-double-left"></i>
              </button>
              <button onclick="changePage(currentPage - 1)" id="prevPageBtn" class="px-3 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-600 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors" disabled>
                <i class="fas fa-angle-left mr-1"></i>上一页
              </button>
              <div id="pageNumbers" class="flex items-center space-x-1">
                <!-- 页码将通过JavaScript动态渲染 -->
              </div>
              <button onclick="changePage(currentPage + 1)" id="nextPageBtn" class="px-3 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-600 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                下一页<i class="fas fa-angle-right ml-1"></i>
              </button>
              <button onclick="goToLastPage()" id="lastPageBtn" class="px-3 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-600 hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                <i class="fas fa-angle-double-right"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- 题目预览侧滑面板 -->
  <div id="previewOverlay" class="preview-overlay" onclick="closePreview()"></div>
  <div id="previewDrawer" class="preview-drawer">
    <!-- 面板头部 -->
    <div class="flex items-center justify-between px-6 py-4 border-b border-gray-200 bg-gray-50">
      <h2 class="text-lg font-semibold text-gray-900">题目详情</h2>
      <button onclick="closePreview()" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-200 rounded-lg transition-colors">
        <i class="fas fa-times"></i>
      </button>
    </div>

    <!-- 面板内容 -->
    <div id="previewContent" class="flex-1 overflow-y-auto p-6">
      <div class="text-center py-20 text-gray-400">
        <i class="fas fa-circle-notch fa-spin text-3xl mb-3"></i>
        <p>加载中...</p>
      </div>
    </div>

    <!-- 面板底部操作栏 -->
    <div class="flex items-center justify-between px-6 py-4 border-t border-gray-200 bg-gray-50">
      <button onclick="closePreview()" class="px-4 py-2 border border-gray-300 hover:bg-gray-100 text-gray-700 rounded-lg text-sm font-medium transition-colors">
        关闭
      </button>
      <div class="flex items-center space-x-2">
        <button onclick="editCurrentQuestion()" class="px-4 py-2 bg-info-500 hover:bg-info-600 text-white rounded-lg text-sm font-medium transition-colors">
          <i class="fas fa-edit mr-1.5"></i>编辑
        </button>
        <button onclick="deleteCurrentQuestion()" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg text-sm font-medium transition-colors">
          <i class="fas fa-trash mr-1.5"></i>删除
        </button>
      </div>
    </div>
  </div>

  <!-- 移动知识点位置弹窗 -->
  <div id="moveModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-2xl p-6 w-96 shadow-2xl">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold text-gray-900">移动知识点</h3>
        <button onclick="closeMoveModal()" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-2">目标位置</label>
        <select id="moveTargetSelect" class="w-full px-4 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent">
          <option value="root">根目录</option>
          <!-- 动态填充其他知识点 -->
        </select>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-2">排序位置</label>
        <input type="number" id="movePositionInput" min="1" value="1"
               class="w-full px-4 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
               placeholder="输入位置序号（从1开始）">
      </div>
      <div class="flex items-center space-x-3">
        <button onclick="closeMoveModal()" class="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-2 rounded-lg font-medium text-sm transition-colors">
          取消
        </button>
        <button onclick="confirmMove()" class="flex-1 bg-primary-500 hover:bg-primary-600 text-white px-4 py-2 rounded-lg font-medium text-sm transition-colors">
          确定移动
        </button>
      </div>
    </div>
  </div>

  <!-- 题型设置弹窗 -->
  <div id="questionTypeSettingsModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-2xl w-full max-w-4xl max-h-[90vh] shadow-2xl flex flex-col">
      <!-- 弹窗头部 -->
      <div class="flex items-center justify-between px-6 py-4 border-b border-gray-200">
        <div>
          <h3 class="text-lg font-semibold text-gray-900">题型设置</h3>
          <p class="text-sm text-gray-500 mt-1">自定义题型，满足不同出题需求</p>
        </div>
        <button onclick="closeQuestionTypeSettings()" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors">
          <i class="fas fa-times"></i>
        </button>
      </div>

      <!-- 弹窗内容 -->
      <div class="flex-1 overflow-y-auto p-6">
        <!-- 默认题型 -->
        <div class="mb-6">
          <h4 class="text-sm font-semibold text-gray-900 mb-3 flex items-center">
            <i class="fas fa-cube text-primary-500 mr-2"></i>
            默认题型
          </h4>
          <div id="defaultQuestionTypes" class="space-y-2">
            <!-- 动态渲染 -->
          </div>
        </div>

        <!-- 自定义题型 -->
        <div>
          <div class="flex items-center justify-between mb-3">
            <h4 class="text-sm font-semibold text-gray-900 flex items-center">
              <i class="fas fa-puzzle-piece text-success-500 mr-2"></i>
              自定义题型
            </h4>
            <button onclick="openAddCustomType()" class="px-3 py-1.5 bg-success-500 hover:bg-success-600 text-white rounded-lg text-xs font-medium transition-colors">
              <i class="fas fa-plus mr-1"></i>
              添加自定义题型
            </button>
          </div>
          <div id="customQuestionTypes" class="space-y-2">
            <!-- 动态渲染 -->
          </div>
          <div id="emptyCustomTypes" class="hidden text-center py-12 text-gray-400">
            <i class="fas fa-inbox text-4xl mb-3"></i>
            <p class="text-sm">暂无自定义题型</p>
            <p class="text-xs mt-1">点击上方按钮添加</p>
          </div>
        </div>
      </div>

      <!-- 弹窗底部 -->
      <div class="px-6 py-4 border-t border-gray-200 bg-gray-50 rounded-b-2xl">
        <div class="flex items-center justify-end">
          <button onclick="closeQuestionTypeSettings()" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg font-medium text-sm transition-colors">
            关闭
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- 添加/编辑自定义题型弹窗 -->
  <div id="addCustomTypeModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60]">
    <div class="bg-white rounded-2xl w-full max-w-2xl shadow-2xl">
      <div class="flex items-center justify-between px-6 py-4 border-b border-gray-200">
        <h3 class="text-lg font-semibold text-gray-900" id="customTypeModalTitle">添加自定义题型</h3>
        <button onclick="closeAddCustomType()" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-colors">
          <i class="fas fa-times"></i>
        </button>
      </div>

      <div class="p-6 space-y-4">
        <!-- 选择基础题型 -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            基础题型 <span class="text-error-500">*</span>
          </label>
          <select id="baseQuestionType" onchange="updateCompositeOptions()" class="w-full px-4 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500">
            <option value="">请选择</option>
            <option value="single">单选题</option>
            <option value="multiple">多选题</option>
            <option value="judge">判断题</option>
            <option value="blank">填空题</option>
            <option value="shortAnswer">简答题</option>
            <option value="composite">复合题型</option>
          </select>
        </div>

        <!-- 自定义名称 -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            自定义名称 <span class="text-error-500">*</span>
          </label>
          <!-- 原始名称提示（仅编辑内置题型时显示） -->
          <div id="originalNameHint" class="hidden mb-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
            <div class="flex items-start space-x-2">
              <i class="fas fa-info-circle text-blue-500 mt-0.5"></i>
              <div class="flex-1">
                <p class="text-sm text-blue-700">
                  <span class="font-medium">原始名称：</span><span id="originalNameDisplay" class="font-semibold"></span>
                </p>
                <p class="text-xs text-blue-600 mt-1">提示：删除自定义名称即可恢复为原始名称</p>
              </div>
            </div>
          </div>
          <input type="text" id="customTypeName" placeholder="例如：情境选择题、案例分析题"
                 class="w-full px-4 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500">
          <p class="text-xs text-gray-500 mt-1">建议使用易于识别的名称</p>
        </div>

        <!-- 复合方式（仅复合题型显示） -->
        <div id="compositeOptionsContainer" class="hidden">
          <label class="block text-sm font-medium text-gray-700 mb-2">
            复合方式 <span class="text-error-500">*</span>
          </label>
          <div class="border border-gray-300 rounded-lg p-4 space-y-3">
            <div class="flex items-center justify-between">
              <span class="text-sm text-gray-700">包含材料/背景</span>
              <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="hasMaterial" class="sr-only peer" checked>
                <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-primary-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary-500"></div>
              </label>
            </div>

            <div>
              <label class="block text-xs text-gray-600 mb-2">子题型组合</label>
              <div class="space-y-2">
                <label class="flex items-center space-x-2">
                  <input type="checkbox" value="single" class="composite-subtype rounded border-gray-300 text-primary-500 focus:ring-primary-500">
                  <span class="text-sm text-gray-700">单选题</span>
                </label>
                <label class="flex items-center space-x-2">
                  <input type="checkbox" value="multiple" class="composite-subtype rounded border-gray-300 text-primary-500 focus:ring-primary-500">
                  <span class="text-sm text-gray-700">多选题</span>
                </label>
                <label class="flex items-center space-x-2">
                  <input type="checkbox" value="judge" class="composite-subtype rounded border-gray-300 text-primary-500 focus:ring-primary-500">
                  <span class="text-sm text-gray-700">判断题</span>
                </label>
                <label class="flex items-center space-x-2">
                  <input type="checkbox" value="blank" class="composite-subtype rounded border-gray-300 text-primary-500 focus:ring-primary-500">
                  <span class="text-sm text-gray-700">填空题</span>
                </label>
                <label class="flex items-center space-x-2">
                  <input type="checkbox" value="shortAnswer" class="composite-subtype rounded border-gray-300 text-primary-500 focus:ring-primary-500">
                  <span class="text-sm text-gray-700">简答题</span>
                </label>
              </div>
            </div>
          </div>
          <p class="text-xs text-gray-500 mt-1">选择该复合题型包含的子题型</p>
        </div>

        <!-- 描述（可选） -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            描述（可选）
          </label>
          <textarea id="customTypeDescription" rows="3" placeholder="简要说明该题型的特点和使用场景"
                    class="w-full px-4 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary-500 resize-none"></textarea>
        </div>
      </div>

      <div class="flex items-center justify-end space-x-3 px-6 py-4 border-t border-gray-200 bg-gray-50">
        <button onclick="closeAddCustomType()" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg font-medium text-sm transition-colors">
          取消
        </button>
        <button onclick="saveCustomType()" class="px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-lg font-medium text-sm transition-colors">
          保存
        </button>
      </div>
    </div>
  </div>

  <script>
    // ==================== 知识点树数据结构 ====================
    // type: 'directory' 表示目录（可以包含子目录或知识点）
    // type: 'knowledge' 表示知识点（叶子节点，不能再包含子节点）
    let knowledgeTree = [
      {
        id: 1,
        name: '计算机基础',
        type: 'directory',
        count: 45,
        collapsed: false,
        children: [
          { id: 11, name: '计算机系统', type: 'knowledge', count: 15, children: [] },
          { id: 12, name: '操作系统', type: 'knowledge', count: 18, children: [] },
          { id: 13, name: '数据结构', type: 'knowledge', count: 12, children: [] }
        ]
      },
      {
        id: 2,
        name: '编程语言',
        type: 'directory',
        count: 38,
        collapsed: true,
        children: [
          { id: 21, name: 'Python基础', type: 'knowledge', count: 20, children: [] },
          { id: 22, name: 'Java基础', type: 'knowledge', count: 18, children: [] }
        ]
      },
      {
        id: 3,
        name: '数据库',
        type: 'directory',
        count: 25,
        collapsed: true,
        children: [
          { id: 31, name: 'SQL语法', type: 'knowledge', count: 15, children: [] },
          { id: 32, name: '数据库设计', type: 'knowledge', count: 10, children: [] }
        ]
      },
      {
        id: 4,
        name: '网络技术',
        type: 'directory',
        count: 20,
        collapsed: true,
        children: [
          { id: 41, name: '网络协议', type: 'knowledge', count: 12, children: [] },
          { id: 42, name: '网络安全', type: 'knowledge', count: 8, children: [] }
        ]
      }
    ];

    // ==================== 题目数据（示例） ====================
    let allQuestions = [
      {
        id: 'Q001', type: 'single', typeName: '单选题', typeIcon: 'fa-dot-circle', typeColor: 'info',
        difficulty: 2, difficultyName: '二级', knowledgeId: '11', knowledgePath: '计算机基础 / 计算机系统',
        content: '下列关于计算机系统的描述，<strong>正确</strong>的是？',
        tags: ['系统结构', '基础'], createTime: '2026-01-15 14:30', author: '张老师', useCount: 12,
        score: '2', explanation: '计算机系统由硬件和软件两部分组成，硬件是物理设备，软件是程序和数据。',
        options: [
          { label: 'A', text: '计算机只由硬件组成' },
          { label: 'B', text: '计算机系统由硬件和软件组成' },
          { label: 'C', text: '软件不是计算机系统的一部分' },
          { label: 'D', text: '操作系统属于硬件' }
        ],
        correctAnswers: ['B']
      },
      {
        id: 'Q002', type: 'multiple', typeName: '多选题', typeIcon: 'fa-check-double', typeColor: 'success',
        difficulty: 2, difficultyName: '二级', knowledgeId: '21', knowledgePath: '编程语言 / Python基础',
        content: '以下哪些是Python的特点？（多选）',
        tags: ['Python', '特性'], createTime: '2026-01-15 10:20', author: '李老师', useCount: 8,
        score: '3', explanation: 'Python是一种解释型、面向对象、动态类型的高级编程语言，语法简洁易读。',
        options: [
          { label: 'A', text: '解释型语言' },
          { label: 'B', text: '面向对象' },
          { label: 'C', text: '静态类型' },
          { label: 'D', text: '语法简洁' }
        ],
        correctAnswers: ['A', 'B', 'D']
      },
      {
        id: 'Q003', type: 'judge', typeName: '判断题', typeIcon: 'fa-check', typeColor: 'warning',
        difficulty: 1, difficultyName: '一级', knowledgeId: '41', knowledgePath: '网络技术 / 网络协议',
        content: 'HTTP协议是无状态协议。',
        tags: ['HTTP', '协议'], createTime: '2026-01-13 11:15', author: '周老师', useCount: 20,
        score: '1', explanation: 'HTTP协议本身是无状态的，服务器不会保存客户端的状态信息，每次请求都是独立的。',
        correctAnswer: 'true'
      },
      {
        id: 'Q004', type: 'blank', typeName: '填空题', typeIcon: 'fa-pen', typeColor: 'primary',
        difficulty: 2, difficultyName: '二级', knowledgeId: '31', knowledgePath: '数据库 / SQL语法',
        content: 'SQL中用于查询数据的关键字是_____。',
        tags: ['SQL', '查询'], createTime: '2026-01-14 09:30', author: '王老师', useCount: 15,
        score: '2', explanation: 'SELECT是SQL中最基本的查询语句，用于从数据库表中检索数据。',
        blanks: [{ index: 1, answer: 'SELECT', score: 2 }]
      },
      {
        id: 'Q005', type: 'short', typeName: '简答题', typeIcon: 'fa-align-left', typeColor: 'purple',
        difficulty: 3, difficultyName: '三级', knowledgeId: '13', knowledgePath: '计算机基础 / 数据结构',
        content: '请简述栈和队列的区别。',
        tags: ['数据结构', '栈', '队列'], createTime: '2026-01-13 16:20', author: '赵老师', useCount: 10,
        score: '5', explanation: '栈和队列都是线性数据结构，但操作方式不同。',
        referenceAnswer: '栈是后进先出（LIFO）的数据结构，只能在栈顶进行插入和删除操作；队列是先进先出（FIFO）的数据结构，在队尾插入，在队头删除。'
      },
      {
        id: 'Q006', type: 'cloze', typeName: '完形填空', typeIcon: 'fa-layer-group', typeColor: 'indigo',
        difficulty: 3, difficultyName: '三级', knowledgeId: '22', knowledgePath: '编程语言 / Java基础',
        content: 'Java面向对象编程特性包括封装、继承和多态。封装是将数据和操作数据的方法绑定在一起，隐藏对象的内部细节；继承允许子类继承父类的属性和方法，实现代码复用；多态则是指同一个方法调用可以有不同的执行结果，主要通过方法重载和方法重写实现。',
        tags: ['Java', '面向对象'], isComposite: true, subCount: 5,
        createTime: '2026-01-14 16:45', author: '孙老师', useCount: 7,
        score: '10', explanation: 'Java面向对象三大特性是封装、继承、多态。',
        blanks: [
          { index: 1, answer: '封装', score: 2 },
          { index: 2, answer: '继承', score: 2 },
          { index: 3, answer: '多态', score: 2 },
          { index: 4, answer: '重载', score: 2 },
          { index: 5, answer: '重写', score: 2 }
        ]
      },
      {
        id: 'Q007', type: 'materialAnalysis', typeName: '材料分析', typeIcon: 'fa-layer-group', typeColor: 'purple',
        difficulty: 4, difficultyName: '四级', knowledgeId: '32', knowledgePath: '数据库 / 数据库设计',
        content: '某公司数据库设计方案：用户表包含30个字段，包括姓名、身份证号、电话、地址、邮箱等信息。订单表包含订单编号、用户ID、订单时间、订单金额、商品详情、收货地址、支付方式等。请分析该设计是否符合数据库范式要求，并指出存在的问题及优化建议。',
        tags: ['数据库设计', '范式'], isComposite: true, subCount: 3,
        createTime: '2026-01-14 09:30', author: '赵老师', useCount: 6,
        score: '15', explanation: '数据库设计应遵循范式要求，避免数据冗余。',
        subQuestions: [
          { id: 1, type: 'single', content: '该设计违反了第几范式？', score: 3, options: [{ label: 'A', text: '第一范式' }, { label: 'B', text: '第二范式' }, { label: 'C', text: '第三范式' }, { label: 'D', text: '都不违反' }], correctAnswers: ['C'], explanation: '收货地址在订单表中重复存储，违反第三范式。' },
          { id: 2, type: 'short', content: '请指出用户表设计存在的问题。', score: 5, referenceAnswer: '用户表字段过多，应该进行垂直拆分，将常用字段和不常用字段分开存储。', explanation: '' },
          { id: 3, type: 'short', content: '请给出优化建议。', score: 7, referenceAnswer: '1. 将用户表拆分为基本信息表和扩展信息表；2. 将收货地址单独建表，通过外键关联；3. 商品详情应该关联商品表而不是直接存储。', explanation: '' }
        ]
      },
      {
        id: 'Q008', type: 'single', typeName: '单选题', typeIcon: 'fa-dot-circle', typeColor: 'info',
        difficulty: 1, difficultyName: '一级', knowledgeId: '12', knowledgePath: '计算机基础 / 操作系统',
        content: '以下哪个不是操作系统的功能？',
        tags: ['操作系统'], createTime: '2026-01-12 14:30', author: '张老师', useCount: 18,
        score: '2', explanation: '操作系统的主要功能包括进程管理、内存管理、文件管理、设备管理等。',
        options: [
          { label: 'A', text: '进程管理' },
          { label: 'B', text: '内存管理' },
          { label: 'C', text: '编译程序' },
          { label: 'D', text: '文件管理' }
        ],
        correctAnswers: ['C']
      },
      // 新增30道题目
      {
        id: 'Q009', type: 'single', typeName: '单选题', typeIcon: 'fa-dot-circle', typeColor: 'info',
        difficulty: 2, difficultyName: '二级', knowledgeId: '21', knowledgePath: '编程语言 / Python基础',
        content: 'Python中哪个数据类型是不可变的？',
        tags: ['Python', '数据类型'], createTime: '2026-01-16 09:15', author: '李老师', useCount: 5,
        score: '2', explanation: '元组(tuple)是Python中的不可变数据类型，一旦创建就不能修改。',
        options: [{ label: 'A', text: '列表(list)' }, { label: 'B', text: '字典(dict)' }, { label: 'C', text: '元组(tuple)' }, { label: 'D', text: '集合(set)' }],
        correctAnswers: ['C']
      },
      {
        id: 'Q010', type: 'multiple', typeName: '多选题', typeIcon: 'fa-check-double', typeColor: 'success',
        difficulty: 3, difficultyName: '三级', knowledgeId: '31', knowledgePath: '数据库 / SQL语法',
        content: '以下哪些是SQL的聚合函数？',
        tags: ['SQL', '聚合函数'], createTime: '2026-01-16 10:20', author: '王老师', useCount: 9,
        score: '3', explanation: 'SQL聚合函数包括COUNT、SUM、AVG、MAX、MIN等。',
        options: [{ label: 'A', text: 'COUNT' }, { label: 'B', text: 'SUM' }, { label: 'C', text: 'SELECT' }, { label: 'D', text: 'AVG' }],
        correctAnswers: ['A', 'B', 'D']
      },
      {
        id: 'Q011', type: 'judge', typeName: '判断题', typeIcon: 'fa-check', typeColor: 'warning',
        difficulty: 1, difficultyName: '一级', knowledgeId: '11', knowledgePath: '计算机基础 / 计算机系统',
        content: 'CPU是计算机的核心部件，负责执行指令和处理数据。',
        tags: ['CPU', '硬件'], createTime: '2026-01-16 11:30', author: '张老师', useCount: 14,
        score: '1', explanation: 'CPU（中央处理器）是计算机的核心，负责执行程序指令和处理数据。',
        correctAnswer: 'true'
      },
      {
        id: 'Q012', type: 'blank', typeName: '填空题', typeIcon: 'fa-pen', typeColor: 'primary',
        difficulty: 2, difficultyName: '二级', knowledgeId: '22', knowledgePath: '编程语言 / Java基础',
        content: 'Java中的_____关键字用于定义常量。',
        tags: ['Java', '关键字'], createTime: '2026-01-16 13:45', author: '孙老师', useCount: 11,
        score: '2', explanation: 'final关键字用于定义常量，被final修饰的变量不能被重新赋值。',
        blanks: [{ index: 1, answer: 'final', score: 2 }]
      },
      {
        id: 'Q013', type: 'single', typeName: '单选题', typeIcon: 'fa-dot-circle', typeColor: 'info',
        difficulty: 3, difficultyName: '三级', knowledgeId: '13', knowledgePath: '计算机基础 / 数据结构',
        content: '二叉搜索树的中序遍历结果是什么顺序？',
        tags: ['数据结构', '二叉树'], createTime: '2026-01-16 14:10', author: '赵老师', useCount: 7,
        score: '2', explanation: '二叉搜索树的中序遍历会按照升序输出所有节点。',
        options: [{ label: 'A', text: '随机顺序' }, { label: 'B', text: '升序' }, { label: 'C', text: '降序' }, { label: 'D', text: '层序' }],
        correctAnswers: ['B']
      },
      {
        id: 'Q014', type: 'multiple', typeName: '多选题', typeIcon: 'fa-check-double', typeColor: 'success',
        difficulty: 2, difficultyName: '二级', knowledgeId: '41', knowledgePath: '网络技术 / 网络协议',
        content: '以下哪些属于应用层协议？',
        tags: ['网络协议', '应用层'], createTime: '2026-01-16 15:25', author: '周老师', useCount: 13,
        score: '3', explanation: 'HTTP、FTP、SMTP都是应用层协议，TCP是传输层协议。',
        options: [{ label: 'A', text: 'HTTP' }, { label: 'B', text: 'FTP' }, { label: 'C', text: 'TCP' }, { label: 'D', text: 'SMTP' }],
        correctAnswers: ['A', 'B', 'D']
      },
      {
        id: 'Q015', type: 'judge', typeName: '判断题', typeIcon: 'fa-check', typeColor: 'warning',
        difficulty: 1, difficultyName: '一级', knowledgeId: '21', knowledgePath: '编程语言 / Python基础',
        content: 'Python是一种解释型编程语言。',
        tags: ['Python', '语言特性'], createTime: '2026-01-16 16:40', author: '李老师', useCount: 16,
        score: '1', explanation: 'Python是解释型语言，代码在运行时由解释器逐行执行。',
        correctAnswer: 'true'
      },
      {
        id: 'Q016', type: 'short', typeName: '简答题', typeIcon: 'fa-align-left', typeColor: 'purple',
        difficulty: 3, difficultyName: '三级', knowledgeId: '32', knowledgePath: '数据库 / 数据库设计',
        content: '请简述数据库三大范式的主要内容。',
        tags: ['数据库设计', '范式'], createTime: '2026-01-17 09:00', author: '王老师', useCount: 8,
        score: '5', explanation: '数据库范式是设计关系型数据库的规范。',
        referenceAnswer: '第一范式(1NF)：属性不可再分；第二范式(2NF)：在1NF基础上，非主属性完全依赖于主键；第三范式(3NF)：在2NF基础上，非主属性不传递依赖于主键。'
      },
      {
        id: 'Q017', type: 'single', typeName: '单选题', typeIcon: 'fa-dot-circle', typeColor: 'info',
        difficulty: 2, difficultyName: '二级', knowledgeId: '12', knowledgePath: '计算机基础 / 操作系统',
        content: '以下哪个不是进程调度算法？',
        tags: ['操作系统', '调度'], createTime: '2026-01-17 10:15', author: '张老师', useCount: 10,
        score: '2', explanation: '冒泡排序是排序算法，不是进程调度算法。',
        options: [{ label: 'A', text: '先来先服务(FCFS)' }, { label: 'B', text: '短作业优先(SJF)' }, { label: 'C', text: '冒泡排序' }, { label: 'D', text: '时间片轮转' }],
        correctAnswers: ['C']
      },
      {
        id: 'Q018', type: 'blank', typeName: '填空题', typeIcon: 'fa-pen', typeColor: 'primary',
        difficulty: 2, difficultyName: '二级', knowledgeId: '23', knowledgePath: '编程语言 / JavaScript',
        content: 'JavaScript中使用_____关键字声明块级作用域变量。',
        tags: ['JavaScript', '变量'], createTime: '2026-01-17 11:30', author: '李老师', useCount: 12,
        score: '2', explanation: 'let和const都可以声明块级作用域变量，let是最常用的。',
        blanks: [{ index: 1, answer: 'let', score: 2 }]
      },
      {
        id: 'Q019', type: 'multiple', typeName: '多选题', typeIcon: 'fa-check-double', typeColor: 'success',
        difficulty: 3, difficultyName: '三级', knowledgeId: '13', knowledgePath: '计算机基础 / 数据结构',
        content: '以下哪些是线性数据结构？',
        tags: ['数据结构', '线性结构'], createTime: '2026-01-17 13:20', author: '赵老师', useCount: 6,
        score: '3', explanation: '数组、链表、栈、队列都是线性数据结构，二叉树是非线性结构。',
        options: [{ label: 'A', text: '数组' }, { label: 'B', text: '链表' }, { label: 'C', text: '二叉树' }, { label: 'D', text: '栈' }],
        correctAnswers: ['A', 'B', 'D']
      },
      {
        id: 'Q020', type: 'judge', typeName: '判断题', typeIcon: 'fa-check', typeColor: 'warning',
        difficulty: 1, difficultyName: '一级', knowledgeId: '31', knowledgePath: '数据库 / SQL语法',
        content: 'SELECT语句中WHERE子句用于分组。',
        tags: ['SQL', '查询'], createTime: '2026-01-17 14:40', author: '王老师', useCount: 15,
        score: '1', explanation: 'WHERE子句用于过滤条件，GROUP BY子句用于分组。',
        correctAnswer: 'false'
      },
      {
        id: 'Q021', type: 'single', typeName: '单选题', typeIcon: 'fa-dot-circle', typeColor: 'info',
        difficulty: 2, difficultyName: '二级', knowledgeId: '42', knowledgePath: '网络技术 / 网络安全',
        content: '以下哪种加密算法是非对称加密？',
        tags: ['网络安全', '加密'], createTime: '2026-01-17 15:50', author: '周老师', useCount: 9,
        score: '2', explanation: 'RSA是非对称加密算法，使用公钥和私钥进行加解密。',
        options: [{ label: 'A', text: 'AES' }, { label: 'B', text: 'DES' }, { label: 'C', text: 'RSA' }, { label: 'D', text: 'MD5' }],
        correctAnswers: ['C']
      },
      {
        id: 'Q022', type: 'blank', typeName: '填空题', typeIcon: 'fa-pen', typeColor: 'primary',
        difficulty: 2, difficultyName: '二级', knowledgeId: '11', knowledgePath: '计算机基础 / 计算机系统',
        content: '计算机的五大基本组成部分包括：运算器、控制器、存储器、_____和输出设备。',
        tags: ['计算机系统', '组成'], createTime: '2026-01-18 09:10', author: '张老师', useCount: 11,
        score: '2', explanation: '计算机五大部件：运算器、控制器、存储器、输入设备、输出设备。',
        blanks: [{ index: 1, answer: '输入设备', score: 2 }]
      },
      {
        id: 'Q023', type: 'multiple', typeName: '多选题', typeIcon: 'fa-check-double', typeColor: 'success',
        difficulty: 3, difficultyName: '三级', knowledgeId: '22', knowledgePath: '编程语言 / Java基础',
        content: 'Java中的访问修饰符有哪些？',
        tags: ['Java', '访问控制'], createTime: '2026-01-18 10:25', author: '孙老师', useCount: 8,
        score: '3', explanation: 'Java有四种访问修饰符：public、protected、default(无修饰符)、private。',
        options: [{ label: 'A', text: 'public' }, { label: 'B', text: 'protected' }, { label: 'C', text: 'private' }, { label: 'D', text: 'static' }],
        correctAnswers: ['A', 'B', 'C']
      },
      {
        id: 'Q024', type: 'short', typeName: '简答题', typeIcon: 'fa-align-left', typeColor: 'purple',
        difficulty: 4, difficultyName: '四级', knowledgeId: '12', knowledgePath: '计算机基础 / 操作系统',
        content: '请解释操作系统中的死锁及其产生的四个必要条件。',
        tags: ['操作系统', '死锁'], createTime: '2026-01-18 11:40', author: '张老师', useCount: 5,
        score: '6', explanation: '死锁是操作系统中的重要概念。',
        referenceAnswer: '死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种互相等待的现象。四个必要条件：1.互斥条件；2.请求与保持条件；3.不可剥夺条件；4.循环等待条件。'
      },
      {
        id: 'Q025', type: 'judge', typeName: '判断题', typeIcon: 'fa-check', typeColor: 'warning',
        difficulty: 1, difficultyName: '一级', knowledgeId: '23', knowledgePath: '编程语言 / JavaScript',
        content: 'JavaScript是一种单线程语言。',
        tags: ['JavaScript', '特性'], createTime: '2026-01-18 13:15', author: '李老师', useCount: 17,
        score: '1', explanation: 'JavaScript是单线程语言，但通过事件循环机制可以实现异步操作。',
        correctAnswer: 'true'
      },
      {
        id: 'Q026', type: 'single', typeName: '单选题', typeIcon: 'fa-dot-circle', typeColor: 'info',
        difficulty: 2, difficultyName: '二级', knowledgeId: '32', knowledgePath: '数据库 / 数据库设计',
        content: '以下哪个不是关系型数据库的特点？',
        tags: ['数据库', '关系型'], createTime: '2026-01-18 14:30', author: '王老师', useCount: 10,
        score: '2', explanation: '关系型数据库使用表格存储数据，支持SQL查询，有严格的数据模式。',
        options: [{ label: 'A', text: '使用表格存储数据' }, { label: 'B', text: '支持SQL查询' }, { label: 'C', text: '无模式设计' }, { label: 'D', text: '支持事务' }],
        correctAnswers: ['C']
      },
      {
        id: 'Q027', type: 'blank', typeName: '填空题', typeIcon: 'fa-pen', typeColor: 'primary',
        difficulty: 2, difficultyName: '二级', knowledgeId: '41', knowledgePath: '网络技术 / 网络协议',
        content: 'TCP/IP模型中，负责端到端通信的是_____层。',
        tags: ['网络协议', 'TCP/IP'], createTime: '2026-01-18 15:45', author: '周老师', useCount: 13,
        score: '2', explanation: '传输层负责端到端的通信，主要协议有TCP和UDP。',
        blanks: [{ index: 1, answer: '传输', score: 2 }]
      },
      {
        id: 'Q028', type: 'multiple', typeName: '多选题', typeIcon: 'fa-check-double', typeColor: 'success',
        difficulty: 3, difficultyName: '三级', knowledgeId: '21', knowledgePath: '编程语言 / Python基础',
        content: 'Python中以下哪些是可迭代对象？',
        tags: ['Python', '迭代'], createTime: '2026-01-19 09:00', author: '李老师', useCount: 7,
        score: '3', explanation: '列表、字符串、字典都是可迭代对象，整数不是。',
        options: [{ label: 'A', text: '列表' }, { label: 'B', text: '字符串' }, { label: 'C', text: '整数' }, { label: 'D', text: '字典' }],
        correctAnswers: ['A', 'B', 'D']
      },
      {
        id: 'Q029', type: 'judge', typeName: '判断题', typeIcon: 'fa-check', typeColor: 'warning',
        difficulty: 1, difficultyName: '一级', knowledgeId: '13', knowledgePath: '计算机基础 / 数据结构',
        content: '链表是一种顺序存储的数据结构。',
        tags: ['数据结构', '链表'], createTime: '2026-01-19 10:20', author: '赵老师', useCount: 12,
        score: '1', explanation: '链表是链式存储结构，不是顺序存储。数组才是顺序存储。',
        correctAnswer: 'false'
      },
      {
        id: 'Q030', type: 'short', typeName: '简答题', typeIcon: 'fa-align-left', typeColor: 'purple',
        difficulty: 3, difficultyName: '三级', knowledgeId: '31', knowledgePath: '数据库 / SQL语法',
        content: '请说明SQL中JOIN的几种类型及其区别。',
        tags: ['SQL', 'JOIN'], createTime: '2026-01-19 11:35', author: '王老师', useCount: 9,
        score: '5', explanation: 'JOIN是SQL中用于连接多个表的操作。',
        referenceAnswer: 'INNER JOIN：返回两表匹配的行；LEFT JOIN：返回左表所有行，右表匹配的行；RIGHT JOIN：返回右表所有行，左表匹配的行；FULL JOIN：返回两表所有行。'
      },
      {
        id: 'Q031', type: 'single', typeName: '单选题', typeIcon: 'fa-dot-circle', typeColor: 'info',
        difficulty: 2, difficultyName: '二级', knowledgeId: '22', knowledgePath: '编程语言 / Java基础',
        content: 'Java中的垃圾回收机制主要针对什么内存区域？',
        tags: ['Java', 'GC'], createTime: '2026-01-19 13:10', author: '孙老师', useCount: 6,
        score: '2', explanation: 'Java垃圾回收主要针对堆内存中不再使用的对象。',
        options: [{ label: 'A', text: '栈内存' }, { label: 'B', text: '堆内存' }, { label: 'C', text: '方法区' }, { label: 'D', text: '程序计数器' }],
        correctAnswers: ['B']
      },
      {
        id: 'Q032', type: 'blank', typeName: '填空题', typeIcon: 'fa-pen', typeColor: 'primary',
        difficulty: 2, difficultyName: '二级', knowledgeId: '42', knowledgePath: '网络技术 / 网络安全',
        content: '_____是一种用于验证用户身份的安全机制。',
        tags: ['网络安全', '认证'], createTime: '2026-01-19 14:25', author: '周老师', useCount: 11,
        score: '2', explanation: '身份认证是验证用户身份的安全机制。',
        blanks: [{ index: 1, answer: '身份认证', score: 2 }]
      },
      {
        id: 'Q033', type: 'multiple', typeName: '多选题', typeIcon: 'fa-check-double', typeColor: 'success',
        difficulty: 3, difficultyName: '三级', knowledgeId: '12', knowledgePath: '计算机基础 / 操作系统',
        content: '以下哪些是操作系统的主要功能？',
        tags: ['操作系统', '功能'], createTime: '2026-01-19 15:40', author: '张老师', useCount: 8,
        score: '3', explanation: '操作系统的主要功能包括进程管理、内存管理、文件管理、设备管理。',
        options: [{ label: 'A', text: '进程管理' }, { label: 'B', text: '内存管理' }, { label: 'C', text: '编译程序' }, { label: 'D', text: '文件管理' }],
        correctAnswers: ['A', 'B', 'D']
      },
      {
        id: 'Q034', type: 'judge', typeName: '判断题', typeIcon: 'fa-check', typeColor: 'warning',
        difficulty: 1, difficultyName: '一级', knowledgeId: '32', knowledgePath: '数据库 / 数据库设计',
        content: 'NoSQL数据库不支持事务处理。',
        tags: ['数据库', 'NoSQL'], createTime: '2026-01-19 16:55', author: '王老师', useCount: 14,
        score: '1', explanation: '部分NoSQL数据库支持事务处理，如MongoDB 4.0+支持多文档事务。',
        correctAnswer: 'false'
      },
      {
        id: 'Q035', type: 'short', typeName: '简答题', typeIcon: 'fa-align-left', typeColor: 'purple',
        difficulty: 4, difficultyName: '四级', knowledgeId: '23', knowledgePath: '编程语言 / JavaScript',
        content: '请解释JavaScript中的事件循环机制。',
        tags: ['JavaScript', '事件循环'], createTime: '2026-01-19 17:20', author: '李老师', useCount: 4,
        score: '6', explanation: '事件循环是JavaScript实现异步的核心机制。',
        referenceAnswer: '事件循环是JavaScript的执行机制。主线程执行同步代码，异步任务放入任务队列。主线程空闲时，从任务队列取出任务执行。宏任务包括setTimeout、setInterval等，微任务包括Promise.then等，微任务优先于宏任务执行。'
      },
      {
        id: 'Q036', type: 'single', typeName: '单选题', typeIcon: 'fa-dot-circle', typeColor: 'info',
        difficulty: 2, difficultyName: '二级', knowledgeId: '11', knowledgePath: '计算机基础 / 计算机系统',
        content: '以下哪个是主存储器？',
        tags: ['计算机系统', '存储'], createTime: '2026-01-19 18:05', author: '张老师', useCount: 15,
        score: '2', explanation: '内存(RAM)是主存储器，硬盘、U盘、光盘是外存储器。',
        options: [{ label: 'A', text: '硬盘' }, { label: 'B', text: '内存' }, { label: 'C', text: 'U盘' }, { label: 'D', text: '光盘' }],
        correctAnswers: ['B']
      },
      {
        id: 'Q037', type: 'blank', typeName: '填空题', typeIcon: 'fa-pen', typeColor: 'primary',
        difficulty: 2, difficultyName: '二级', knowledgeId: '21', knowledgePath: '编程语言 / Python基础',
        content: 'Python中使用_____函数可以获取列表的长度。',
        tags: ['Python', '列表'], createTime: '2026-01-19 19:15', author: '李老师', useCount: 10,
        score: '2', explanation: 'len()函数用于获取序列（列表、字符串等）的长度。',
        blanks: [{ index: 1, answer: 'len', score: 2 }]
      },
      {
        id: 'Q038', type: 'multiple', typeName: '多选题', typeIcon: 'fa-check-double', typeColor: 'success',
        difficulty: 3, difficultyName: '三级', knowledgeId: '41', knowledgePath: '网络技术 / 网络协议',
        content: '以下哪些是传输层协议？',
        tags: ['网络协议', '传输层'], createTime: '2026-01-19 20:30', author: '周老师', useCount: 7,
        score: '3', explanation: 'TCP和UDP是传输层协议，HTTP和FTP是应用层协议。',
        options: [{ label: 'A', text: 'TCP' }, { label: 'B', text: 'UDP' }, { label: 'C', text: 'HTTP' }, { label: 'D', text: 'FTP' }],
        correctAnswers: ['A', 'B']
      },
      // ==================== 包含图片和公式的示例题目 ====================
      {
        id: 'Q039', type: 'single', typeName: '单选题', typeIcon: 'fa-dot-circle', typeColor: 'info',
        difficulty: 3, difficultyName: '三级', knowledgeId: '13', knowledgePath: '计算机基础 / 数据结构',
        content: '观察下图所示的二叉树结构：<br><br><img src="images/binary-tree.svg" alt="二叉树结构图" style="max-width:100%;border-radius:8px;border:1px solid #e5e7eb;"><br><br>该二叉树的中序遍历结果是？<br><br>已知前序遍历为：A, B, D, E, C, F<br>后序遍历为：D, E, B, F, C, A',
        tags: ['二叉树', '遍历', '图片题'], createTime: '2026-01-20 09:00', author: '张老师', useCount: 3,
        score: '3', explanation: '中序遍历顺序为：左子树 → 根节点 → 右子树。<br><br><img src="images/binary-tree.svg" alt="中序遍历示意图" style="max-width:100%;border-radius:8px;">',
        options: [
          { label: 'A', text: 'D, B, E, A, F, C' },
          { label: 'B', text: 'A, B, D, E, C, F' },
          { label: 'C', text: 'D, E, B, F, C, A' },
          { label: 'D', text: 'A, B, C, D, E, F' }
        ],
        correctAnswers: ['A']
      },
      {
        id: 'Q040', type: 'multiple', typeName: '多选题', typeIcon: 'fa-check-double', typeColor: 'success',
        difficulty: 4, difficultyName: '四级', knowledgeId: '13', knowledgePath: '计算机基础 / 数据结构',
        content: '根据下图所示的图结构，回答问题：<br><br><img src="images/graph-structure.svg" alt="带权图结构" style="max-width:100%;border-radius:8px;border:1px solid #e5e7eb;"><br><br>以下关于该图的描述，正确的有哪些？<br><br>图中边的权重公式为：<code>W(u,v) = |u - v| × 2</code>',
        tags: ['图论', '最短路径', '图片题'], createTime: '2026-01-20 09:30', author: '李老师', useCount: 5,
        score: '4', explanation: '图的分析需要考虑连通性、权重和路径。<br><br>最短路径算法公式：<br><code>d[v] = min(d[v], d[u] + w(u,v))</code><br><br><img src="images/graph-structure.svg" alt="Dijkstra算法示意" style="max-width:100%;border-radius:8px;">',
        options: [
          { label: 'A', text: '该图是连通图' },
          { label: 'B', text: '该图是有向图' },
          { label: 'C', text: '从A到E的最短路径经过B' },
          { label: 'D', text: '该图包含环' }
        ],
        correctAnswers: ['A', 'C', 'D']
      },
      {
        id: 'Q041', type: 'blank', typeName: '填空题', typeIcon: 'fa-pen', typeColor: 'primary',
        difficulty: 3, difficultyName: '三级', knowledgeId: '13', knowledgePath: '计算机基础 / 数据结构',
        content: '观察下图中的排序过程：<br><br><img src="images/sorting-process.svg" alt="排序过程示意图" style="max-width:100%;border-radius:8px;border:1px solid #e5e7eb;"><br><br>该排序算法的时间复杂度为 O(_______)，空间复杂度为 O(_______)。<br><br>时间复杂度计算公式：<code>T(n) = n × (n-1) / 2 = O(n²)</code>',
        tags: ['排序', '复杂度', '图片题'], createTime: '2026-01-20 10:00', author: '王老师', useCount: 8,
        score: '4', explanation: '从图中可以看出这是冒泡排序的过程。<br><br>复杂度分析：<br>• 时间复杂度：最坏情况下需要比较 <code>n(n-1)/2</code> 次<br>• 空间复杂度：只需要常数级别的额外空间<br><br><img src="images/sorting-process.svg" alt="冒泡排序复杂度" style="max-width:100%;border-radius:8px;">',
        blanks: [
          { index: 1, answer: 'n²', score: 2 },
          { index: 2, answer: '1', score: 2 }
        ]
      },
      {
        id: 'Q042', type: 'short', typeName: '简答题', typeIcon: 'fa-align-left', typeColor: 'purple',
        difficulty: 4, difficultyName: '四级', knowledgeId: '13', knowledgePath: '计算机基础 / 数据结构',
        content: '观察下图所示的哈希表结构和冲突情况：<br><br><img src="images/hash-table.svg" alt="哈希表冲突示意图" style="max-width:100%;border-radius:8px;border:1px solid #e5e7eb;"><br><br>哈希函数为：<code>h(key) = key mod 10</code><br><br>请回答：<br>1. 分析图中哈希冲突产生的原因<br>2. 说明链地址法如何解决该冲突<br>3. 计算装载因子 α = n/m 对性能的影响',
        tags: ['哈希表', '冲突处理', '图片题'], createTime: '2026-01-20 10:30', author: '赵老师', useCount: 4,
        score: '10', explanation: '哈希冲突是哈希表设计中的核心问题。',
        referenceAnswer: '1. 冲突原因分析：\n当不同的键值通过哈希函数 h(key) = key mod 10 计算后得到相同的哈希值时，就会产生冲突。如图所示，键值 13 和 23 都映射到桶 3。\n\n<img src="images/hash-table.svg" alt="哈希冲突示例" style="max-width:100%;border-radius:8px;margin:10px 0;">\n\n2. 链地址法解决方案：\n• 每个桶维护一个链表\n• 冲突的元素依次添加到链表末尾\n• 查找时遍历对应桶的链表\n\n3. 装载因子影响：\n• α = n/m（n为元素数，m为桶数）\n• α 越大，冲突概率越高\n• 建议保持 α < 0.75\n• 查找时间复杂度：O(1 + α)'
      },
      {
        id: 'Q043', type: 'materialAnalysis', typeName: '材料分析', typeIcon: 'fa-layer-group', typeColor: 'purple',
        difficulty: 5, difficultyName: '五级', knowledgeId: '13', knowledgePath: '计算机基础 / 数据结构',
        content: '【算法分析综合题】<br><br>阅读以下材料，观察图示，回答问题。<br><br><strong>材料：</strong>某电商平台需要实现商品推荐系统，使用图结构存储用户-商品关系。<br><br><img src="images/social-network.svg" alt="用户-商品关系图" style="max-width:100%;border-radius:8px;border:1px solid #e5e7eb;"><br><br>图中边的权重表示购买次数，推荐算法基于协同过滤：<br><code>Score(u,p) = Σ sim(u,v) × r(v,p)</code><br><br>其中 sim(u,v) 为用户相似度，r(v,p) 为用户v对商品p的评分。',
        tags: ['图算法', '推荐系统', '综合题', '图片题'], isComposite: true, subCount: 4,
        createTime: '2026-01-20 11:00', author: '钱老师', useCount: 2,
        score: '20', explanation: '本题考查图结构在实际应用中的使用，以及算法复杂度分析能力。',
        subQuestions: [
          {
            id: 1, type: 'single', content: '根据图示，该图结构属于什么类型？',
            score: 3,
            options: [
              { label: 'A', text: '有向无权图' },
              { label: 'B', text: '无向有权图' },
              { label: 'C', text: '二分图（Bipartite Graph）' },
              { label: 'D', text: '完全图' }
            ],
            correctAnswers: ['C'],
            explanation: '用户和商品是两类不同的节点，边只存在于不同类节点之间，符合二分图定义。<br><img src="https://via.placeholder.com/300x150/dbeafe/1d4ed8?text=Bipartite+Graph" alt="二分图示意" style="max-width:100%;border-radius:8px;">'
          },
          {
            id: 2, type: 'multiple', content: '以下关于该推荐算法的描述，正确的有？',
            score: 4,
            options: [
              { label: 'A', text: '时间复杂度与用户数量相关' },
              { label: 'B', text: '需要计算用户间的相似度矩阵' },
              { label: 'C', text: '属于基于内容的推荐算法' },
              { label: 'D', text: '可以发现用户的潜在兴趣' }
            ],
            correctAnswers: ['A', 'B', 'D'],
            explanation: '协同过滤是基于用户行为的推荐算法，不是基于内容的。'
          },
          {
            id: 3, type: 'blank', content: '如果用户数为 n，商品数为 m，计算所有用户相似度的时间复杂度为 O(_____)，空间复杂度为 O(_____)。',
            score: 4,
            blanks: [
              { index: 1, answer: 'n²m', score: 2 },
              { index: 2, answer: 'n²', score: 2 }
            ],
            explanation: '需要计算 n×n 的相似度矩阵，每次计算需要遍历 m 个商品。'
          },
          {
            id: 4, type: 'shortAnswer', content: '请根据图示数据，说明如何优化该推荐系统的性能，并给出具体方案。',
            score: 9,
            referenceAnswer: '优化方案：\n\n1. 数据结构优化：\n<img src="https://via.placeholder.com/350x180/fef3c7/d97706?text=Sparse+Matrix+Storage" alt="稀疏矩阵存储" style="max-width:100%;border-radius:8px;margin:10px 0;">\n• 使用稀疏矩阵存储用户-商品关系\n• 采用邻接表代替邻接矩阵\n\n2. 算法优化：\n• 预计算用户相似度矩阵\n• 使用 LSH（局部敏感哈希）加速相似度计算\n• 只保留 Top-K 相似用户\n\n3. 系统优化：\n• 增量更新而非全量计算\n• 使用缓存存储热门推荐结果\n• 分布式计算处理大规模数据\n\n复杂度改进：\n• 时间：O(n²m) → O(nk·m)，k为相似用户数\n• 空间：O(n²) → O(nk)',
            explanation: '推荐系统优化需要从数据结构、算法和系统架构多个层面考虑。'
          }
        ]
      }
    ];

    let filteredQuestions = [...allQuestions];

    // 分页变量
    let currentPage = 1;
    const pageSize = 20;

    let nextId = 100; // 用于生成新节点的ID
    let draggedNode = null; // 被拖拽的节点
    let draggedNodeParent = null; // 被拖拽节点的父节点
    let moveTargetNode = null; // 移动目标节点

    // ==================== 渲染函数 ====================

    // 渲染整个知识点树
    function renderKnowledgeTree() {
      const container = document.getElementById('knowledgeTreeContainer');
      container.innerHTML = '';

      // 如果有搜索关键词，过滤节点
      const nodesToRender = searchKeyword
        ? knowledgeTree.filter(node => matchesSearch(node, searchKeyword))
        : knowledgeTree;

      nodesToRender.forEach((node, index) => {
        container.appendChild(createNodeElement(node, null, index));
      });

      // 如果搜索后没有结果，显示提示
      if (nodesToRender.length === 0 && searchKeyword) {
        const noResult = document.createElement('div');
        noResult.className = 'text-center text-gray-400 py-8';
        noResult.innerHTML = '<i class="fas fa-search text-2xl mb-2"></i><p class="text-sm">未找到匹配的知识点</p>';
        container.appendChild(noResult);
      }
    }

    // 创建节点元素（递归）
    function createNodeElement(node, parentNode, index) {
      const wrapper = document.createElement('div');
      wrapper.className = 'knowledge-node-wrapper';
      wrapper.dataset.nodeId = node.id;

      // 主节点
      const nodeDiv = document.createElement('div');
      nodeDiv.className = 'tree-item px-3 py-2 rounded-lg cursor-pointer flex items-center justify-between group';
      nodeDiv.draggable = true;
      nodeDiv.dataset.nodeId = node.id;

      // 设置拖拽事件
      nodeDiv.addEventListener('dragstart', (e) => handleDragStart(e, node, parentNode));
      nodeDiv.addEventListener('dragover', (e) => handleDragOver(e));
      nodeDiv.addEventListener('drop', (e) => handleDrop(e, node));
      nodeDiv.addEventListener('dragend', () => handleDragEnd());

      // 点击节点筛选题目
      nodeDiv.addEventListener('click', function() {
        selectKnowledgeNode(node.id, node.name);
        nodeDiv.classList.add('active');
      });

      // 点击节点筛选题目
      nodeDiv.addEventListener('click', function() {
        selectKnowledgeNode(node.id, node.name);
        nodeDiv.classList.add('active');
      });

      // 左侧内容
      const leftDiv = document.createElement('div');
      leftDiv.className = 'flex items-center space-x-2 flex-1';

      // 如果有子节点，显示展开/收起图标
      if (node.children && node.children.length > 0) {
        const chevron = document.createElement('i');
        // 搜索时自动展开，显示向下箭头
        const isExpanded = searchKeyword ? true : !node.collapsed;
        chevron.className = `fas ${isExpanded ? 'fa-chevron-down' : 'fa-chevron-right'} text-xs text-gray-400 transition-transform`;
        chevron.onclick = (e) => {
          e.stopPropagation();
          // 搜索模式下不允许折叠
          if (!searchKeyword) {
            toggleNode(node.id);
          }
        };
        leftDiv.appendChild(chevron);
      } else {
        // 空白占位
        const spacer = document.createElement('span');
        spacer.style.width = '12px';
        leftDiv.appendChild(spacer);
      }

      // 图标：目录用文件夹，知识点用书本
      const icon = document.createElement('i');
      const colors = ['text-warning-500', 'text-info-500', 'text-success-500', 'text-error-500', 'text-purple-500'];
      if (node.type === 'knowledge') {
        // 知识点用书本图标
        icon.className = `fas fa-book text-primary-500`;
      } else {
        // 目录用文件夹图标
        icon.className = `fas fa-folder ${colors[index % colors.length]}`;
      }
      leftDiv.appendChild(icon);

      // 名称（可编辑）
      const nameSpan = document.createElement('span');
      nameSpan.className = 'text-sm node-name';

      // 如果有搜索关键词，高亮显示
      if (searchKeyword && node.name.toLowerCase().includes(searchKeyword)) {
        const regex = new RegExp(`(${searchKeyword})`, 'gi');
        const highlightedName = node.name.replace(regex, '<mark class="bg-yellow-200 text-gray-900">$1</mark>');
        nameSpan.innerHTML = highlightedName;
      } else {
        nameSpan.textContent = node.name;
      }

      nameSpan.dataset.nodeId = node.id;
      leftDiv.appendChild(nameSpan);

      // 编辑输入框（隐藏）
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'hidden text-sm px-2 py-1 border border-primary-500 rounded focus:outline-none focus:ring-1 focus:ring-primary-500 node-input';
      input.value = node.name;
      input.dataset.nodeId = node.id;
      input.addEventListener('blur', () => finishEditing(node.id));
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          finishEditing(node.id);
        } else if (e.key === 'Escape') {
          cancelEditing(node.id);
        }
      });
      leftDiv.appendChild(input);

      nodeDiv.appendChild(leftDiv);

      // 右侧操作按钮
      const rightDiv = document.createElement('div');
      rightDiv.className = 'flex items-center space-x-2';

      // 题目数量（悬停时隐藏）
      const countSpan = document.createElement('span');
      countSpan.className = 'text-xs text-gray-500 group-hover:hidden';
      countSpan.textContent = node.count || 0;
      rightDiv.appendChild(countSpan);

      // 操作按钮组（悬停显示）
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'hidden group-hover:flex items-center space-x-1 ml-2';
      actionsDiv.onclick = (e) => e.stopPropagation();

      // 如果是目录节点，显示添加子目录和添加知识点按钮
      if (node.type === 'directory') {
        // 添加子目录
        const addDirBtn = createActionButton('fa-folder-plus', 'success', '添加子目录', () => addChildDirectory(node.id));
        actionsDiv.appendChild(addDirBtn);

        // 添加知识点
        const addKnowledgeBtn = createActionButton('fa-plus', 'success', '添加知识点', () => addChildKnowledge(node.id));
        actionsDiv.appendChild(addKnowledgeBtn);
      }
      // 知识点节点不显示添加按钮

      // 编辑
      const editBtn = createActionButton('fa-edit', 'info', '编辑', () => startEditing(node.id));
      actionsDiv.appendChild(editBtn);

      // 移动
      const moveBtn = createActionButton('fa-arrows-alt', 'warning', '移动位置', () => openMoveModal(node.id, parentNode));
      actionsDiv.appendChild(moveBtn);

      // 删除
      const deleteBtn = createActionButton('fa-trash', 'error', '删除', () => deleteNode(node.id, parentNode));
      actionsDiv.appendChild(deleteBtn);

      rightDiv.appendChild(actionsDiv);
      nodeDiv.appendChild(rightDiv);

      wrapper.appendChild(nodeDiv);

      // 子节点（递归）
      if (node.children && node.children.length > 0) {
        // 搜索模式下，过滤子节点并自动展开
        const shouldExpand = searchKeyword ? true : !node.collapsed;
        const childrenToRender = searchKeyword
          ? node.children.filter(child => matchesSearch(child, searchKeyword))
          : node.children;

        if (childrenToRender.length > 0 && shouldExpand) {
          const childrenContainer = document.createElement('div');
          childrenContainer.className = 'ml-6 mt-1 space-y-1';
          childrenToRender.forEach((child, childIndex) => {
            childrenContainer.appendChild(createNodeElement(child, node, childIndex));
          });
          wrapper.appendChild(childrenContainer);
        }
      }

      return wrapper;
    }

    // 创建操作按钮
    function createActionButton(icon, color, title, onclick) {
      const btn = document.createElement('button');
      btn.className = `w-6 h-6 flex items-center justify-center text-gray-400 hover:text-${color}-600 hover:bg-${color}-50 rounded transition-colors`;
      btn.title = title;
      btn.onclick = (e) => {
        e.stopPropagation();
        onclick();
      };

      const iconEl = document.createElement('i');
      iconEl.className = `fas ${icon} text-xs`;
      btn.appendChild(iconEl);

      return btn;
    }

    // ==================== 数据持久化 ====================

    // 保存知识点树到 localStorage
    function saveKnowledgeTreeToStorage() {
      try {
        localStorage.setItem('knowledgePoints', JSON.stringify(knowledgeTree));
        console.log('知识点树已保存到 localStorage');
      } catch (e) {
        console.error('保存知识点树失败:', e);
      }
    }

    // 从 localStorage 加载知识点树
    function loadKnowledgeTreeFromStorage() {
      try {
        const saved = localStorage.getItem('knowledgePoints');
        if (saved) {
          knowledgeTree = JSON.parse(saved);
          console.log('从 localStorage 加载知识点树:', knowledgeTree);

          // 更新 nextId，确保不会产生重复ID
          let maxId = 0;
          function findMaxId(nodes) {
            nodes.forEach(node => {
              if (node.id > maxId) maxId = node.id;
              if (node.children && node.children.length > 0) {
                findMaxId(node.children);
              }
            });
          }
          findMaxId(knowledgeTree);
          nextId = maxId + 1;
        } else {
          console.log('localStorage 中没有知识点数据，使用默认数据');
          // 首次加载时保存默认数据
          saveKnowledgeTreeToStorage();
        }
      } catch (e) {
        console.error('加载知识点树失败:', e);
      }
    }

    // ==================== 节点操作 ====================

    // 切换展开/收起
    function toggleNode(nodeId) {
      const node = findNode(nodeId);
      if (node) {
        node.collapsed = !node.collapsed;
        renderKnowledgeTree();
      }
    }

    // 添加根目录
    function addRootDirectory() {
      const newNode = {
        id: nextId++,
        name: '',
        type: 'directory',  // 根节点目录
        count: 0,
        collapsed: false,
        children: [],
        isNew: true
      };
      knowledgeTree.push(newNode);
      saveKnowledgeTreeToStorage(); // 保存到 localStorage
      renderKnowledgeTree();

      // 自动进入编辑状态
      setTimeout(() => startEditing(newNode.id), 50);
    }

    // 添加根知识点
    function addRootKnowledgePoint() {
      const newNode = {
        id: nextId++,
        name: '',
        type: 'knowledge',  // 根节点知识点
        count: 0,
        children: [],  // 知识点没有子节点
        isNew: true
      };
      knowledgeTree.push(newNode);
      saveKnowledgeTreeToStorage(); // 保存到 localStorage
      renderKnowledgeTree();

      // 自动进入编辑状态
      setTimeout(() => startEditing(newNode.id), 50);
    }

    // 兼容旧代码
    function addRootKnowledge() {
      addRootDirectory();
    }

    // 添加子目录
    function addChildDirectory(parentId) {
      const parent = findNode(parentId);
      if (parent) {
        if (!parent.children) {
          parent.children = [];
        }
        const newNode = {
          id: nextId++,
          name: '',
          type: 'directory',
          count: 0,
          collapsed: false,
          children: [],
          isNew: true
        };
        parent.children.push(newNode);
        parent.collapsed = false; // 展开父节点
        saveKnowledgeTreeToStorage(); // 保存到 localStorage
        renderKnowledgeTree();

        // 自动进入编辑状态
        setTimeout(() => startEditing(newNode.id), 50);
      }
    }

    // 添加知识点（叶子节点）
    function addChildKnowledge(parentId) {
      const parent = findNode(parentId);
      if (parent) {
        if (!parent.children) {
          parent.children = [];
        }
        const newNode = {
          id: nextId++,
          name: '',
          type: 'knowledge',  // 知识点类型
          count: 0,
          children: [],  // 知识点不能有子节点
          isNew: true
        };
        parent.children.push(newNode);
        parent.collapsed = false; // 展开父节点
        saveKnowledgeTreeToStorage(); // 保存到 localStorage
        renderKnowledgeTree();

        // 自动进入编辑状态
        setTimeout(() => startEditing(newNode.id), 50);
      }
    }

    // 添加子知识点（兼容旧代码，实际调用 addChildKnowledge）
    function addChildNode(parentId) {
      addChildKnowledge(parentId);
    }

    // 开始编辑
    function startEditing(nodeId) {
      const nameSpan = document.querySelector(`.node-name[data-node-id="${nodeId}"]`);
      const input = document.querySelector(`.node-input[data-node-id="${nodeId}"]`);

      if (nameSpan && input) {
        nameSpan.classList.add('hidden');
        input.classList.remove('hidden');
        input.focus();
        input.select();
      }
    }

    // 完成编辑
    function finishEditing(nodeId) {
      const input = document.querySelector(`.node-input[data-node-id="${nodeId}"]`);
      const nameSpan = document.querySelector(`.node-name[data-node-id="${nodeId}"]`);

      if (input && nameSpan) {
        const newName = input.value.trim();
        if (newName) {
          const node = findNode(nodeId);
          if (node) {
            node.name = newName;
            node.isNew = false;
            nameSpan.textContent = newName;
            saveKnowledgeTreeToStorage(); // 保存到 localStorage
          }
        } else if (findNode(nodeId)?.isNew) {
          // 如果是新建节点且名称为空，删除它
          deleteNodeById(nodeId);
          renderKnowledgeTree();
          return;
        }

        input.classList.add('hidden');
        nameSpan.classList.remove('hidden');
      }
    }

    // 取消编辑
    function cancelEditing(nodeId) {
      const node = findNode(nodeId);
      if (node?.isNew) {
        // 新建节点取消时删除
        deleteNodeById(nodeId);
        renderKnowledgeTree();
      } else {
        const input = document.querySelector(`.node-input[data-node-id="${nodeId}"]`);
        const nameSpan = document.querySelector(`.node-name[data-node-id="${nodeId}"]`);

        if (input && nameSpan && node) {
          input.value = node.name;
          input.classList.add('hidden');
          nameSpan.classList.remove('hidden');
        }
      }
    }

    // 删除节点
    function deleteNode(nodeId, parentNode) {
      const node = findNode(nodeId);
      if (!node) return;

      if (confirm(`确定要删除"${node.name}"知识点吗？\n\n删除后，该知识点下的子知识点和题目将移至"未分类"。`)) {
        deleteNodeById(nodeId);
        renderKnowledgeTree();
      }
    }

    // 根据ID删除节点（递归）
    function deleteNodeById(nodeId) {
      // 从根级别删除
      const rootIndex = knowledgeTree.findIndex(n => n.id === nodeId);
      if (rootIndex !== -1) {
        knowledgeTree.splice(rootIndex, 1);
        saveKnowledgeTreeToStorage(); // 保存到 localStorage
        return true;
      }

      // 递归查找并删除
      function deleteFromChildren(nodes) {
        for (let node of nodes) {
          if (node.children) {
            const index = node.children.findIndex(n => n.id === nodeId);
            if (index !== -1) {
              node.children.splice(index, 1);
              return true;
            }
            if (deleteFromChildren(node.children)) {
              return true;
            }
          }
        }
        return false;
      }

      const result = deleteFromChildren(knowledgeTree);
      if (result) {
        saveKnowledgeTreeToStorage(); // 保存到 localStorage
      }
      return result;
    }

    // 查找节点（递归）
    function findNode(nodeId, nodes = knowledgeTree) {
      for (let node of nodes) {
        if (node.id === nodeId) return node;
        if (node.children) {
          const found = findNode(nodeId, node.children);
          if (found) return found;
        }
      }
      return null;
    }

    // ==================== 拖拽功能 ====================

    function handleDragStart(e, node, parentNode) {
      draggedNode = node;
      draggedNodeParent = parentNode;
      e.currentTarget.style.opacity = '0.5';
      e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      e.currentTarget.style.background = '#E6F9F0';
    }

    function handleDrop(e, targetNode) {
      e.preventDefault();
      e.stopPropagation();
      e.currentTarget.style.background = '';

      if (!draggedNode || draggedNode.id === targetNode.id) return;

      // 删除原位置的节点
      deleteNodeById(draggedNode.id);

      // 添加到新位置
      if (!targetNode.children) {
        targetNode.children = [];
      }
      targetNode.children.push(draggedNode);
      targetNode.collapsed = false;

      saveKnowledgeTreeToStorage(); // 保存到 localStorage
      renderKnowledgeTree();
    }

    function handleDragEnd() {
      document.querySelectorAll('.tree-item').forEach(el => {
        el.style.opacity = '';
        el.style.background = '';
      });
      draggedNode = null;
      draggedNodeParent = null;
    }

    // ==================== 移动位置功能 ====================

    function openMoveModal(nodeId, parentNode) {
      moveTargetNode = { id: nodeId, parent: parentNode };

      // 填充目标位置下拉框
      const select = document.getElementById('moveTargetSelect');
      select.innerHTML = '<option value="root">根目录</option>';

      function addOptions(nodes, prefix = '') {
        nodes.forEach(node => {
          if (node.id !== nodeId) { // 不能移动到自己
            const option = document.createElement('option');
            option.value = node.id;
            option.textContent = prefix + node.name;
            select.appendChild(option);

            if (node.children && node.children.length > 0) {
              addOptions(node.children, prefix + '　');
            }
          }
        });
      }

      addOptions(knowledgeTree);

      document.getElementById('moveModal').classList.remove('hidden');
    }

    function closeMoveModal() {
      document.getElementById('moveModal').classList.add('hidden');
      moveTargetNode = null;
    }

    function confirmMove() {
      const targetValue = document.getElementById('moveTargetSelect').value;
      const position = parseInt(document.getElementById('movePositionInput').value) - 1;

      if (!moveTargetNode) return;

      const node = findNode(moveTargetNode.id);
      if (!node) return;

      // 删除原位置
      deleteNodeById(node.id);

      // 插入到新位置
      if (targetValue === 'root') {
        knowledgeTree.splice(Math.max(0, Math.min(position, knowledgeTree.length)), 0, node);
      } else {
        const targetNode = findNode(parseInt(targetValue));
        if (targetNode) {
          if (!targetNode.children) {
            targetNode.children = [];
          }
          targetNode.children.splice(Math.max(0, Math.min(position, targetNode.children.length)), 0, node);
          targetNode.collapsed = false;
        }
      }

      saveKnowledgeTreeToStorage(); // 保存到 localStorage
      closeMoveModal();
      renderKnowledgeTree();
    }

    // ESC键关闭弹窗
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        closeMoveModal();
      }
    });

    // ==================== 其他功能 ====================

    // 搜索知识点
    let searchKeyword = '';

    function searchKnowledge(keyword) {
      searchKeyword = keyword.trim().toLowerCase();
      renderKnowledgeTree();

      // 显示/隐藏清空按钮
      const clearBtn = document.getElementById('clearSearchBtn');
      if (searchKeyword) {
        clearBtn.classList.remove('hidden');
      } else {
        clearBtn.classList.add('hidden');
      }
    }

    // 清空搜索
    function clearSearch() {
      document.getElementById('searchInput').value = '';
      searchKnowledge('');
    }

    // ==================== 题目筛选功能 ====================

    // 当前筛选条件
    let currentFilters = {
      search: '',
      knowledge: '',
      questionTypes: [],  // 多选
      difficulties: [],   // 多选
      tag: ''
    };

    // 防抖函数
    let searchDebounceTimer = null;
    function debounce(func, delay) {
      return function(...args) {
        clearTimeout(searchDebounceTimer);
        searchDebounceTimer = setTimeout(() => func.apply(this, args), delay);
      };
    }

    // 即时搜索处理函数
    function handleInstantSearch() {
      applyFilters();
    }

    // 创建防抖的即时搜索函数（300ms延迟）
    const debouncedSearch = debounce(handleInstantSearch, 300);

    // 处理回车键搜索
    function handleEnterKey(event) {
      if (event.key === 'Enter' || event.keyCode === 13) {
        event.preventDefault(); // 阻止表单默认提交行为
        clearTimeout(searchDebounceTimer); // 取消防抖延迟
        applyFilters(); // 立即执行搜索
      }
    }

    // 点击外部关闭下拉框
    document.addEventListener('click', function(e) {
      const qtBtn = document.getElementById('questionTypeDropdownBtn');
      const qtDropdown = document.getElementById('questionTypeDropdown');
      const diffBtn = document.getElementById('difficultyDropdownBtn');
      const diffDropdown = document.getElementById('difficultyDropdown');

      if (!qtBtn?.contains(e.target) && !qtDropdown?.contains(e.target)) {
        qtDropdown?.classList.add('hidden');
      }
      if (!diffBtn?.contains(e.target) && !diffDropdown?.contains(e.target)) {
        diffDropdown?.classList.add('hidden');
      }
    });

    // 切换题型下拉框
    function toggleQuestionTypeDropdown() {
      document.getElementById('questionTypeDropdown').classList.toggle('hidden');
      document.getElementById('difficultyDropdown').classList.add('hidden');
    }

    // 切换难度下拉框
    function toggleDifficultyDropdown() {
      document.getElementById('difficultyDropdown').classList.toggle('hidden');
      document.getElementById('questionTypeDropdown').classList.add('hidden');
    }

    // 更新题型选择显示
    function updateQuestionTypeSelection() {
      const checkboxes = document.querySelectorAll('.question-type-checkbox');
      const selected = Array.from(checkboxes).filter(cb => cb.checked);
      const label = document.getElementById('questionTypeLabel');

      if (selected.length === 0) {
        label.textContent = '全部题型';
      } else if (selected.length === 1) {
        label.textContent = selected[0].nextElementSibling.textContent;
      } else {
        label.textContent = `已选${selected.length}项`;
      }
    }

    // 更新难度选择显示
    function updateDifficultySelection() {
      const checkboxes = document.querySelectorAll('.difficulty-checkbox');
      const selected = Array.from(checkboxes).filter(cb => cb.checked);
      const label = document.getElementById('difficultyLabel');

      if (selected.length === 0) {
        label.textContent = '全部难度';
      } else if (selected.length === 1) {
        label.textContent = selected[0].nextElementSibling.textContent;
      } else {
        label.textContent = `已选${selected.length}项`;
      }
    }

    // 获取节点及其所有子节点的ID列表
    function getAllNodeIds(nodeId) {
      if (!nodeId) return [];

      const node = findNode(parseInt(nodeId));
      if (!node) return [nodeId];

      const ids = [nodeId];

      function collectChildIds(node) {
        if (node.children && node.children.length > 0) {
          node.children.forEach(child => {
            ids.push(child.id.toString());
            collectChildIds(child);
          });
        }
      }

      collectChildIds(node);
      return ids;
    }

    // 更新知识点树的题目数量
    function updateKnowledgeTreeCounts() {
      const countMap = {};

      allQuestions.forEach(q => {
        const knowledgeId = q.knowledgeId;
        if (knowledgeId) {
          countMap[knowledgeId] = (countMap[knowledgeId] || 0) + 1;
        }
      });

      function updateNodeCounts(node) {
        let totalCount = 0;

        if (node.children && node.children.length > 0) {
          node.children.forEach(child => {
            updateNodeCounts(child);
            totalCount += child.count;
          });
        } else {
          totalCount = countMap[node.id.toString()] || 0;
        }

        node.count = totalCount;
      }

      knowledgeTree.forEach(node => updateNodeCounts(node));

      // 更新总题目数
      const total = allQuestions.length;
      const totalElement = document.getElementById('totalQuestionsInTree');
      if (totalElement) {
        totalElement.textContent = total;
      }
    }

    // 应用筛选
    function applyFilters() {
      // 重置到第一页
      currentPage = 1;

      currentFilters.search = document.getElementById('globalSearchInput').value.trim().toLowerCase();
      currentFilters.tag = document.getElementById('filterTag').value.trim().toLowerCase();

      const qtCheckboxes = document.querySelectorAll('.question-type-checkbox:checked');
      currentFilters.questionTypes = Array.from(qtCheckboxes).map(cb => cb.value);

      const diffCheckboxes = document.querySelectorAll('.difficulty-checkbox:checked');
      currentFilters.difficulties = Array.from(diffCheckboxes).map(cb => cb.value);

      // 获取当前知识点及其所有子节点的ID列表
      const knowledgeIds = currentFilters.knowledge ? getAllNodeIds(currentFilters.knowledge) : [];

      filteredQuestions = allQuestions.filter(question => {
        if (currentFilters.search && !question.content.toLowerCase().includes(currentFilters.search)) {
          return false;
        }
        // 知识点筛选：匹配节点及其所有子节点
        if (currentFilters.knowledge && !knowledgeIds.includes(question.knowledgeId)) {
          return false;
        }
        if (currentFilters.questionTypes.length > 0 && !currentFilters.questionTypes.includes(question.type)) {
          return false;
        }
        if (currentFilters.difficulties.length > 0 && !currentFilters.difficulties.includes(question.difficulty.toString())) {
          return false;
        }
        if (currentFilters.tag && !question.tags.some(tag => tag.toLowerCase().includes(currentFilters.tag))) {
          return false;
        }
        return true;
      });

      renderQuestions();
      document.getElementById('questionTypeDropdown').classList.add('hidden');
      document.getElementById('difficultyDropdown').classList.add('hidden');
    }

    // 清空所有筛选
    function clearAllFilters() {
      currentFilters = {
        search: '',
        knowledge: '',
        questionTypes: [],
        difficulties: [],
        tag: ''
      };

      document.getElementById('globalSearchInput').value = '';
      document.getElementById('filterTag').value = '';

      document.querySelectorAll('.question-type-checkbox').forEach(cb => cb.checked = false);
      document.getElementById('questionTypeLabel').textContent = '全部题型';

      document.querySelectorAll('.difficulty-checkbox').forEach(cb => cb.checked = false);
      document.getElementById('difficultyLabel').textContent = '全部难度';

      // 重置知识点树选中状态
      document.querySelectorAll('.tree-item').forEach(el => el.classList.remove('active'));
      document.querySelector('.tree-item')?.classList.add('active');
      document.getElementById('pageTitle').textContent = '全部题目';

      applyFilters();
    }

    // 渲染题目列表
    function renderQuestions() {
      const container = document.getElementById('questionList');
      const emptyState = document.getElementById('emptyState');
      const paginationContainer = document.getElementById('paginationContainer');

      // 按创建时间倒序排序（最新的在前面）
      filteredQuestions.sort((a, b) => {
        return b.createTime.localeCompare(a.createTime);
      });

      document.getElementById('totalQuestions').textContent = filteredQuestions.length;

      if (filteredQuestions.length === 0) {
        container.innerHTML = '';
        emptyState.classList.remove('hidden');
        paginationContainer.classList.add('hidden');
        return;
      }

      emptyState.classList.add('hidden');
      container.innerHTML = '';

      // 计算分页
      const totalPages = Math.ceil(filteredQuestions.length / pageSize);
      const startIndex = (currentPage - 1) * pageSize;
      const endIndex = Math.min(startIndex + pageSize, filteredQuestions.length);
      const currentQuestions = filteredQuestions.slice(startIndex, endIndex);

      // 渲染当前页的题目
      currentQuestions.forEach(question => {
        container.appendChild(createQuestionCard(question));
      });

      // 显示并渲染分页控件
      if (filteredQuestions.length > 0) {
        paginationContainer.classList.remove('hidden');
        renderPagination(totalPages, startIndex, endIndex, filteredQuestions.length);
      } else {
        paginationContainer.classList.add('hidden');
      }
    }

    // 创建题目卡片
    function createQuestionCard(q) {
      const card = document.createElement('div');
      card.className = 'apple-card bg-white rounded-2xl p-6 shadow-sm border border-gray-100 cursor-pointer';

      // 调试日志：仅对简便录入的题目输出
      if (q.author === '简便录入') {
        console.log('[渲染卡片] 简便录入题目:', q.id);
        console.log('  - knowledgeIds:', q.knowledgeIds);
        console.log('  - knowledgePath:', q.knowledgePath);
      }

      // 生成标签HTML
      const tagsHtml = q.tags && q.tags.length > 0
        ? q.tags.map(tag => `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs bg-gray-100 text-gray-700">#${tag}</span>`).join(' ')
        : '';

      card.innerHTML = `
        <div class="flex items-start justify-between">
          <div class="flex-1 cursor-pointer" onclick="viewQuestion('${q.id}')">
            <div class="flex items-center space-x-3 mb-3">
              <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-${q.typeColor}-50 text-${q.typeColor}-700">
                <i class="fas ${q.typeIcon} mr-1.5"></i>${q.typeName}
              </span>
              <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-warning-50 text-warning-700">
                ${q.difficultyName}
              </span>
              ${q.isComposite ? `<span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-700">
                <i class="fas fa-list-ol mr-1"></i>${q.subCount} 道子题
              </span>` : ''}
            </div>
            <div class="text-gray-900 text-base leading-relaxed mb-3 question-content">${q.content}</div>
            <div class="flex items-center gap-3 mb-2">
              ${tagsHtml}
            </div>
            <div class="flex items-center space-x-4 text-xs text-gray-500">
              <span class="flex items-center">
                <i class="fas fa-folder text-gray-400 mr-1.5"></i>${q.knowledgePath}
              </span>
              <span class="flex items-center">
                <i class="fas fa-layer-group text-gray-400 mr-1.5"></i>组卷 ${q.useCount} 次
              </span>
            </div>
          </div>
          <div class="flex flex-col items-end space-y-2 ml-6">
            <button onclick="viewQuestion('${q.id}')" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-primary-500 hover:bg-primary-50 rounded-lg transition-colors" title="查看详情">
              <i class="fas fa-eye"></i>
            </button>
            <button onclick="editQuestion('${q.id}')" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-info-500 hover:bg-info-50 rounded-lg transition-colors" title="编辑题目">
              <i class="fas fa-edit"></i>
            </button>
            <button onclick="deleteQuestion('${q.id}', '${q.content.replace(/<[^>]*>/g, '').substring(0, 20)}...')" class="w-8 h-8 flex items-center justify-center text-gray-400 hover:text-error-500 hover:bg-error-50 rounded-lg transition-colors" title="删除题目">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        </div>
      `;

      return card;
    }

    // ==================== 分页功能 ====================

    // 渲染分页控件
    function renderPagination(totalPages, startIndex, endIndex, total) {
      // 更新显示信息
      document.getElementById('pageStart').textContent = startIndex + 1;
      document.getElementById('pageEnd').textContent = endIndex;
      document.getElementById('pageTotal').textContent = total;

      // 更新按钮状态
      const firstPageBtn = document.getElementById('firstPageBtn');
      const prevPageBtn = document.getElementById('prevPageBtn');
      const nextPageBtn = document.getElementById('nextPageBtn');
      const lastPageBtn = document.getElementById('lastPageBtn');

      firstPageBtn.disabled = currentPage === 1;
      prevPageBtn.disabled = currentPage === 1;
      nextPageBtn.disabled = currentPage === totalPages;
      lastPageBtn.disabled = currentPage === totalPages;

      // 渲染页码
      const pageNumbers = document.getElementById('pageNumbers');
      pageNumbers.innerHTML = '';

      // 计算显示的页码范围
      let startPage = Math.max(1, currentPage - 2);
      let endPage = Math.min(totalPages, currentPage + 2);

      // 确保始终显示5个页码（如果总页数>=5）
      if (endPage - startPage < 4) {
        if (currentPage < 3) {
          endPage = Math.min(5, totalPages);
        } else {
          startPage = Math.max(1, endPage - 4);
        }
      }

      // 第一页
      if (startPage > 1) {
        const btn = createPageButton(1, false);
        pageNumbers.appendChild(btn);

        if (startPage > 2) {
          const ellipsis = document.createElement('span');
          ellipsis.className = 'px-2 text-gray-500';
          ellipsis.textContent = '...';
          pageNumbers.appendChild(ellipsis);
        }
      }

      // 中间页码
      for (let i = startPage; i <= endPage; i++) {
        const btn = createPageButton(i, i === currentPage);
        pageNumbers.appendChild(btn);
      }

      // 最后一页
      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          const ellipsis = document.createElement('span');
          ellipsis.className = 'px-2 text-gray-500';
          ellipsis.textContent = '...';
          pageNumbers.appendChild(ellipsis);
        }

        const btn = createPageButton(totalPages, false);
        pageNumbers.appendChild(btn);
      }
    }

    // 创建页码按钮
    function createPageButton(pageNum, isActive) {
      const btn = document.createElement('button');
      btn.onclick = () => changePage(pageNum);
      btn.className = isActive
        ? 'px-3 py-1.5 bg-primary-500 text-white rounded-lg text-sm font-medium'
        : 'px-3 py-1.5 border border-gray-300 rounded-lg text-sm text-gray-600 hover:bg-gray-50 transition-colors';
      btn.textContent = pageNum;
      return btn;
    }

    // 切换页码
    function changePage(page) {
      const totalPages = Math.ceil(filteredQuestions.length / pageSize);
      if (page < 1 || page > totalPages) return;

      currentPage = page;
      renderQuestions();

      // 滚动到顶部
      document.getElementById('questionListContainer').scrollTop = 0;
    }

    // 跳转到第一页
    function goToFirstPage() {
      changePage(1);
    }

    // 跳转到最后一页
    function goToLastPage() {
      const totalPages = Math.ceil(filteredQuestions.length / pageSize);
      changePage(totalPages);
    }

    // ==================== 知识点筛选 ====================

    // 点击知识点节点筛选
    function selectKnowledgeNode(nodeId, nodeName) {
      document.querySelectorAll('.tree-item').forEach(el => el.classList.remove('active'));

      currentFilters.knowledge = nodeId.toString();

      document.getElementById('pageTitle').textContent = nodeId ? nodeName : '全部题目';

      applyFilters();
    }

    // 检查节点或其子节点是否匹配搜索关键词
    function matchesSearch(node, keyword) {
      if (!keyword) return true;

      // 检查当前节点
      if (node.name.toLowerCase().includes(keyword)) {
        return true;
      }

      // 检查子节点
      if (node.children && node.children.length > 0) {
        return node.children.some(child => matchesSearch(child, keyword));
      }

      return false;
    }

    // 选择全部题目
    function selectAllQuestions(element) {
      selectKnowledgeNode('', '全部题目');
      element.classList.add('active');
    }

    // ==================== 题型设置功能 ====================

    // 默认题型（原始定义）- 只保留单选、多选、判断、填空和复合题型
    const defaultQuestionTypes = [
      { id: 'single', name: '单选题', icon: 'fa-dot-circle', color: 'info', isDefault: true },
      { id: 'multiple', name: '多选题', icon: 'fa-check-double', color: 'success', isDefault: true },
      { id: 'judge', name: '判断题', icon: 'fa-check-circle', color: 'success', isDefault: true },
      { id: 'blank', name: '填空题', icon: 'fa-keyboard', color: 'warning', isDefault: true },
      { id: 'cloze', name: '完形填空', icon: 'fa-layer-group', color: 'indigo', isDefault: true },
      { id: 'shortAnswer', name: '简答题', icon: 'fa-align-left', color: 'teal', isDefault: true },
      {
        id: 'materialAnalysis',
        name: '材料分析',
        icon: 'fa-list-alt',
        color: 'purple',
        isDefault: true,
        isComposite: true,
        hasMaterial: true,
        subTypes: ['single', 'multiple', 'judge', 'blank', 'shortAnswer']  // 只包含需要的基础题型
      }
    ];

    // 对默认题型的修改（用于存储重命名等修改）
    let modifiedDefaultTypes = {};

    // 自定义题型数据
    let customQuestionTypes = [];
    let nextCustomTypeId = 1000;
    let editingQuestionType = null; // 正在编辑的题型（可能是默认或自定义）

    // 从 localStorage 加载题型配置
    function loadQuestionTypesFromStorage() {
      const saved = localStorage.getItem('questionTypesConfig');
      if (saved) {
        try {
          const config = JSON.parse(saved);
          if (config.modifiedDefaultTypes) {
            modifiedDefaultTypes = config.modifiedDefaultTypes;
          }
          if (config.customQuestionTypes) {
            customQuestionTypes = config.customQuestionTypes;
          }
          if (config.nextCustomTypeId) {
            nextCustomTypeId = config.nextCustomTypeId;
          }
        } catch (e) {
          console.error('加载题型配置失败:', e);
        }
      }
    }

    // 保存题型配置到 localStorage
    function saveQuestionTypesToStorage() {
      const config = {
        modifiedDefaultTypes: modifiedDefaultTypes,
        customQuestionTypes: customQuestionTypes,
        nextCustomTypeId: nextCustomTypeId
      };
      localStorage.setItem('questionTypesConfig', JSON.stringify(config));
    }

    // 获取题型（考虑修改后的版本）
    function getQuestionType(type) {
      if (type.isDefault && modifiedDefaultTypes[type.id]) {
        // 返回修改后的版本，但保留原始名称
        const modified = { ...type, ...modifiedDefaultTypes[type.id] };
        // 如果有自定义名称，使用自定义名称；否则使用原始名称
        if (modified.customName) {
          modified.name = modified.customName;
        }
        // 保留原始名称供恢复使用
        modified.originalName = type.name;
        return modified;
      }
      return type;
    }

    // 打开题型设置弹窗
    function openQuestionTypeSettings() {
      renderDefaultQuestionTypes();
      renderCustomQuestionTypes();
      document.getElementById('questionTypeSettingsModal').classList.remove('hidden');
    }

    // 关闭题型设置弹窗
    function closeQuestionTypeSettings() {
      document.getElementById('questionTypeSettingsModal').classList.add('hidden');
    }

    // 渲染默认题型列表
    function renderDefaultQuestionTypes() {
      const container = document.getElementById('defaultQuestionTypes');
      container.innerHTML = '';

      defaultQuestionTypes.forEach(type => {
        // 传递原始的 type，让 createQuestionTypeItem 内部处理显示名称
        const item = createQuestionTypeItem(type, true); // 第二个参数表示是默认题型
        container.appendChild(item);
      });
    }

    // 渲染自定义题型列表
    function renderCustomQuestionTypes() {
      const container = document.getElementById('customQuestionTypes');
      const emptyTip = document.getElementById('emptyCustomTypes');

      if (customQuestionTypes.length === 0) {
        container.classList.add('hidden');
        emptyTip.classList.remove('hidden');
      } else {
        container.classList.remove('hidden');
        emptyTip.classList.add('hidden');
        container.innerHTML = '';

        customQuestionTypes.forEach(type => {
          const item = createQuestionTypeItem(type, false); // 自定义题型
          container.appendChild(item);
        });
      }
    }

    // 创建题型列表项
    function createQuestionTypeItem(type, isDefaultType) {
      // 如果是默认题型，获取显示版本（包含自定义名称）
      const displayType = isDefaultType ? getQuestionType(type) : type;

      const div = document.createElement('div');
      div.className = 'flex items-center justify-between p-4 border border-gray-200 rounded-lg hover:border-primary-300 hover:bg-primary-50 transition-all group';

      // 左侧：图标和名称
      const leftDiv = document.createElement('div');
      leftDiv.className = 'flex items-center space-x-3';

      const iconDiv = document.createElement('div');
      iconDiv.className = `w-10 h-10 rounded-lg bg-${displayType.color}-50 flex items-center justify-center`;
      iconDiv.innerHTML = `<i class="fas ${displayType.icon} text-${displayType.color}-500"></i>`;
      leftDiv.appendChild(iconDiv);

      const infoDiv = document.createElement('div');
      const nameSpan = document.createElement('div');
      nameSpan.className = 'font-medium text-gray-900';
      nameSpan.textContent = displayType.name; // 显示名称（可能是自定义名称）
      infoDiv.appendChild(nameSpan);

      if (displayType.baseType) {
        const baseSpan = document.createElement('div');
        baseSpan.className = 'text-xs text-gray-500 mt-0.5';
        baseSpan.textContent = `基于：${getBaseTypeName(displayType.baseType)}`;
        infoDiv.appendChild(baseSpan);
      }

      if (displayType.description) {
        const descSpan = document.createElement('div');
        descSpan.className = 'text-xs text-gray-500 mt-0.5';
        descSpan.textContent = displayType.description;
        infoDiv.appendChild(descSpan);
      }

      leftDiv.appendChild(infoDiv);
      div.appendChild(leftDiv);

      // 右侧：标签和操作
      const rightDiv = document.createElement('div');
      rightDiv.className = 'flex items-center space-x-3';

      // 默认题型标签
      if (displayType.isDefault) {
        const badge = document.createElement('span');
        badge.className = 'px-2 py-1 bg-gray-100 text-gray-600 text-xs rounded';
        badge.textContent = '内置';
        rightDiv.appendChild(badge);
      }

      // 复合题型标签
      if (displayType.isComposite) {
        const badge = document.createElement('span');
        badge.className = 'px-2 py-1 bg-purple-100 text-purple-600 text-xs rounded';
        badge.textContent = '复合';
        rightDiv.appendChild(badge);
      }

      // 操作按钮（所有题型都可以编辑）
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'hidden group-hover:flex items-center space-x-2';

      // 编辑按钮
      const editBtn = document.createElement('button');
      editBtn.className = 'w-8 h-8 flex items-center justify-center text-gray-400 hover:text-info-600 hover:bg-info-50 rounded transition-colors';
      editBtn.title = '编辑';
      editBtn.innerHTML = '<i class="fas fa-edit text-sm"></i>';
      editBtn.onclick = (e) => {
        e.stopPropagation();
        // 传递原始的 type，不是 displayType
        editQuestionType(type);
      };
      actionsDiv.appendChild(editBtn);

      // 删除按钮（仅自定义题型）
      if (!type.isDefault) {
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'w-8 h-8 flex items-center justify-center text-gray-400 hover:text-error-600 hover:bg-error-50 rounded transition-colors';
        deleteBtn.title = '删除';
        deleteBtn.innerHTML = '<i class="fas fa-trash text-sm"></i>';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deleteCustomType(type);
        };
        actionsDiv.appendChild(deleteBtn);
      }

      rightDiv.appendChild(actionsDiv);

      div.appendChild(rightDiv);
      return div;
    }

    // 获取基础题型名称
    function getBaseTypeName(typeId) {
      const type = defaultQuestionTypes.find(t => t.id === typeId);
      if (!type) return typeId;
      const displayType = getQuestionType(type);
      return displayType.name;
    }

    // 打开添加自定义题型弹窗
    function openAddCustomType() {
      editingQuestionType = null;
      document.getElementById('customTypeModalTitle').textContent = '添加自定义题型';

      // 隐藏原始名称提示
      document.getElementById('originalNameHint').classList.add('hidden');

      // 重置基础题型选择（移除 composite 选项，因为内置已包含复合题型）
      const baseTypeSelect = document.getElementById('baseQuestionType');
      baseTypeSelect.innerHTML = `
        <option value="">请选择</option>
        <option value="single">单选题</option>
        <option value="multiple">多选题</option>
        <option value="judge">判断题</option>
        <option value="blank">填空题</option>
        <option value="cloze">完形填空</option>
        <option value="shortAnswer">简答题</option>
        <option value="composite">复合题型（自定义组合）</option>
      `;
      baseTypeSelect.value = '';

      document.getElementById('customTypeName').value = '';
      document.getElementById('customTypeDescription').value = '';
      document.getElementById('compositeOptionsContainer').classList.add('hidden');
      document.querySelectorAll('.composite-subtype').forEach(cb => cb.checked = false);
      document.getElementById('hasMaterial').checked = true;
      document.getElementById('addCustomTypeModal').classList.remove('hidden');
    }

    // 关闭添加自定义题型弹窗
    function closeAddCustomType() {
      document.getElementById('addCustomTypeModal').classList.add('hidden');
      editingQuestionType = null;
      // 恢复基础题型选择框的可用状态
      document.getElementById('baseQuestionType').disabled = false;
    }

    // 更新复合选项显示
    function updateCompositeOptions() {
      const baseType = document.getElementById('baseQuestionType').value;
      const container = document.getElementById('compositeOptionsContainer');

      if (baseType === 'composite') {
        container.classList.remove('hidden');
      } else {
        container.classList.add('hidden');
      }
    }

    // 保存题型（内置或自定义）
    function saveCustomType() {
      const baseType = document.getElementById('baseQuestionType').value;
      const name = document.getElementById('customTypeName').value.trim();
      const description = document.getElementById('customTypeDescription').value.trim();

      // 判断是否是编辑内置题型
      if (editingQuestionType && editingQuestionType.isDefault) {
        // 编辑内置题型，名称可以为空（表示恢复原始名称）

        // 保存对内置题型的修改
        const modifications = {
          description: description
        };

        // 只有当自定义名称不为空且与原始名称不同时，才保存customName
        if (name && name !== editingQuestionType.name) {
          modifications.customName = name;
        }

        // 如果是复合题型，保存复合配置
        if (editingQuestionType.isComposite) {
          const checkedSubtypes = Array.from(document.querySelectorAll('.composite-subtype:checked'));
          if (checkedSubtypes.length === 0) {
            alert('请至少选择一个子题型');
            return;
          }
          modifications.hasMaterial = document.getElementById('hasMaterial').checked;
          modifications.subTypes = checkedSubtypes.map(cb => cb.value);
        }

        // 存储修改
        modifiedDefaultTypes[editingQuestionType.id] = modifications;

        // 保存到 localStorage
        saveQuestionTypesToStorage();

        // 更新UI
        renderDefaultQuestionTypes();
        updateQuestionTypeFilter();
        closeAddCustomType();
        return;
      }

      // 以下是自定义题型的处理，名称必填
      if (!name) {
        alert('请输入名称');
        return;
      }
      if (!baseType) {
        alert('请选择基础题型');
        return;
      }

      // 复合题型验证
      if (baseType === 'composite') {
        const checkedSubtypes = Array.from(document.querySelectorAll('.composite-subtype:checked'));
        if (checkedSubtypes.length === 0) {
          alert('请至少选择一个子题型');
          return;
        }
      }

      // 构建题型对象
      const customType = {
        id: editingQuestionType ? editingQuestionType.id : `custom_${nextCustomTypeId++}`,
        name: name,
        baseType: baseType,
        description: description,
        icon: baseType === 'composite' ? 'fa-layer-group' : defaultQuestionTypes.find(t => t.id === baseType)?.icon || 'fa-file-alt',
        color: baseType === 'composite' ? 'purple' : defaultQuestionTypes.find(t => t.id === baseType)?.color || 'gray',
        isComposite: baseType === 'composite',
        isDefault: false
      };

      if (baseType === 'composite') {
        customType.hasMaterial = document.getElementById('hasMaterial').checked;
        customType.subTypes = Array.from(document.querySelectorAll('.composite-subtype:checked')).map(cb => cb.value);
      }

      // 添加或更新
      if (editingQuestionType && !editingQuestionType.isDefault) {
        const index = customQuestionTypes.findIndex(t => t.id === editingQuestionType.id);
        if (index !== -1) {
          customQuestionTypes[index] = customType;
        }
      } else {
        customQuestionTypes.push(customType);
      }

      // 保存到 localStorage
      saveQuestionTypesToStorage();

      // 更新UI
      renderCustomQuestionTypes();
      updateQuestionTypeFilter();
      closeAddCustomType();
    }

    // 编辑题型（内置或自定义）
    function editQuestionType(type) {
      editingQuestionType = type;

      if (type.isDefault) {
        // 编辑内置题型
        // 直接使用 type.name 作为原始名称（因为 type 来自 defaultQuestionTypes，未被修改）
        const originalName = type.name;
        document.getElementById('customTypeModalTitle').textContent = `编辑题型：${originalName}`;

        // 内置题型不显示基础题型选择，直接显示原始类型名称
        const baseTypeSelect = document.getElementById('baseQuestionType');
        if (type.isComposite) {
          baseTypeSelect.innerHTML = `<option value="composite" selected>复合题型</option>`;
          baseTypeSelect.disabled = true;
        } else {
          baseTypeSelect.innerHTML = `<option value="${type.id}" selected>${originalName}</option>`;
          baseTypeSelect.disabled = true;
        }

        // 显示原始名称提示
        const originalNameHint = document.getElementById('originalNameHint');
        const originalNameDisplay = document.getElementById('originalNameDisplay');
        originalNameHint.classList.remove('hidden');
        originalNameDisplay.textContent = originalName;

        // 从 modifiedDefaultTypes 获取自定义名称（如果有）
        const customName = modifiedDefaultTypes[type.id]?.customName || '';
        document.getElementById('customTypeName').value = customName;
        document.getElementById('customTypeDescription').value = modifiedDefaultTypes[type.id]?.description || '';

        if (type.isComposite) {
          document.getElementById('compositeOptionsContainer').classList.remove('hidden');
          const savedMaterial = modifiedDefaultTypes[type.id]?.hasMaterial;
          const savedSubTypes = modifiedDefaultTypes[type.id]?.subTypes;
          document.getElementById('hasMaterial').checked = savedMaterial !== undefined ? savedMaterial : (type.hasMaterial !== false);
          document.querySelectorAll('.composite-subtype').forEach(cb => {
            cb.checked = savedSubTypes ? savedSubTypes.includes(cb.value) : (type.subTypes && type.subTypes.includes(cb.value));
          });
        } else {
          document.getElementById('compositeOptionsContainer').classList.add('hidden');
        }
      } else {
        // 编辑自定义题型
        document.getElementById('customTypeModalTitle').textContent = '编辑自定义题型';

        // 隐藏原始名称提示
        document.getElementById('originalNameHint').classList.add('hidden');

        const baseTypeSelect = document.getElementById('baseQuestionType');
        baseTypeSelect.innerHTML = `
          <option value="">请选择</option>
          <option value="single">单选题</option>
          <option value="multiple">多选题</option>
          <option value="judge">判断题</option>
          <option value="blank">填空题</option>
          <option value="cloze">完形填空</option>
          <option value="shortAnswer">简答题</option>
          <option value="composite">复合题型（自定义组合）</option>
        `;
        baseTypeSelect.disabled = false;
        baseTypeSelect.value = type.baseType;

        document.getElementById('customTypeName').value = type.name;
        document.getElementById('customTypeDescription').value = type.description || '';

        if (type.isComposite) {
          document.getElementById('compositeOptionsContainer').classList.remove('hidden');
          document.getElementById('hasMaterial').checked = type.hasMaterial !== false;
          document.querySelectorAll('.composite-subtype').forEach(cb => {
            cb.checked = type.subTypes && type.subTypes.includes(cb.value);
          });
        } else {
          document.getElementById('compositeOptionsContainer').classList.add('hidden');
        }
      }

      document.getElementById('addCustomTypeModal').classList.remove('hidden');
    }

    // 删除自定义题型
    function deleteCustomType(type) {
      if (confirm(`确定要删除自定义题型"${type.name}"吗？\n\n删除后不可恢复！`)) {
        customQuestionTypes = customQuestionTypes.filter(t => t.id !== type.id);

        // 保存到 localStorage
        saveQuestionTypesToStorage();

        renderCustomQuestionTypes();
        updateQuestionTypeFilter();
      }
    }

    // 更新题型筛选下拉框（当自定义题型变化时调用）
    function updateQuestionTypeFilter() {
      const select = document.getElementById('filterQuestionType');
      if (!select) return;

      // 保存当前选中的值
      const currentValues = Array.from(select.selectedOptions).map(opt => opt.value);

      // 清空并重建选项
      select.innerHTML = '';

      // 添加"全部"选项
      const allOption = document.createElement('option');
      allOption.value = '';
      allOption.textContent = '全部题型';
      allOption.selected = currentValues.includes('') || currentValues.length === 0;
      select.appendChild(allOption);

      // 添加基础题型
      defaultQuestionTypes.filter(t => !t.isComposite).forEach(type => {
        const displayType = getQuestionType(type);
        const option = document.createElement('option');
        option.value = type.id;
        option.textContent = displayType.name;
        option.selected = currentValues.includes(type.id);
        select.appendChild(option);
      });

      // 添加复合题型
      defaultQuestionTypes.filter(t => t.isComposite).forEach(type => {
        const displayType = getQuestionType(type);
        const option = document.createElement('option');
        option.value = type.id;
        option.textContent = displayType.name;
        option.selected = currentValues.includes(type.id);
        select.appendChild(option);
      });

      // 添加自定义题型
      customQuestionTypes.forEach(type => {
        const option = document.createElement('option');
        option.value = type.id;
        option.textContent = type.name;
        option.selected = currentValues.includes(type.id);
        select.appendChild(option);
      });
    }

    // ==================== 题目操作函数 ====================

    // 新增题目
    function addNewQuestion() {
      window.location.href = 'add.html';
    }

    // 查看题目详情
    let currentPreviewQuestion = null;

    function viewQuestion(questionId) {
      // 查找题目数据
      const question = allQuestions.find(q => q.id === questionId);
      if (!question) {
        alert('未找到题目数据');
        return;
      }

      currentPreviewQuestion = question;

      // 渲染题目预览内容
      renderQuestionPreview(question);

      // 显示侧滑面板
      setTimeout(() => {
        document.getElementById('previewOverlay').classList.add('active');
        document.getElementById('previewDrawer').classList.add('active');
        document.body.style.overflow = 'hidden';
      }, 10);
    }

    // 关闭预览面板
    function closePreview() {
      document.getElementById('previewOverlay').classList.remove('active');
      document.getElementById('previewDrawer').classList.remove('active');
      document.body.style.overflow = '';
      currentPreviewQuestion = null;
    }

    // 渲染题目预览内容
    function renderQuestionPreview(q) {
      const content = document.getElementById('previewContent');

      // 生成题型标签
      const typeTag = `<span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-${q.typeColor}-50 text-${q.typeColor}-700">
        <i class="fas ${q.typeIcon} mr-1.5"></i>${q.typeName}
      </span>`;

      // 生成难度标签
      const difficultyTag = `<span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-warning-50 text-warning-700">
        ${q.difficultyName}
      </span>`;

      // 生成标签列表
      const tagsHtml = q.tags && q.tags.length > 0
        ? q.tags.map(tag => `<span class="inline-flex items-center px-2 py-1 rounded text-xs bg-gray-100 text-gray-700">#${tag}</span>`).join(' ')
        : '<span class="text-gray-400 text-sm">无标签</span>';

      // 根据题型生成内容
      let questionContent = '';

      if (q.isComposite) {
        // 复合题型
        questionContent = renderCompositeQuestion(q);
      } else if (q.type === 'single' || q.type === 'multiple') {
        // 选择题
        questionContent = renderChoiceQuestion(q);
      } else if (q.type === 'judge') {
        // 判断题
        questionContent = renderJudgeQuestion(q);
      } else if (q.type === 'blank' || q.type === 'cloze') {
        // 填空题、完形填空
        questionContent = renderBlankQuestion(q);
      } else if (q.type === 'shortAnswer' || q.type === 'essay' || q.type === 'calculation') {
        // 简答题、论述题、计算题等主观题
        questionContent = renderShortQuestion(q);
      } else {
        // 其他题型（名词解释、汉译英等）
        questionContent = renderShortQuestion(q);
      }

      content.innerHTML = `
        <div class="space-y-6">
          <!-- 基本信息 -->
          <div class="flex items-center gap-3 flex-wrap">
            ${typeTag}
            ${difficultyTag}
            ${q.isComposite ? `<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-700">
              <i class="fas fa-list-ol mr-1"></i>${q.subCount} 道子题
            </span>` : ''}
          </div>

          ${questionContent}

          <!-- 附加信息 -->
          <div class="pt-6 border-t border-gray-200 space-y-3">
            <div class="flex items-start">
              <span class="text-sm font-medium text-gray-500 w-20 flex-shrink-0">知识点：</span>
              <span class="text-sm text-gray-900">${q.knowledgePath}</span>
            </div>
            <div class="flex items-start">
              <span class="text-sm font-medium text-gray-500 w-20 flex-shrink-0">标签：</span>
              <div class="flex items-center gap-2 flex-wrap">${tagsHtml}</div>
            </div>
            <div class="flex items-center">
              <span class="text-sm font-medium text-gray-500 w-20 flex-shrink-0">默认分值：</span>
              <span class="text-sm text-gray-900">${q.score ? q.score + ' 分' : '--'}</span>
            </div>
            <div class="flex items-center">
              <span class="text-sm font-medium text-gray-500 w-20 flex-shrink-0">创建时间：</span>
              <span class="text-sm text-gray-600">${q.createTime}</span>
            </div>
            <div class="flex items-center">
              <span class="text-sm font-medium text-gray-500 w-20 flex-shrink-0">创建者：</span>
              <span class="text-sm text-gray-600">${q.author}</span>
            </div>
            <div class="flex items-center">
              <span class="text-sm font-medium text-gray-500 w-20 flex-shrink-0">使用次数：</span>
              <span class="text-sm text-gray-600">组卷 ${q.useCount} 次</span>
            </div>
          </div>
        </div>
      `;
    }

    // 渲染选择题
    function renderChoiceQuestion(q) {
      const optionsHtml = q.options.map(opt => {
        const isCorrect = q.correctAnswers.includes(opt.label);
        return `
          <div class="flex items-start py-2">
            <span class="option-label ${isCorrect ? 'correct' : ''}">${opt.label}</span>
            <span class="text-gray-900">${opt.text}</span>
          </div>
        `;
      }).join('');

      return `
        <div class="space-y-4">
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">题干</div>
            <div class="question-content text-gray-900 text-base leading-relaxed">${q.content}</div>
          </div>
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">选项</div>
            <div class="space-y-1">${optionsHtml}</div>
          </div>
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">正确答案</div>
            <div class="inline-flex items-center px-3 py-1.5 bg-green-50 text-green-700 rounded-lg font-medium">
              ${q.correctAnswers.join('、')}
            </div>
          </div>
          ${q.explanation ? `
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">答案解析</div>
            <div class="question-content text-gray-700 text-sm leading-relaxed bg-blue-50 p-4 rounded-lg">${q.explanation}</div>
          </div>
          ` : ''}
        </div>
      `;
    }

    // 渲染判断题
    function renderJudgeQuestion(q) {
      return `
        <div class="space-y-4">
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">题干</div>
            <div class="question-content text-gray-900 text-base leading-relaxed">${q.content}</div>
          </div>
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">正确答案</div>
            <div class="inline-flex items-center px-3 py-1.5 bg-green-50 text-green-700 rounded-lg font-medium">
              ${q.correctAnswer ? '正确' : '错误'}
            </div>
          </div>
          ${q.explanation ? `
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">答案解析</div>
            <div class="question-content text-gray-700 text-sm leading-relaxed bg-blue-50 p-4 rounded-lg">${q.explanation}</div>
          </div>
          ` : ''}
        </div>
      `;
    }

    // 渲染填空题
    function renderBlankQuestion(q) {
      if (!q.blanks || q.blanks.length === 0) {
        return `
          <div class="space-y-4">
            <div>
              <div class="text-sm font-medium text-gray-500 mb-2">题干</div>
              <div class="question-content text-gray-900 text-base leading-relaxed">${q.content}</div>
            </div>
            <div>
              <div class="text-sm font-medium text-gray-500 mb-2">参考答案</div>
              <div class="text-sm text-gray-400">暂无填空答案</div>
            </div>
            ${q.explanation ? `
            <div>
              <div class="text-sm font-medium text-gray-500 mb-2">答案解析</div>
              <div class="question-content text-gray-700 text-sm leading-relaxed bg-blue-50 p-4 rounded-lg">${q.explanation}</div>
            </div>
            ` : ''}
          </div>
        `;
      }

      const blanksHtml = q.blanks.map((blank, index) => `
        <div class="flex items-center py-2">
          <span class="text-sm font-medium text-gray-500 w-20">空 ${blank.index}：</span>
          <span class="inline-flex items-center px-3 py-1.5 bg-green-50 text-green-700 rounded-lg font-medium">${blank.answer}</span>
          <span class="text-sm text-gray-500 ml-3">(${blank.score ? blank.score + ' 分' : '--'})</span>
        </div>
      `).join('');

      return `
        <div class="space-y-4">
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">题干</div>
            <div class="question-content text-gray-900 text-base leading-relaxed">${q.content}</div>
          </div>
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">参考答案</div>
            <div class="space-y-1">${blanksHtml}</div>
          </div>
          ${q.explanation ? `
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">答案解析</div>
            <div class="question-content text-gray-700 text-sm leading-relaxed bg-blue-50 p-4 rounded-lg">${q.explanation}</div>
          </div>
          ` : ''}
        </div>
      `;
    }

    // 渲染简答题
    function renderShortQuestion(q) {
      return `
        <div class="space-y-4">
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">题干</div>
            <div class="question-content text-gray-900 text-base leading-relaxed">${q.content}</div>
          </div>
          ${q.referenceAnswer ? `
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">参考答案</div>
            <div class="question-content text-gray-700 text-sm leading-relaxed bg-green-50 p-4 rounded-lg whitespace-pre-line">${q.referenceAnswer}</div>
          </div>
          ` : ''}
          ${q.explanation ? `
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">答案解析</div>
            <div class="question-content text-gray-700 text-sm leading-relaxed bg-blue-50 p-4 rounded-lg">${q.explanation}</div>
          </div>
          ` : ''}
        </div>
      `;
    }

    // 渲染复合题
    function renderCompositeQuestion(q) {
      const subQuestionsHtml = q.subQuestions.map((sub, index) => {
        let subContent = '';
        if (sub.type === 'single' || sub.type === 'multiple') {
          const optionsHtml = sub.options.map(opt => {
            const isCorrect = sub.correctAnswers.includes(opt.label);
            return `
              <div class="flex items-start py-1">
                <span class="option-label ${isCorrect ? 'correct' : ''}">${opt.label}</span>
                <span class="text-gray-800 text-sm">${opt.text}</span>
              </div>
            `;
          }).join('');
          subContent = `
            <div class="mt-2 space-y-2">
              ${optionsHtml}
              <div class="mt-2">
                <span class="text-xs font-medium text-gray-500">答案：</span>
                <span class="inline-flex items-center px-2 py-0.5 bg-green-50 text-green-700 rounded text-xs font-medium">
                  ${sub.correctAnswers.join('、')}
                </span>
                <span class="text-xs text-gray-500 ml-2">(${sub.score ? sub.score + ' 分' : '--'})</span>
              </div>
            </div>
          `;
        } else {
          subContent = `
            <div class="mt-2">
              <div class="text-xs font-medium text-gray-500 mb-1">参考答案：</div>
              <div class="text-sm text-gray-700 bg-green-50 p-2 rounded">${sub.answer || '无'}</div>
              <span class="text-xs text-gray-500 mt-1 inline-block">(${sub.score ? sub.score + ' 分' : '--'})</span>
            </div>
          `;
        }

        return `
          <div class="border-l-2 border-gray-300 pl-4 py-2">
            <div class="text-sm font-medium text-gray-700 mb-1">
              ${index + 1}）${sub.content}
            </div>
            ${subContent}
          </div>
        `;
      }).join('');

      return `
        <div class="space-y-4">
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">材料</div>
            <div class="question-content text-gray-900 text-base leading-relaxed bg-amber-50 p-4 rounded-lg">${q.content}</div>
          </div>
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">子题目 (共 ${q.subCount} 道)</div>
            <div class="space-y-3">${subQuestionsHtml}</div>
          </div>
          ${q.explanation ? `
          <div>
            <div class="text-sm font-medium text-gray-500 mb-2">答案解析</div>
            <div class="question-content text-gray-700 text-sm leading-relaxed bg-blue-50 p-4 rounded-lg">${q.explanation}</div>
          </div>
          ` : ''}
        </div>
      `;
    }

    // 编辑当前预览的题目
    function editCurrentQuestion() {
      if (currentPreviewQuestion) {
        const questionId = currentPreviewQuestion.id; // 先保存ID
        closePreview();
        editQuestion(questionId);
      }
    }

    // 删除当前预览的题目
    function deleteCurrentQuestion() {
      if (currentPreviewQuestion) {
        const questionId = currentPreviewQuestion.id; // 先保存ID
        const questionTitle = currentPreviewQuestion.content.replace(/<[^>]*>/g, '').substring(0, 30);
        closePreview();
        deleteQuestion(questionId, questionTitle);
      }
    }

    // 编辑题目
    function editQuestion(questionId) {
      window.location.href = `add.html?id=${questionId}`;
    }

    // 删除题目
    function deleteQuestion(questionId, questionTitle) {
      if (confirm(`确定要删除这道题目吗？\n\n题目编号：${questionId}\n题目内容：${questionTitle}\n\n删除后不可恢复！`)) {
        // 从 allQuestions 数组中删除
        const index = allQuestions.findIndex(q => q.id === questionId);
        if (index > -1) {
          allQuestions.splice(index, 1);
        }

        // 保存到 localStorage
        localStorage.setItem('allQuestions', JSON.stringify(allQuestions));

        // 从 filteredQuestions 数组中删除
        const filteredIndex = filteredQuestions.findIndex(q => q.id === questionId);
        if (filteredIndex > -1) {
          filteredQuestions.splice(filteredIndex, 1);
        }

        // 刷新页面显示
        updateKnowledgeTreeCounts();
        renderQuestions();

        // 显示成功提示
        alert(`题目 ${questionId} 已成功删除！`);
      }
    }

    // 页面加载完成后初始化
    window.addEventListener('DOMContentLoaded', function() {
      // 加载知识点树
      loadKnowledgeTreeFromStorage();

      // 加载题型配置
      loadQuestionTypesFromStorage();

      // 从 localStorage 读取已保存的题目
      let savedQuestions = JSON.parse(localStorage.getItem('allQuestions') || '[]');

      console.log('===== list.html 加载题目 =====');
      console.log('从localStorage读取题目数量:', savedQuestions.length);
      if (savedQuestions.length > 0) {
        const lastQuestion = savedQuestions[savedQuestions.length - 1];
        console.log('最后一个题目:', lastQuestion);
        console.log('  - ID:', lastQuestion.id);
        console.log('  - 题型:', lastQuestion.type, lastQuestion.typeName);
        console.log('  - 作者:', lastQuestion.author);
        console.log('  - knowledgeIds:', lastQuestion.knowledgeIds);
        console.log('  - knowledgePath:', lastQuestion.knowledgePath);
      }
      console.log('==============================');

      // 检查内置题目是否已保存到 localStorage
      // 通过检查是否存在 Q001 来判断
      const hasBuiltInQuestions = savedQuestions.some(q => q.id === 'Q001');

      if (!hasBuiltInQuestions) {
        // 首次加载：将内置题目保存到 localStorage
        // 内置题目放在前面，用户添加的题目放在后面
        const mergedQuestions = [...allQuestions, ...savedQuestions];
        localStorage.setItem('allQuestions', JSON.stringify(mergedQuestions));
        savedQuestions = mergedQuestions;
      }

      // 使用 localStorage 中的数据作为数据源
      allQuestions = savedQuestions;

      // 重新初始化 filteredQuestions
      filteredQuestions = [...allQuestions];

      updateKnowledgeTreeCounts();  // 先更新题目数量
      renderKnowledgeTree();
      renderQuestions();
    });
  </script>
</body>
</html>
