<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>偏好记录功能测试</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .test-result {
      margin: 10px 0;
      padding: 10px;
      border-radius: 4px;
    }
    .test-pass {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .test-fail {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .test-section {
      margin: 20px 0;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
  </style>
</head>
<body class="bg-gray-50 p-8">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-3xl font-bold mb-6">偏好记录功能测试</h1>

    <div class="bg-white p-6 rounded-lg shadow mb-6">
      <button id="runAllTests" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600">
        运行所有测试
      </button>
      <button id="clearStorage" class="bg-red-500 text-white px-6 py-2 rounded hover:bg-red-600 ml-4">
        清除存储
      </button>
    </div>

    <div id="testResults" class="space-y-4"></div>
  </div>

  <script>
    // ============================================
    // UserPreferenceManager 类（从 ai-assistant.html 复制）
    // ============================================
    class UserPreferenceManager {
      constructor() {
        this.storageKey = 'ai_assistant_user_preferences';
        this.preferences = this.loadPreferences();
      }

      // 获取默认偏好数据结构
      getDefaultPreferences() {
        return {
          userId: 'default_user',
          version: '1.0',

          // 1. 基础偏好统计
          basicPreferences: {
            questionType: {
              'single': { count: 0, percentage: 0 },
              'multiple': { count: 0, percentage: 0 },
              'judge': { count: 0, percentage: 0 },
              'fill': { count: 0, percentage: 0 },
              'essay': { count: 0, percentage: 0 },
              'all': { count: 0, percentage: 0 }
            },
            difficulty: {
              '1': { count: 0, percentage: 0 },
              '2': { count: 0, percentage: 0 },
              '3': { count: 0, percentage: 0 },
              '4': { count: 0, percentage: 0 },
              '5': { count: 0, percentage: 0 }
            },
            quantity: {
              total: 0,
              average: 10,
              mostCommon: 10,
              distribution: {}
            },
            knowledgePoints: {}
          },

          // 2. 场景偏好
          scenarioPreferences: {
            'generate_questions': {
              lastUsed: null,
              frequency: 0,
              lastParams: null,
              commonConfig: null
            }
          },

          // 3. 行为模式
          behaviorPatterns: {
            timePatterns: {
              weekday: { samples: 0, avgDifficulty: 0, avgCount: 0, commonType: null },
              weekend: { samples: 0, avgDifficulty: 0, avgCount: 0, commonType: null }
            },
            knowledgePointFocus: {
              recent: [],
              trending: null
            },
            commonCombinations: []
          },

          // 4. 对话风格偏好
          conversationStyle: {
            verbosity: 'normal',
            confirmationNeeded: true,
            preferQuickActions: false
          },

          // 5. 元数据
          metadata: {
            totalActions: 0,
            firstActionDate: null,
            lastActionDate: null,
            totalQuestionsGenerated: 0
          }
        };
      }

      // 加载偏好数据
      loadPreferences() {
        try {
          const stored = localStorage.getItem(this.storageKey);
          if (stored) {
            return JSON.parse(stored);
          }
        } catch (error) {
          console.error('加载偏好数据失败:', error);
        }
        return this.getDefaultPreferences();
      }

      // 保存偏好数据
      savePreferences() {
        try {
          localStorage.setItem(this.storageKey, JSON.stringify(this.preferences));
          return true;
        } catch (error) {
          console.error('保存偏好数据失败:', error);
          return false;
        }
      }

      // ============================================
      // 偏好记录功能
      // ============================================

      /**
       * 记录用户操作行为
       * @param {Object} params - 操作参数
       * @param {string} params.type - 题型 (single/multiple/judge/fill/essay/all)
       * @param {number} params.count - 生成数量
       * @param {number} params.difficulty - 难度 (1-5)
       * @param {string} params.knowledgePoint - 知识点
       * @param {Date} params.timestamp - 时间戳
       */
      recordAction(params) {
        // 验证参数
        if (!params || typeof params !== 'object') {
          console.error('recordAction: 参数无效');
          return false;
        }

        // 设置默认时间戳
        if (!params.timestamp) {
          params.timestamp = new Date();
        }

        // 更新元数据
        const metadata = this.preferences.metadata;
        metadata.totalActions++;
        if (!metadata.firstActionDate) {
          metadata.firstActionDate = params.timestamp.toISOString();
        }
        metadata.lastActionDate = params.timestamp.toISOString();

        // 更新生成题目总数
        if (params.count && typeof params.count === 'number') {
          metadata.totalQuestionsGenerated += params.count;
        }

        // 更新各类偏好
        this.updateBasicPreferences(params);
        this.updateScenarioPreferences(params);
        this.updateBehaviorPatterns(params);

        // 重新计算百分比
        this.calculatePercentages();

        // 保存到 LocalStorage
        return this.savePreferences();
      }

      /**
       * 更新基础偏好统计
       * @param {Object} params - 操作参数
       */
      updateBasicPreferences(params) {
        const basic = this.preferences.basicPreferences;

        // 1. 更新题型统计
        if (params.type) {
          const typeKey = params.type;
          if (basic.questionType[typeKey]) {
            basic.questionType[typeKey].count++;
          }
        }

        // 2. 更新难度统计
        if (params.difficulty) {
          const diffKey = String(params.difficulty);
          if (basic.difficulty[diffKey]) {
            basic.difficulty[diffKey].count++;
          }
        }

        // 3. 更新数量统计
        if (params.count && typeof params.count === 'number') {
          const quantity = basic.quantity;

          // 更新总数
          quantity.total += params.count;

          // 更新分布
          const countKey = String(params.count);
          if (!quantity.distribution[countKey]) {
            quantity.distribution[countKey] = 0;
          }
          quantity.distribution[countKey]++;

          // 计算平均值
          const totalSamples = Object.values(quantity.distribution).reduce((sum, val) => sum + val, 0);
          const weightedSum = Object.entries(quantity.distribution).reduce((sum, [count, freq]) => {
            return sum + (parseInt(count) * freq);
          }, 0);
          quantity.average = totalSamples > 0 ? Math.round(weightedSum / totalSamples) : 10;

          // 找出最常用的数量
          let maxFreq = 0;
          let mostCommonCount = 10;
          for (const [count, freq] of Object.entries(quantity.distribution)) {
            if (freq > maxFreq) {
              maxFreq = freq;
              mostCommonCount = parseInt(count);
            }
          }
          quantity.mostCommon = mostCommonCount;
        }

        // 4. 更新知识点统计
        if (params.knowledgePoint) {
          const kpKey = params.knowledgePoint;
          if (!basic.knowledgePoints[kpKey]) {
            basic.knowledgePoints[kpKey] = { count: 0, percentage: 0 };
          }
          basic.knowledgePoints[kpKey].count++;
        }
      }

      /**
       * 更新场景偏好
       * @param {Object} params - 操作参数
       */
      updateScenarioPreferences(params) {
        const scenario = this.preferences.scenarioPreferences.generate_questions;

        // 更新最后使用时间
        scenario.lastUsed = params.timestamp ? params.timestamp.toISOString() : new Date().toISOString();

        // 更新使用频率
        scenario.frequency++;

        // 更新最后使用的参数
        scenario.lastParams = {
          type: params.type || null,
          count: params.count || null,
          difficulty: params.difficulty || null,
          knowledgePoint: params.knowledgePoint || null
        };

        // 更新常用配置（使用最后一次的参数作为常用配置）
        scenario.commonConfig = {
          type: params.type || 'single',
          count: params.count || 10,
          difficulty: params.difficulty || 2,
          knowledgePoint: params.knowledgePoint || null
        };
      }

      /**
       * 更新行为模式
       * @param {Object} params - 操作参数
       */
      updateBehaviorPatterns(params) {
        const patterns = this.preferences.behaviorPatterns;
        const timestamp = params.timestamp || new Date();

        // 1. 更新时间模式（工作日/周末）
        const dayOfWeek = timestamp.getDay(); // 0=周日, 6=周六
        const isWeekend = (dayOfWeek === 0 || dayOfWeek === 6);
        const timeKey = isWeekend ? 'weekend' : 'weekday';
        const timePattern = patterns.timePatterns[timeKey];

        timePattern.samples++;

        // 更新平均难度
        if (params.difficulty) {
          const currentAvg = timePattern.avgDifficulty || 0;
          const currentSamples = timePattern.samples;
          timePattern.avgDifficulty = ((currentAvg * (currentSamples - 1)) + params.difficulty) / currentSamples;
        }

        // 更新平均数量
        if (params.count) {
          const currentAvg = timePattern.avgCount || 0;
          const currentSamples = timePattern.samples;
          timePattern.avgCount = ((currentAvg * (currentSamples - 1)) + params.count) / currentSamples;
        }

        // 更新常用题型
        if (params.type) {
          timePattern.commonType = params.type;
        }

        // 2. 更新知识点关注度（滑动窗口，最多保留10条）
        if (params.knowledgePoint) {
          const recent = patterns.knowledgePointFocus.recent;
          recent.push({
            knowledgePoint: params.knowledgePoint,
            timestamp: timestamp.toISOString()
          });

          // 保持最多10条记录
          if (recent.length > 10) {
            recent.shift();
          }

          // 计算趋势（最近使用最多的知识点）
          const kpCounts = {};
          recent.forEach(item => {
            kpCounts[item.knowledgePoint] = (kpCounts[item.knowledgePoint] || 0) + 1;
          });

          let maxCount = 0;
          let trendingKp = null;
          for (const [kp, count] of Object.entries(kpCounts)) {
            if (count > maxCount) {
              maxCount = count;
              trendingKp = kp;
            }
          }
          patterns.knowledgePointFocus.trending = trendingKp;
        }

        // 3. 更新常用组合
        if (params.type && params.difficulty && params.count) {
          const combination = {
            type: params.type,
            difficulty: params.difficulty,
            count: params.count,
            frequency: 1
          };

          // 查找是否已存在相同组合
          const existingIndex = patterns.commonCombinations.findIndex(c =>
            c.type === combination.type &&
            c.difficulty === combination.difficulty &&
            c.count === combination.count
          );

          if (existingIndex >= 0) {
            // 已存在，增加频率
            patterns.commonCombinations[existingIndex].frequency++;
          } else {
            // 不存在，添加新组合
            patterns.commonCombinations.push(combination);
          }

          // 按频率排序，保留前5个
          patterns.commonCombinations.sort((a, b) => b.frequency - a.frequency);
          if (patterns.commonCombinations.length > 5) {
            patterns.commonCombinations = patterns.commonCombinations.slice(0, 5);
          }
        }
      }

      /**
       * 重新计算所有百分比
       */
      calculatePercentages() {
        const basic = this.preferences.basicPreferences;

        // 1. 计算题型百分比
        const typeTotal = Object.values(basic.questionType).reduce((sum, item) => sum + item.count, 0);
        if (typeTotal > 0) {
          for (const key in basic.questionType) {
            const count = basic.questionType[key].count;
            basic.questionType[key].percentage = Math.round((count / typeTotal) * 100 * 100) / 100;
          }
        }

        // 2. 计算难度百分比
        const diffTotal = Object.values(basic.difficulty).reduce((sum, item) => sum + item.count, 0);
        if (diffTotal > 0) {
          for (const key in basic.difficulty) {
            const count = basic.difficulty[key].count;
            basic.difficulty[key].percentage = Math.round((count / diffTotal) * 100 * 100) / 100;
          }
        }

        // 3. 计算知识点百分比
        const kpTotal = Object.values(basic.knowledgePoints).reduce((sum, item) => sum + item.count, 0);
        if (kpTotal > 0) {
          for (const key in basic.knowledgePoints) {
            const count = basic.knowledgePoints[key].count;
            basic.knowledgePoints[key].percentage = Math.round((count / kpTotal) * 100 * 100) / 100;
          }
        }
      }
    }

    // ============================================
    // 测试框架
    // ============================================
    class TestRunner {
      constructor() {
        this.results = [];
        this.manager = null;
      }

      // 运行单个测试
      runTest(name, testFn) {
        try {
          testFn();
          this.results.push({ name, status: 'pass', message: '测试通过' });
        } catch (error) {
          this.results.push({ name, status: 'fail', message: error.message });
        }
      }

      // 断言函数
      assert(condition, message) {
        if (!condition) {
          throw new Error(message || '断言失败');
        }
      }

      assertEqual(actual, expected, message) {
        if (actual !== expected) {
          throw new Error(message || `期望 ${expected}，实际 ${actual}`);
        }
      }

      assertDeepEqual(actual, expected, message) {
        if (JSON.stringify(actual) !== JSON.stringify(expected)) {
          throw new Error(message || `对象不相等: ${JSON.stringify(actual)} !== ${JSON.stringify(expected)}`);
        }
      }

      // 显示测试结果
      displayResults() {
        const container = document.getElementById('testResults');
        container.innerHTML = '';

        const summary = document.createElement('div');
        summary.className = 'test-section bg-blue-50';
        const passCount = this.results.filter(r => r.status === 'pass').length;
        const failCount = this.results.filter(r => r.status === 'fail').length;
        summary.innerHTML = `
          <h2 class="text-xl font-bold mb-2">测试摘要</h2>
          <p>总计: ${this.results.length} | 通过: ${passCount} | 失败: ${failCount}</p>
        `;
        container.appendChild(summary);

        this.results.forEach(result => {
          const div = document.createElement('div');
          div.className = `test-result test-${result.status}`;
          div.innerHTML = `
            <strong>${result.name}</strong>: ${result.message}
          `;
          container.appendChild(div);
        });
      }

      // 运行所有测试
      runAllTests() {
        this.results = [];
        this.manager = new UserPreferenceManager();

        // 清除存储，从干净状态开始
        localStorage.removeItem('ai_assistant_user_preferences');
        this.manager = new UserPreferenceManager();

        // 测试 1: recordAction 基本功能
        this.runTest('测试1: recordAction 基本功能', () => {
          const result = this.manager.recordAction({
            type: 'single',
            count: 10,
            difficulty: 2,
            knowledgePoint: '数据结构',
            timestamp: new Date('2026-02-03T10:00:00')
          });

          this.assert(result === true, 'recordAction 应该返回 true');
          this.assertEqual(this.manager.preferences.metadata.totalActions, 1, '总操作数应为 1');
          this.assertEqual(this.manager.preferences.metadata.totalQuestionsGenerated, 10, '总生成题目数应为 10');
        });

        // 测试 2: updateBasicPreferences - 题型统计
        this.runTest('测试2: 题型统计更新', () => {
          this.manager.recordAction({
            type: 'single',
            count: 5,
            difficulty: 2,
            timestamp: new Date()
          });

          const singleCount = this.manager.preferences.basicPreferences.questionType.single.count;
          this.assertEqual(singleCount, 2, '单选题计数应为 2');
        });

        // 测试 3: updateBasicPreferences - 难度统计
        this.runTest('测试3: 难度统计更新', () => {
          this.manager.recordAction({
            type: 'multiple',
            count: 8,
            difficulty: 3,
            timestamp: new Date()
          });

          const diff3Count = this.manager.preferences.basicPreferences.difficulty['3'].count;
          this.assertEqual(diff3Count, 1, '难度3计数应为 1');
        });

        // 测试 4: updateBasicPreferences - 数量统计
        this.runTest('测试4: 数量统计更新', () => {
          const quantity = this.manager.preferences.basicPreferences.quantity;

          // 之前已记录: 10, 5, 8
          this.assertEqual(quantity.total, 23, '总数量应为 23');
          this.assert(quantity.distribution['10'] === 1, '数量10的分布应为 1');
          this.assert(quantity.distribution['5'] === 1, '数量5的分布应为 1');
          this.assert(quantity.distribution['8'] === 1, '数量8的分布应为 1');
        });

        // 测试 5: updateBasicPreferences - 知识点统计
        this.runTest('测试5: 知识点统计更新', () => {
          this.manager.recordAction({
            type: 'judge',
            count: 5,
            difficulty: 1,
            knowledgePoint: '数据结构',
            timestamp: new Date()
          });

          const kp = this.manager.preferences.basicPreferences.knowledgePoints['数据结构'];
          this.assertEqual(kp.count, 2, '数据结构知识点计数应为 2');
        });

        // 测试 6: updateScenarioPreferences
        this.runTest('测试6: 场景偏好更新', () => {
          const scenario = this.manager.preferences.scenarioPreferences.generate_questions;

          this.assertEqual(scenario.frequency, 4, '场景使用频率应为 4');
          this.assert(scenario.lastUsed !== null, '最后使用时间应该被设置');
          this.assert(scenario.lastParams !== null, '最后参数应该被设置');
          this.assertEqual(scenario.lastParams.type, 'judge', '最后参数题型应为 judge');
        });

        // 测试 7: updateBehaviorPatterns - 时间模式
        this.runTest('测试7: 时间模式更新', () => {
          // 周一（工作日）
          this.manager.recordAction({
            type: 'single',
            count: 10,
            difficulty: 2,
            timestamp: new Date('2026-02-02T10:00:00') // 周一
          });

          // 周日（周末）
          this.manager.recordAction({
            type: 'multiple',
            count: 15,
            difficulty: 3,
            timestamp: new Date('2026-02-01T10:00:00') // 周日
          });

          const weekday = this.manager.preferences.behaviorPatterns.timePatterns.weekday;
          const weekend = this.manager.preferences.behaviorPatterns.timePatterns.weekend;

          this.assert(weekday.samples > 0, '工作日样本数应大于 0');
          this.assert(weekend.samples > 0, '周末样本数应大于 0');
        });

        // 测试 8: updateBehaviorPatterns - 知识点关注度
        this.runTest('测试8: 知识点关注度更新', () => {
          // 添加多个知识点
          for (let i = 0; i < 5; i++) {
            this.manager.recordAction({
              type: 'single',
              count: 5,
              difficulty: 2,
              knowledgePoint: '算法',
              timestamp: new Date()
            });
          }

          const focus = this.manager.preferences.behaviorPatterns.knowledgePointFocus;
          this.assert(focus.recent.length > 0, '最近知识点列表应有数据');
          this.assert(focus.recent.length <= 10, '最近知识点列表不应超过 10 条');
          this.assertEqual(focus.trending, '算法', '趋势知识点应为"算法"');
        });

        // 测试 9: updateBehaviorPatterns - 常用组合
        this.runTest('测试9: 常用组合更新', () => {
          // 重复相同组合
          for (let i = 0; i < 3; i++) {
            this.manager.recordAction({
              type: 'single',
              count: 10,
              difficulty: 2,
              timestamp: new Date()
            });
          }

          const combinations = this.manager.preferences.behaviorPatterns.commonCombinations;
          this.assert(combinations.length > 0, '常用组合列表应有数据');
          this.assert(combinations.length <= 5, '常用组合列表不应超过 5 条');

          // 找到 single-10-2 组合
          const combo = combinations.find(c =>
            c.type === 'single' && c.count === 10 && c.difficulty === 2
          );
          this.assert(combo !== undefined, '应该找到 single-10-2 组合');
          this.assert(combo.frequency >= 3, '该组合频率应至少为 3');
        });

        // 测试 10: calculatePercentages - 题型百分比
        this.runTest('测试10: 题型百分比计算', () => {
          const questionType = this.manager.preferences.basicPreferences.questionType;

          // 计算总数
          const total = Object.values(questionType).reduce((sum, item) => sum + item.count, 0);

          // 验证百分比总和约为 100
          const percentageSum = Object.values(questionType).reduce((sum, item) => sum + item.percentage, 0);
          this.assert(Math.abs(percentageSum - 100) < 1, `百分比总和应接近 100，实际为 ${percentageSum}`);
        });

        // 测试 11: calculatePercentages - 难度百分比
        this.runTest('测试11: 难度百分比计算', () => {
          const difficulty = this.manager.preferences.basicPreferences.difficulty;

          // 验证百分比总和约为 100
          const percentageSum = Object.values(difficulty).reduce((sum, item) => sum + item.percentage, 0);
          this.assert(Math.abs(percentageSum - 100) < 1, `百分比总和应接近 100，实际为 ${percentageSum}`);
        });

        // 测试 12: calculatePercentages - 知识点百分比
        this.runTest('测试12: 知识点百分比计算', () => {
          const knowledgePoints = this.manager.preferences.basicPreferences.knowledgePoints;

          if (Object.keys(knowledgePoints).length > 0) {
            const percentageSum = Object.values(knowledgePoints).reduce((sum, item) => sum + item.percentage, 0);
            this.assert(Math.abs(percentageSum - 100) < 1, `百分比总和应接近 100，实际为 ${percentageSum}`);
          }
        });

        // 测试 13: 边界情况 - 空参数
        this.runTest('测试13: 边界情况 - 空参数', () => {
          const result = this.manager.recordAction(null);
          this.assertEqual(result, false, '空参数应返回 false');
        });

        // 测试 14: 边界情况 - 缺少时间戳
        this.runTest('测试14: 边界情况 - 缺少时间戳', () => {
          const beforeCount = this.manager.preferences.metadata.totalActions;
          this.manager.recordAction({
            type: 'single',
            count: 5,
            difficulty: 2
          });
          const afterCount = this.manager.preferences.metadata.totalActions;
          this.assertEqual(afterCount, beforeCount + 1, '缺少时间戳时应使用当前时间');
        });

        // 测试 15: 数据持久化
        this.runTest('测试15: 数据持久化', () => {
          // 创建新实例，应该能加载之前保存的数据
          const newManager = new UserPreferenceManager();
          this.assert(newManager.preferences.metadata.totalActions > 0, '新实例应该加载到之前的数据');
        });

        this.displayResults();
      }
    }

    // ============================================
    // 页面交互
    // ============================================
    const testRunner = new TestRunner();

    document.getElementById('runAllTests').addEventListener('click', () => {
      testRunner.runAllTests();
    });

    document.getElementById('clearStorage').addEventListener('click', () => {
      localStorage.removeItem('ai_assistant_user_preferences');
      alert('存储已清除');
      document.getElementById('testResults').innerHTML = '';
    });

    // 页面加载时自动运行测试
    window.addEventListener('load', () => {
      testRunner.runAllTests();
    });
  </script>
</body>
</html>
